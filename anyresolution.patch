From 4de2d8181572fc1c7767c67338bb09f4338a51cf Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Mon, 24 Jul 2023 13:52:29 -0300
Subject: [PATCH 01/27] i_video.c refactor port

---
 src/m_anigif.c    |   74 ++-
 src/sdl/i_video.c | 1197 ++++++++++++++++++++-------------------------
 2 files changed, 601 insertions(+), 670 deletions(-)

diff --git a/src/m_anigif.c b/src/m_anigif.c
index 90e4c69ce4..2862f7bdea 100644
--- a/src/m_anigif.c
+++ b/src/m_anigif.c
@@ -57,7 +57,13 @@ static precise_t gif_prevframetime = 0;
 static UINT32 gif_delayus = 0; // "us" is microseconds
 static UINT8 gif_writeover = 0;
 
-
+typedef struct
+{
+	void *pixels;
+	size_t size;
+	boolean owns_pixels;
+} gif_screen_t;
+static gif_screen_t gif_screens[2];
 
 // OPTIMIZE gif output
 // ---
@@ -535,7 +541,8 @@ static void GIF_rgbconvert(UINT8 *linear, UINT8 *scr)
 static void GIF_framewrite(void)
 {
 	UINT8 *p;
-	UINT8 *movie_screen = screens[2];
+	UINT8 *base_screen = gif_screens[0].pixels;
+	UINT8 *movie_screen = gif_screens[1].pixels;
 	INT32 blitx, blity, blitw, blith;
 	boolean palchanged;
 
@@ -560,7 +567,7 @@ static void GIF_framewrite(void)
 	if (gif_optimize && gif_frames > 0 && (!palchanged))
 	{
 		// before blit movie_screen points to last frame, cur_screen points to this frame
-		UINT8 *cur_screen = screens[0];
+		UINT8 *cur_screen = base_screen;
 		GIF_optimizeregion(cur_screen, movie_screen, &blitx, &blity, &blitw, &blith);
 
 		// blit to temp screen
@@ -586,7 +593,7 @@ static void GIF_framewrite(void)
 		if (rendermode == render_opengl)
 		{
 			UINT8 *linear = HWR_GetScreenshot();
-			GIF_rgbconvert(linear, screens[0]);
+			GIF_rgbconvert(linear, base_screen);
 			free(linear);
 		}
 #endif
@@ -596,7 +603,7 @@ static void GIF_framewrite(void)
 		if (gif_frames == 0 && rendermode == render_soft)
 			I_ReadScreen(movie_screen);
 
-		movie_screen = screens[0];
+		movie_screen = base_screen;
 	}
 
 	// screen regions are handled in GIF_lzw
@@ -744,13 +751,66 @@ INT32 GIF_open(const char *filename)
 	return 1;
 }
 
+static void GIF_checkscreens(void)
+{
+	for (size_t i = 0; i < sizeof(gif_screens) / sizeof(gif_screens[0]); i++)
+	{
+		if (rendermode == render_soft)
+		{
+			if (gif_screens[i].owns_pixels)
+			{
+				Z_Free(gif_screens[i].pixels);
+				gif_screens[i].owns_pixels = false;
+			}
+
+			gif_screens[i].size = 0;
+
+			if (i == 1)
+				gif_screens[i].pixels = screens[2];
+			else
+				gif_screens[i].pixels = screens[0];
+		}
+		else
+		{
+			size_t sz = vid.width * vid.height * vid.bpp;
+
+			if (!gif_screens[i].owns_pixels)
+			{
+				gif_screens[i].size = sz;
+				gif_screens[i].pixels = Z_Malloc(gif_screens[i].size, PU_STATIC, NULL);
+				gif_screens[i].owns_pixels = true;
+			}
+			else if (gif_screens[i].size != sz)
+			{
+				gif_screens[i].size = sz;
+				gif_screens[i].pixels = Z_Realloc(gif_screens[i].pixels, gif_screens[i].size, PU_STATIC, NULL);
+			}
+		}
+	}
+}
+
+static void GIF_freescreens(void)
+{
+	for (size_t i = 0; i < sizeof(gif_screens) / sizeof(gif_screens[0]); i++)
+	{
+		if (gif_screens[i].owns_pixels)
+		{
+			Z_Free(gif_screens[i].pixels);
+			gif_screens[i].owns_pixels = false;
+		}
+
+		gif_screens[i].size = 0;
+		gif_screens[i].pixels = NULL;
+	}
+}
+
 //
 // GIF_frame
 // writes a frame into the output gif
 //
 void GIF_frame(void)
 {
-	// there's not much actually needed here, is there.
+	GIF_checkscreens();
 	GIF_framewrite();
 }
 
@@ -780,6 +840,8 @@ INT32 GIF_close(void)
 		Z_Free(giflzw_hashTable);
 	giflzw_hashTable = NULL;
 
+	GIF_freescreens();
+
 	CONS_Printf(M_GetText("Animated gif closed; wrote %d frames\n"), gif_frames);
 	return 1;
 }
diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index b2215f634a..a90700fa99 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -17,7 +17,7 @@
 // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 // GNU General Public License for more details.
 //-----------------------------------------------------------------------------
-/// \file
+/// \file i_video.c
 /// \brief SRB2 graphics stuff for SDL
 
 #include <stdlib.h>
@@ -77,11 +77,12 @@
 #include "../lua_script.h"
 #include "../lua_libs.h"
 #include "../lua_hook.h"
+
 #include "sdlmain.h"
+
 #ifdef HWRENDER
 #include "../hardware/hw_main.h"
 #include "../hardware/hw_drv.h"
-// For dynamic referencing of HW rendering functions
 #include "hwsym_sdl.h"
 #include "ogl_sdl.h"
 #endif
@@ -89,14 +90,6 @@
 // maximum number of windowed modes (see windowedModes[][])
 #define MAXWINMODES (18)
 
-/**	\brief
-*/
-static INT32 numVidModes = -1;
-
-/**	\brief
-*/
-static char vidModeName[33][32]; // allow 33 different modes
-
 rendermode_t rendermode = render_soft;
 rendermode_t chosenrendermode = render_none; // set by command line arguments
 
@@ -109,48 +102,65 @@ consvar_t cv_vidwait = CVAR_INIT ("vid_wait", "On", CV_SAVE | CV_CALL, CV_OnOff,
 static consvar_t cv_stretch = CVAR_INIT ("stretch", "Off", CV_SAVE|CV_NOSHOWHELP, CV_OnOff, NULL);
 static consvar_t cv_alwaysgrabmouse = CVAR_INIT ("alwaysgrabmouse", "Off", CV_SAVE, CV_OnOff, NULL);
 
+#if defined(__ANDROID__)
+static void Impl_SetColorBufferDepth(INT32 red, INT32 green, INT32 blue, INT32 alpha);
+#endif
+
 UINT8 graphics_started = 0; // Is used in console.c and screen.c
 
 // To disable fullscreen at startup; is set in VID_PrepareModeList
 boolean allow_fullscreen = false;
 static SDL_bool disable_fullscreen = SDL_FALSE;
+
 #define USE_FULLSCREEN (disable_fullscreen||!allow_fullscreen)?0:cv_fullscreen.value
+
 static SDL_bool disable_mouse = SDL_FALSE;
 #define USE_MOUSEINPUT (!disable_mouse && cv_usemouse.value && havefocus)
 #define MOUSE_MENU false //(!disable_mouse && cv_usemouse.value && menuactive && !USE_FULLSCREEN)
 #define MOUSEBUTTONS_MAX MOUSEBUTTONS
 
-// first entry in the modelist which is not bigger than MAXVIDWIDTHxMAXVIDHEIGHT
-static      INT32          firstEntry = 0;
-
 // Total mouse motion X/Y offsets
 static      INT32        mousemovex = 0, mousemovey = 0;
 
 // SDL vars
 static      SDL_Surface *vidSurface = NULL;
 static      SDL_Surface *bufSurface = NULL;
-static      SDL_Surface *icoSurface = NULL;
 static      SDL_Color    localPalette[256];
-#if 0
-static      SDL_Rect   **modeList = NULL;
-static       Uint8       BitsPerPixel = 16;
-#endif
-Uint16      realwidth = BASEVIDWIDTH;
-Uint16      realheight = BASEVIDHEIGHT;
 static       SDL_bool    mousegrabok = SDL_TRUE;
 static       SDL_bool    wrapmouseok = SDL_FALSE;
 #define HalfWarpMouse(x,y) if (wrapmouseok) SDL_WarpMouseInWindow(window, (Uint16)(x/2),(Uint16)(y/2))
-static       SDL_bool    videoblitok = SDL_FALSE;
-static       SDL_bool    exposevideo = SDL_FALSE;
 static       SDL_bool    usesdl2soft = SDL_FALSE;
 static       SDL_bool    borderlesswindow = SDL_FALSE;
 
-// SDL2 vars
+Uint16      realwidth = BASEVIDWIDTH;
+Uint16      realheight = BASEVIDHEIGHT;
+
 SDL_Window   *window;
 SDL_Renderer *renderer;
 static SDL_Texture  *texture;
 static SDL_bool      havefocus = SDL_TRUE;
-static const char *fallback_resolution_name = "Fallback";
+
+static UINT32 refresh_rate;
+
+static boolean video_init = false;
+
+static SDL_bool Impl_CreateWindow(SDL_bool fullscreen);
+
+static void Impl_VideoSetupSurfaces(int width, int height);
+static void Impl_VideoSetupBuffer(void);
+
+static void Impl_SetupSoftwareBuffer(void);
+
+static void Impl_InitOpenGL(void);
+
+#if !defined(__ANDROID__) && defined(HAVE_IMAGE)
+#define USE_WINDOW_ICON
+#endif
+
+#ifdef USE_WINDOW_ICON
+static void Impl_SetWindowIcon(void);
+static SDL_Surface *icoSurface = NULL;
+#endif
 
 // windowed video modes from which to choose from.
 static INT32 windowedModes[MAXWINMODES][2] =
@@ -175,31 +185,183 @@ static INT32 windowedModes[MAXWINMODES][2] =
 	{ 320, 200}, // 1.60,1.00
 };
 
-static void Impl_VideoSetupSDLBuffer(void);
-static void Impl_VideoSetupBuffer(void);
-static SDL_bool Impl_CreateWindow(SDL_bool fullscreen);
-//static void Impl_SetWindowName(const char *title);
-static void Impl_SetWindowIcon(void);
+static char vidModeName[MAXWINMODES][32];
+static const char *fallback_resolution_name = "Fallback";
 
-static void SDLSetMode(INT32 width, INT32 height, SDL_bool fullscreen, SDL_bool reposition)
+#define VIDEO_INIT_ERROR(str) { \
+	if (!graphics_started) \
+		I_Error(str, SDL_GetError()); \
+	else \
+		CONS_Printf(str "\n", SDL_GetError()); \
+}
+
+static SDL_bool Impl_RenderContextCreate(void)
+{
+	if (rendermode != render_opengl)
+	{
+		int flags = 0; // Use this to set SDL_RENDERER_* flags now
+
+		if (usesdl2soft)
+			flags |= SDL_RENDERER_SOFTWARE;
+		else if (cv_vidwait.value)
+		{
+#if SDL_VERSION_ATLEAST(2, 0, 18)
+			// If SDL is new enough, we can turn off vsync later.
+			flags |= SDL_RENDERER_PRESENTVSYNC;
+#else
+			// However, if it isn't, we should just silently turn vid_wait off
+			// This is because the renderer will be created before the config
+			// is read and vid_wait is set from the user's preferences, and thus
+			// vid_wait will have no effect.
+			CV_StealthSetValue(&cv_vidwait, 0);
+#endif
+		}
+
+		if (!renderer)
+			renderer = SDL_CreateRenderer(window, -1, flags);
+
+		if (renderer == NULL)
+		{
+			VIDEO_INIT_ERROR("Couldn't create rendering context: %s");
+			return SDL_FALSE;
+		}
+	}
+
+#ifdef HWRENDER
+	if (rendermode == render_opengl && vid.glstate != VID_GL_LIBRARY_ERROR)
+	{
+		if (sdlglcontext == NULL)
+		{
+			sdlglcontext = SDL_GL_CreateContext(window);
+
+			if (sdlglcontext == NULL)
+			{
+				VIDEO_INIT_ERROR("Couldn't create OpenGL context: %s");
+				return SDL_FALSE;
+			}
+		}
+	}
+#endif
+
+	return SDL_TRUE;
+}
+
+static SDL_bool Impl_RenderContextReset(void)
+{
+	if (renderer)
+	{
+		SDL_DestroyRenderer(renderer);
+		texture = NULL; // Destroying a renderer also destroys all of its textures
+	}
+	renderer = NULL;
+
+	if (Impl_RenderContextCreate() == SDL_FALSE)
+		return SDL_FALSE;
+
+	if (vidSurface != NULL)
+	{
+		SDL_FreeSurface(vidSurface);
+		vidSurface = NULL;
+	}
+
+	if (bufSurface != NULL)
+	{
+		SDL_FreeSurface(bufSurface);
+		bufSurface = NULL;
+	}
+
+#ifdef HWRENDER
+	if (rendermode == render_opengl)
+	{
+		SDL_GL_MakeCurrent(window, sdlglcontext);
+		SDL_GL_SetSwapInterval(cv_vidwait.value ? 1 : 0);
+
+		OglSdlSurface(realwidth, realheight);
+		HWR_Startup();
+	}
+	else
+#endif
+	{
+		SDL_RenderClear(renderer);
+		SDL_RenderSetLogicalSize(renderer, realwidth, realheight);
+		Impl_VideoSetupSurfaces(realwidth, realheight);
+	}
+
+	return SDL_TRUE;
+}
+
+static void Impl_VideoSetupSurfaces(int width, int height)
 {
-	static SDL_bool wasfullscreen = SDL_FALSE;
-	Uint32 rmask;
-	Uint32 gmask;
-	Uint32 bmask;
-	Uint32 amask;
 	int bpp = 16;
 	int sw_texture_format = SDL_PIXELFORMAT_ABGR8888;
 
-	realwidth = vid.width;
-	realheight = vid.height;
+#if !defined(__ANDROID__)
+	if (!usesdl2soft)
+	{
+		sw_texture_format = SDL_PIXELFORMAT_RGB565;
+	}
+	else
+#endif
+	{
+		bpp = 32;
+		sw_texture_format = SDL_PIXELFORMAT_RGBA8888;
+	}
+
+	if (texture == NULL)
+		texture = SDL_CreateTexture(renderer, sw_texture_format, SDL_TEXTUREACCESS_STREAMING, width, height);
+
+	// Set up SW surface
+	if (vidSurface == NULL)
+	{
+		Uint32 rmask;
+		Uint32 gmask;
+		Uint32 bmask;
+		Uint32 amask;
+
+		SDL_PixelFormatEnumToMasks(sw_texture_format, &bpp, &rmask, &gmask, &bmask, &amask);
+		vidSurface = SDL_CreateRGBSurface(0, width, height, bpp, rmask, gmask, bmask, amask);
+	}
+}
+
+static void Impl_SetupSoftwareBuffer(void)
+{
+	// Set up game's software render buffer
+	size_t size;
+
+	vid.rowbytes = vid.width * vid.bpp;
+	vid.direct = NULL;
+
+	free(vid.buffer);
+
+	size = vid.rowbytes*vid.height * NUMSCREENS;
+	vid.buffer = malloc(size);
+
+	if (vid.buffer)
+	{
+		// Clear the buffer
+		// HACK: Wasn't sure where else to put this.
+		memset(vid.buffer, 31, size);
+	}
+	else
+		I_Error("%s", M_GetText("Not enough memory for video buffer\n"));
+}
+
+static SDL_Rect src_rect = { 0, 0, 0, 0 };
+
+static SDL_bool SDLSetMode(INT32 width, INT32 height, SDL_bool fullscreen, SDL_bool reposition)
+{
+	static SDL_bool wasfullscreen = SDL_FALSE;
+	int fullscreen_type = SDL_WINDOW_FULLSCREEN_DESKTOP;
+
+	src_rect.w = realwidth = width;
+	src_rect.h = realheight = height;
 
 	if (window)
 	{
 		if (fullscreen)
 		{
 			wasfullscreen = SDL_TRUE;
-			SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN_DESKTOP);
+			SDL_SetWindowFullscreen(window, fullscreen_type);
 		}
 		else // windowed mode
 		{
@@ -208,10 +370,12 @@ static void SDLSetMode(INT32 width, INT32 height, SDL_bool fullscreen, SDL_bool
 				wasfullscreen = SDL_FALSE;
 				SDL_SetWindowFullscreen(window, 0);
 			}
-			// Reposition window only in windowed mode
+
 			SDL_SetWindowSize(window, width, height);
+
 			if (reposition)
 			{
+				// Reposition window only in windowed mode
 				SDL_SetWindowPosition(window,
 					SDL_WINDOWPOS_CENTERED_DISPLAY(SDL_GetWindowDisplayIndex(window)),
 					SDL_WINDOWPOS_CENTERED_DISPLAY(SDL_GetWindowDisplayIndex(window))
@@ -221,59 +385,25 @@ static void SDLSetMode(INT32 width, INT32 height, SDL_bool fullscreen, SDL_bool
 	}
 	else
 	{
-		Impl_CreateWindow(fullscreen);
+		if (Impl_CreateWindow(fullscreen) == SDL_FALSE)
+			return SDL_FALSE;
+
 		wasfullscreen = fullscreen;
 		SDL_SetWindowSize(window, width, height);
 		if (fullscreen)
-		{
-			SDL_SetWindowFullscreen(window, SDL_WINDOW_FULLSCREEN_DESKTOP);
-		}
+			SDL_SetWindowFullscreen(window, fullscreen_type);
 	}
 
-#ifdef HWRENDER
-	if (rendermode == render_opengl)
-	{
-		OglSdlSurface(vid.width, vid.height);
-	}
-#endif
+	if (Impl_RenderContextReset() == SDL_FALSE)
+		I_Error("Couldn't create or reset rendering context");
 
-	if (rendermode == render_soft)
+	if (vid.buffer)
 	{
-		SDL_RenderClear(renderer);
-		SDL_RenderSetLogicalSize(renderer, width, height);
-		// Set up Texture
-		realwidth = width;
-		realheight = height;
-		if (texture != NULL)
-		{
-			SDL_DestroyTexture(texture);
-		}
-
-		if (!usesdl2soft)
-		{
-			sw_texture_format = SDL_PIXELFORMAT_RGB565;
-		}
-		else
-		{
-			bpp = 32;
-			sw_texture_format = SDL_PIXELFORMAT_RGBA8888;
-		}
-
-		texture = SDL_CreateTexture(renderer, sw_texture_format, SDL_TEXTUREACCESS_STREAMING, width, height);
-
-		// Set up SW surface
-		if (vidSurface != NULL)
-		{
-			SDL_FreeSurface(vidSurface);
-		}
-		if (vid.buffer)
-		{
-			free(vid.buffer);
-			vid.buffer = NULL;
-		}
-		SDL_PixelFormatEnumToMasks(sw_texture_format, &bpp, &rmask, &gmask, &bmask, &amask);
-		vidSurface = SDL_CreateRGBSurface(0, width, height, bpp, rmask, gmask, bmask, amask);
+		free(vid.buffer);
+		vid.buffer = NULL;
 	}
+
+	return SDL_TRUE;
 }
 
 static void VidWaitChanged(void)
@@ -292,6 +422,26 @@ static void VidWaitChanged(void)
 #endif
 }
 
+static UINT32 VID_GetRefreshRate(void)
+{
+	int index = SDL_GetWindowDisplayIndex(window);
+	SDL_DisplayMode m;
+
+	if (SDL_WasInit(SDL_INIT_VIDEO) == 0)
+	{
+		// Video not init yet.
+		return 0;
+	}
+
+	if (SDL_GetCurrentDisplayMode(index, &m) != 0)
+	{
+		// Error has occurred.
+		return 0;
+	}
+
+	return m.refresh_rate;
+}
+
 static INT32 Impl_SDL_Scancode_To_Keycode(SDL_Scancode code)
 {
 	if (code >= SDL_SCANCODE_A && code <= SDL_SCANCODE_Z)
@@ -376,6 +526,7 @@ static INT32 Impl_SDL_Scancode_To_Keycode(SDL_Scancode code)
 		case SDL_SCANCODE_RALT:   return KEY_RALT;
 		case SDL_SCANCODE_LGUI:   return KEY_LEFTWIN;
 		case SDL_SCANCODE_RGUI:   return KEY_RIGHTWIN;
+
 		default:                  break;
 	}
 
@@ -467,65 +618,14 @@ static void SurfaceInfo(const SDL_Surface *infoSurface, const char *SurfaceText)
 
 static void VID_Command_Info_f (void)
 {
-#if 0
-	SDL2STUB();
-#else
-#if 0
-	const SDL_VideoInfo *videoInfo;
-	videoInfo = SDL_GetVideoInfo(); //Alam: Double-Check
-	if (videoInfo)
-	{
-		CONS_Printf("%s", M_GetText("Video Interface Capabilities:\n"));
-		if (videoInfo->hw_available)
-			CONS_Printf("%s", M_GetText(" Hardware surfaces\n"));
-		if (videoInfo->wm_available)
-			CONS_Printf("%s", M_GetText(" Window manager\n"));
-		//UnusedBits1  :6
-		//UnusedBits2  :1
-		if (videoInfo->blit_hw)
-			CONS_Printf("%s", M_GetText(" Accelerated blits HW-2-HW\n"));
-		if (videoInfo->blit_hw_CC)
-			CONS_Printf("%s", M_GetText(" Accelerated blits HW-2-HW with Colorkey\n"));
-		if (videoInfo->wm_available)
-			CONS_Printf("%s", M_GetText(" Accelerated blits HW-2-HW with Alpha\n"));
-		if (videoInfo->blit_sw)
-		{
-			CONS_Printf("%s", M_GetText(" Accelerated blits SW-2-HW\n"));
-			if (!M_CheckParm("-noblit")) videoblitok = SDL_TRUE;
-		}
-		if (videoInfo->blit_sw_CC)
-			CONS_Printf("%s", M_GetText(" Accelerated blits SW-2-HW with Colorkey\n"));
-		if (videoInfo->blit_sw_A)
-			CONS_Printf("%s", M_GetText(" Accelerated blits SW-2-HW with Alpha\n"));
-		if (videoInfo->blit_fill)
-			CONS_Printf("%s", M_GetText(" Accelerated Color filling\n"));
-		//UnusedBits3  :16
-		if (videoInfo->video_mem)
-			CONS_Printf(M_GetText(" There is %i KB of video memory\n"), videoInfo->video_mem);
-		else
-			CONS_Printf("%s", M_GetText(" There no video memory for SDL\n"));
-		//*vfmt
-	}
-#else
-	if (!M_CheckParm("-noblit")) videoblitok = SDL_TRUE;
-#endif
 	SurfaceInfo(bufSurface, M_GetText("Current Engine Mode"));
 	SurfaceInfo(vidSurface, M_GetText("Current Video Mode"));
-#endif
 }
 
 static void VID_Command_ModeList_f(void)
 {
-	// List windowed modes
-	INT32 i = 0;
-	CONS_Printf("NOTE: Under SDL2, all modes are supported on all platforms.\n");
-	CONS_Printf("Under opengl, fullscreen only supports native desktop resolution.\n");
-	CONS_Printf("Under software, the mode is stretched up to desktop resolution.\n");
-	for (i = 0; i < MAXWINMODES; i++)
-	{
+	for (INT32 i = 0; i < MAXWINMODES; i++)
 		CONS_Printf("%2d: %dx%d\n", i, windowedModes[i][0], windowedModes[i][1]);
-	}
-
 }
 
 static void VID_Command_Mode_f (void)
@@ -543,62 +643,26 @@ static void VID_Command_Mode_f (void)
 	if (modenum >= VID_NumModes())
 		CONS_Printf(M_GetText("Video mode not present\n"));
 	else
-		setmodeneeded = modenum+1; // request vid mode change
-}
-
-static inline void SDLJoyRemap(event_t *event)
-{
-	(void)event;
+	{
+		setmodeneeded = modenum + 1; // request vid mode change
+	}
 }
 
-static INT32 SDLJoyAxis(const Sint16 axis, evtype_t which)
+static void Impl_SetFocused(boolean focused)
 {
-	// -32768 to 32767
-	INT32 raxis = axis/32;
-	if (which == ev_joystick)
-	{
-		if (Joystick.bGamepadStyle)
-		{
-			// gamepad control type, on or off, live or die
-			if (raxis < -(JOYAXISRANGE/2))
-				raxis = -1;
-			else if (raxis > (JOYAXISRANGE/2))
-				raxis = 1;
-			else
-				raxis = 0;
-		}
-		else
-		{
-			raxis = JoyInfo.scale!=1?((raxis/JoyInfo.scale)*JoyInfo.scale):raxis;
+	window_notinfocus = !focused;
 
-#ifdef SDL_JDEADZONE
-			if (-SDL_JDEADZONE <= raxis && raxis <= SDL_JDEADZONE)
-				raxis = 0;
-#endif
-		}
-	}
-	else if (which == ev_joystick2)
+	if (window_notinfocus)
 	{
-		if (Joystick2.bGamepadStyle)
-		{
-			// gamepad control type, on or off, live or die
-			if (raxis < -(JOYAXISRANGE/2))
-				raxis = -1;
-			else if (raxis > (JOYAXISRANGE/2))
-				raxis = 1;
-			else raxis = 0;
-		}
-		else
-		{
-			raxis = JoyInfo2.scale!=1?((raxis/JoyInfo2.scale)*JoyInfo2.scale):raxis;
+		if (! cv_playmusicifunfocused.value)
+			S_PauseAudio();
+		if (! cv_playsoundsifunfocused.value)
+			S_StopSounds();
 
-#ifdef SDL_JDEADZONE
-			if (-SDL_JDEADZONE <= raxis && raxis <= SDL_JDEADZONE)
-				raxis = 0;
-#endif
-		}
+		memset(gamekeydown, 0, NUMKEYS); // TODO this is a scary memset
 	}
-	return raxis;
+	else if (!paused)
+		S_ResumeAudio();
 }
 
 static void Impl_HandleWindowEvent(SDL_WindowEvent evt)
@@ -625,20 +689,17 @@ static void Impl_HandleWindowEvent(SDL_WindowEvent evt)
 			break;
 		case SDL_WINDOWEVENT_MAXIMIZED:
 			break;
+		case SDL_WINDOWEVENT_SIZE_CHANGED:
+			break;
 	}
 
 	if (mousefocus && kbfocus)
 	{
 		// Tell game we got focus back, resume music if necessary
-		window_notinfocus = false;
-		if (!paused)
-			S_ResumeAudio(); //resume it
+		Impl_SetFocused(true);
 
-		if (!firsttimeonmouse)
-		{
-			if (cv_usemouse.value) I_StartupMouse();
-		}
-		//else firsttimeonmouse = SDL_FALSE;
+		if (!firsttimeonmouse && cv_usemouse.value)
+			I_StartupMouse();
 
 		if (USE_MOUSEINPUT && !IgnoreMouse())
 			SDLdoGrabMouse();
@@ -646,24 +707,14 @@ static void Impl_HandleWindowEvent(SDL_WindowEvent evt)
 	else if (!mousefocus && !kbfocus)
 	{
 		// Tell game we lost focus, pause music
-		window_notinfocus = true;
-		if (! cv_playmusicifunfocused.value)
-			S_PauseAudio();
-		if (! cv_playsoundsifunfocused.value)
-			S_StopSounds();
+		Impl_SetFocused(false);
 
 		if (!disable_mouse)
-		{
 			SDLforceUngrabMouse();
-		}
-		memset(gamekeydown, 0, NUMKEYS); // TODO this is a scary memset
 
 		if (MOUSE_MENU)
-		{
 			SDLdoUngrabMouse();
-		}
 	}
-
 }
 
 static void Impl_HandleKeyboardEvent(SDL_KeyboardEvent evt, Uint32 type)
@@ -682,7 +733,9 @@ static void Impl_HandleKeyboardEvent(SDL_KeyboardEvent evt, Uint32 type)
 		return;
 	}
 	event.key = Impl_SDL_Scancode_To_Keycode(evt.keysym.scancode);
+
 	event.repeated = (evt.repeat != 0);
+
 	if (event.key) D_PostEvent(&event);
 }
 
@@ -804,31 +857,52 @@ static void Impl_HandleMouseWheelEvent(SDL_MouseWheelEvent evt)
 	}
 }
 
+static INT32 SDLJoyAxis(const Sint16 axis, evtype_t which)
+{
+	// -32768 to 32767
+	INT32 raxis = axis/32;
+	JoyType_t *Joystick_p = (which == ev_joystick2) ? &Joystick2 : &Joystick;
+	SDLJoyInfo_t *JoyInfo_p = (which == ev_joystick2) ? &JoyInfo2 : &JoyInfo;
+
+	if (Joystick_p->bGamepadStyle)
+	{
+		// gamepad control type, on or off, live or die
+		if (raxis < -(JOYAXISRANGE/2))
+			raxis = -1;
+		else if (raxis > (JOYAXISRANGE/2))
+			raxis = 1;
+		else
+			raxis = 0;
+	}
+	else
+		raxis = JoyInfo_p->scale!=1?((raxis/JoyInfo_p->scale)*JoyInfo_p->scale):raxis;
+
+	return raxis;
+}
+
 static void Impl_HandleJoystickAxisEvent(SDL_JoyAxisEvent evt)
 {
 	event_t event;
+
+	evt.axis++;
+	if (evt.axis > JOYAXISSET*2)
+		return;
+
+	event.key = event.x = event.y = INT32_MAX;
+
 	SDL_JoystickID joyid[2];
 
 	// Determine the Joystick IDs for each current open joystick
 	joyid[0] = SDL_JoystickInstanceID(JoyInfo.dev);
 	joyid[1] = SDL_JoystickInstanceID(JoyInfo2.dev);
 
-	evt.axis++;
-	event.key = event.x = event.y = INT32_MAX;
-
 	if (evt.which == joyid[0])
-	{
 		event.type = ev_joystick;
-	}
 	else if (evt.which == joyid[1])
-	{
 		event.type = ev_joystick2;
-	}
-	else return;
-	//axis
-	if (evt.axis > JOYAXISSET*2)
+	else
 		return;
-	//vaule
+
 	if (evt.axis%2)
 	{
 		event.key = evt.axis / 2;
@@ -840,6 +914,7 @@ static void Impl_HandleJoystickAxisEvent(SDL_JoyAxisEvent evt)
 		event.key = evt.axis / 2;
 		event.y = SDLJoyAxis(evt.value, event.type);
 	}
+
 	D_PostEvent(&event);
 }
 
@@ -873,6 +948,7 @@ static void Impl_HandleJoystickHatEvent(SDL_JoyHatEvent evt)
 static void Impl_HandleJoystickButtonEvent(SDL_JoyButtonEvent evt, Uint32 type)
 {
 	event_t event;
+
 	SDL_JoystickID joyid[2];
 
 	// Determine the Joystick IDs for each current open joystick
@@ -888,6 +964,7 @@ static void Impl_HandleJoystickButtonEvent(SDL_JoyButtonEvent evt, Uint32 type)
 		event.key = KEY_2JOY1;
 	}
 	else return;
+
 	if (type == SDL_JOYBUTTONUP)
 	{
 		event.type = ev_keyup;
@@ -897,29 +974,31 @@ static void Impl_HandleJoystickButtonEvent(SDL_JoyButtonEvent evt, Uint32 type)
 		event.type = ev_keydown;
 	}
 	else return;
+
 	if (evt.button < JOYBUTTONS)
 	{
 		event.key += evt.button;
 	}
 	else return;
 
-	SDLJoyRemap(&event);
-	if (event.type != ev_console) D_PostEvent(&event);
+	D_PostEvent(&event);
 }
 
-
+static void Impl_HandleVideoEvent(SDL_Event *evt)
+{
+	switch (evt->type)
+	{
+		case SDL_WINDOWEVENT:
+			Impl_HandleWindowEvent(evt->window);
+			break;
+		default:
+			break;
+	}
+}
 
 void I_GetEvent(void)
 {
 	SDL_Event evt;
-	// We only want the first motion event,
-	// otherwise we'll end up catching the warp back to center.
-	//int mouseMotionOnce = 0;
-
-	if (!graphics_started)
-	{
-		return;
-	}
 
 	mousemovex = mousemovey = 0;
 
@@ -927,9 +1006,10 @@ void I_GetEvent(void)
 	{
 		switch (evt.type)
 		{
-			case SDL_WINDOWEVENT:
-				Impl_HandleWindowEvent(evt.window);
+			default:
+				Impl_HandleVideoEvent(&evt);
 				break;
+			// TODO: Move input code out of this file, desperately
 			case SDL_KEYUP:
 			case SDL_KEYDOWN:
 				Impl_HandleKeyboardEvent(evt.key, evt.type);
@@ -960,9 +1040,10 @@ void I_GetEvent(void)
 				break;
 			case SDL_JOYDEVICEADDED:
 				{
-					SDL_Joystick *newjoy = SDL_JoystickOpen(evt.jdevice.which);
+					INT32 index = evt.jdevice.which;
+					SDL_Joystick *newjoy = SDL_JoystickOpen(index);
 
-					CONS_Debug(DBG_GAMELOGIC, "Joystick device index %d added\n", evt.jdevice.which + 1);
+					CONS_Debug(DBG_GAMELOGIC, "Joystick device index %d added\n", index + 1);
 
 					// Because SDL's device index is unstable, we're going to cheat here a bit:
 					// For the first joystick setting that is NOT active:
@@ -973,7 +1054,7 @@ void I_GetEvent(void)
 					if (newjoy && (!JoyInfo.dev || !SDL_JoystickGetAttached(JoyInfo.dev))
 						&& JoyInfo2.dev != newjoy) // don't override a currently active device
 					{
-						cv_usejoystick.value = evt.jdevice.which + 1;
+						cv_usejoystick.value = index + 1;
 
 						if (JoyInfo2.dev)
 							cv_usejoystick2.value = I_GetJoystickDeviceIndex(JoyInfo2.dev) + 1;
@@ -989,7 +1070,7 @@ void I_GetEvent(void)
 					else if (newjoy && (!JoyInfo2.dev || !SDL_JoystickGetAttached(JoyInfo2.dev))
 						&& JoyInfo.dev != newjoy) // don't override a currently active device
 					{
-						cv_usejoystick2.value = evt.jdevice.which + 1;
+						cv_usejoystick2.value = index + 1;
 
 						if (JoyInfo.dev)
 							cv_usejoystick.value = I_GetJoystickDeviceIndex(JoyInfo.dev) + 1;
@@ -1170,64 +1251,13 @@ void I_OsPolling(void)
 // I_UpdateNoBlit
 //
 void I_UpdateNoBlit(void)
-{
-	if (rendermode == render_none)
-		return;
-	if (exposevideo)
-	{
-#ifdef HWRENDER
-		if (rendermode == render_opengl)
-		{
-			OglSdlFinishUpdate(cv_vidwait.value);
-		}
-		else
-#endif
-		if (rendermode == render_soft)
-		{
-			SDL_RenderCopy(renderer, texture, NULL, NULL);
-			SDL_RenderPresent(renderer);
-		}
-	}
-	exposevideo = SDL_FALSE;
-}
-
-// I_SkipFrame
-//
-// Returns true if it thinks we can afford to skip this frame
-// from PrBoom's src/SDL/i_video.c
-static inline boolean I_SkipFrame(void)
-{
-#if 1
-	// While I fixed the FPS counter bugging out with this,
-	// I actually really like being able to pause and
-	// use perfstats to measure rendering performance
-	// without game logic changes.
-	return false;
-#else
-	static boolean skip = false;
-
-	skip = !skip;
-
-	switch (gamestate)
-	{
-		case GS_LEVEL:
-			if (!paused)
-				return false;
-			/* FALLTHRU */
-		//case GS_TIMEATTACK: -- sorry optimisation but now we have a cool level platter and that being laggardly looks terrible
-		case GS_WAITINGPLAYERS:
-			return skip; // Skip odd frames
-		default:
-			return false;
-	}
-#endif
+{
+
 }
 
 //
 // I_FinishUpdate
 //
-static SDL_Rect src_rect = { 0, 0, 0, 0 };
-
 void I_FinishUpdate(void)
 {
 	if (rendermode == render_none)
@@ -1235,9 +1265,6 @@ void I_FinishUpdate(void)
 
 	SCR_CalculateFPS();
 
-	if (I_SkipFrame())
-		return;
-
 	if (marathonmode)
 		SCR_DisplayMarathonInfo();
 
@@ -1253,19 +1280,14 @@ void I_FinishUpdate(void)
 
 	if (rendermode == render_soft && screens[0])
 	{
-		if (!bufSurface) //Double-Check
-		{
-			Impl_VideoSetupSDLBuffer();
-		}
+		if (!bufSurface) // Double-check
+			Impl_VideoSetupBuffer();
 
-		if (bufSurface)
-		{
-			SDL_BlitSurface(bufSurface, &src_rect, vidSurface, &src_rect);
-			// Fury -- there's no way around UpdateTexture, the GL backend uses it anyway
-			SDL_LockSurface(vidSurface);
-			SDL_UpdateTexture(texture, &src_rect, vidSurface->pixels, vidSurface->pitch);
-			SDL_UnlockSurface(vidSurface);
-		}
+		SDL_BlitSurface(bufSurface, &src_rect, vidSurface, &src_rect);
+		// Fury -- there's no way around UpdateTexture, the GL backend uses it anyway
+		SDL_LockSurface(vidSurface);
+		SDL_UpdateTexture(texture, &src_rect, vidSurface->pixels, vidSurface->pitch);
+		SDL_UnlockSurface(vidSurface);
 
 		SDL_RenderClear(renderer);
 		SDL_RenderCopy(renderer, texture, &src_rect, NULL);
@@ -1273,12 +1295,8 @@ void I_FinishUpdate(void)
 	}
 #ifdef HWRENDER
 	else if (rendermode == render_opengl)
-	{
 		OglSdlFinishUpdate(cv_vidwait.value);
-	}
 #endif
-
-	exposevideo = SDL_FALSE;
 }
 
 //
@@ -1325,39 +1343,18 @@ void I_SetPalette(RGBA_t *palette)
 // return number of fullscreen + X11 modes
 INT32 VID_NumModes(void)
 {
-	if (USE_FULLSCREEN && numVidModes != -1)
-		return numVidModes - firstEntry;
-	else
-		return MAXWINMODES;
+	return MAXWINMODES;
 }
 
 const char *VID_GetModeName(INT32 modeNum)
 {
-#if 0
-	if (USE_FULLSCREEN && numVidModes != -1) // fullscreen modes
-	{
-		modeNum += firstEntry;
-		if (modeNum >= numVidModes)
-			return NULL;
-
-		sprintf(&vidModeName[modeNum][0], "%dx%d",
-			modeList[modeNum]->w,
-			modeList[modeNum]->h);
-	}
-	else // windowed modes
-	{
-#endif
 	if (modeNum == -1)
-	{
 		return fallback_resolution_name;
-	}
-		if (modeNum > MAXWINMODES)
-			return NULL;
+	else if (modeNum > MAXWINMODES)
+		return NULL;
+
+	snprintf(&vidModeName[modeNum][0], 32, "%dx%d", windowedModes[modeNum][0], windowedModes[modeNum][1]);
 
-		sprintf(&vidModeName[modeNum][0], "%dx%d",
-			windowedModes[modeNum][0],
-			windowedModes[modeNum][1]);
-	//}
 	return &vidModeName[modeNum][0];
 }
 
@@ -1372,152 +1369,12 @@ INT32 VID_GetModeForSize(INT32 w, INT32 h)
 		}
 	}
 	return -1;
-#if 0
-	INT32 matchMode = -1, i;
-	VID_PrepareModeList();
-	if (USE_FULLSCREEN && numVidModes != -1)
-	{
-		for (i=firstEntry; i<numVidModes; i++)
-		{
-			if (modeList[i]->w == w &&
-			    modeList[i]->h == h)
-			{
-				matchMode = i;
-				break;
-			}
-		}
-		if (-1 == matchMode) // use smaller mode
-		{
-			w -= w%BASEVIDWIDTH;
-			h -= h%BASEVIDHEIGHT;
-			for (i=firstEntry; i<numVidModes; i++)
-			{
-				if (modeList[i]->w == w &&
-				    modeList[i]->h == h)
-				{
-					matchMode = i;
-					break;
-				}
-			}
-			if (-1 == matchMode) // use smallest mode
-				matchMode = numVidModes-1;
-		}
-		matchMode -= firstEntry;
-	}
-	else
-	{
-		for (i=0; i<MAXWINMODES; i++)
-		{
-			if (windowedModes[i][0] == w &&
-			    windowedModes[i][1] == h)
-			{
-				matchMode = i;
-				break;
-			}
-		}
-		if (-1 == matchMode) // use smaller mode
-		{
-			w -= w%BASEVIDWIDTH;
-			h -= h%BASEVIDHEIGHT;
-			for (i=0; i<MAXWINMODES; i++)
-			{
-				if (windowedModes[i][0] == w &&
-				    windowedModes[i][1] == h)
-				{
-					matchMode = i;
-					break;
-				}
-			}
-			if (-1 == matchMode) // use smallest mode
-				matchMode = MAXWINMODES-1;
-		}
-	}
-	return matchMode;
-#endif
 }
 
 void VID_PrepareModeList(void)
 {
 	// Under SDL2, we just use the windowed modes list, and scale in windowed fullscreen.
 	allow_fullscreen = true;
-#if 0
-	INT32 i;
-
-	firstEntry = 0;
-
-#ifdef HWRENDER
-	if (rendermode == render_opengl)
-		modeList = SDL_ListModes(NULL, SDL_OPENGL|SDL_FULLSCREEN);
-	else
-#endif
-	modeList = SDL_ListModes(NULL, surfaceFlagsF|SDL_HWSURFACE); //Alam: At least hardware surface
-
-	if (disable_fullscreen?0:cv_fullscreen.value) // only fullscreen needs preparation
-	{
-		if (-1 != numVidModes)
-		{
-			for (i=0; i<numVidModes; i++)
-			{
-				if (modeList[i]->w <= MAXVIDWIDTH &&
-					modeList[i]->h <= MAXVIDHEIGHT)
-				{
-					firstEntry = i;
-					break;
-				}
-			}
-		}
-	}
-	allow_fullscreen = true;
-#endif
-}
-
-static SDL_bool Impl_CreateContext(void)
-{
-	// Renderer-specific stuff
-#ifdef HWRENDER
-	if ((rendermode == render_opengl)
-	&& (vid.glstate != VID_GL_LIBRARY_ERROR))
-	{
-		if (!sdlglcontext)
-			sdlglcontext = SDL_GL_CreateContext(window);
-		if (sdlglcontext == NULL)
-		{
-			SDL_DestroyWindow(window);
-			I_Error("Failed to create a GL context: %s\n", SDL_GetError());
-		}
-		SDL_GL_MakeCurrent(window, sdlglcontext);
-	}
-	else
-#endif
-	if (rendermode == render_soft)
-	{
-		int flags = 0; // Use this to set SDL_RENDERER_* flags now
-		if (usesdl2soft)
-			flags |= SDL_RENDERER_SOFTWARE;
-		else if (cv_vidwait.value)
-		{
-#if SDL_VERSION_ATLEAST(2, 0, 18)
-			// If SDL is new enough, we can turn off vsync later.
-			flags |= SDL_RENDERER_PRESENTVSYNC;
-#else
-			// However, if it isn't, we should just silently turn vid_wait off
-			// This is because the renderer will be created before the config
-			// is read and vid_wait is set from the user's preferences, and thus
-			// vid_wait will have no effect.
-			CV_StealthSetValue(&cv_vidwait, 0);
-#endif
-		}
-
-		if (!renderer)
-			renderer = SDL_CreateRenderer(window, -1, flags);
-		if (renderer == NULL)
-		{
-			CONS_Printf(M_GetText("Couldn't create rendering context: %s\n"), SDL_GetError());
-			return SDL_FALSE;
-		}
-		SDL_RenderSetLogicalSize(renderer, BASEVIDWIDTH, BASEVIDHEIGHT);
-	}
-	return SDL_TRUE;
 }
 
 void VID_CheckGLLoaded(rendermode_t oldrender)
@@ -1526,7 +1383,6 @@ void VID_CheckGLLoaded(rendermode_t oldrender)
 #ifdef HWRENDER
 	if (vid.glstate == VID_GL_LIBRARY_ERROR) // Well, it didn't work the first time anyway.
 	{
-		CONS_Alert(CONS_ERROR, "OpenGL never loaded\n");
 		rendermode = oldrender;
 		if (chosenrendermode == render_opengl) // fallback to software
 			rendermode = render_soft;
@@ -1542,13 +1398,15 @@ void VID_CheckGLLoaded(rendermode_t oldrender)
 boolean VID_CheckRenderer(void)
 {
 	boolean rendererchanged = false;
-	boolean contextcreated = false;
+
 #ifdef HWRENDER
 	rendermode_t oldrenderer = rendermode;
 #endif
 
+	refresh_rate = VID_GetRefreshRate();
+
 	if (dedicated)
-		return false;
+		return 0;
 
 	if (setrenderneeded)
 	{
@@ -1560,59 +1418,39 @@ boolean VID_CheckRenderer(void)
 		{
 			VID_CheckGLLoaded(oldrenderer);
 
-			// Initialise OpenGL before calling SDLSetMode!!!
-			// This is because SDLSetMode calls OglSdlSurface.
+			// Initialize OpenGL before calling SDLSetMode, because it calls OglSdlSurface.
 			if (vid.glstate == VID_GL_LIBRARY_NOTLOADED)
-			{
-				VID_StartupOpenGL();
-
-				// Loaded successfully!
-				if (vid.glstate == VID_GL_LIBRARY_LOADED)
-				{
-					// Destroy the current window, if it exists.
-					if (window)
-					{
-						SDL_DestroyWindow(window);
-						window = NULL;
-					}
-
-					// Destroy the current window rendering context, if that also exists.
-					if (renderer)
-					{
-						SDL_DestroyRenderer(renderer);
-						renderer = NULL;
-					}
-
-					// Create a new window.
-					Impl_CreateWindow(USE_FULLSCREEN);
-
-					// From there, the OpenGL context was already created.
-					contextcreated = true;
-				}
-			}
+				Impl_InitOpenGL();
 			else if (vid.glstate == VID_GL_LIBRARY_ERROR)
 				rendererchanged = false;
 		}
-		else
 #endif
 
-		if (!contextcreated)
-			Impl_CreateContext();
-
 		setrenderneeded = 0;
 	}
 
-	SDLSetMode(vid.width, vid.height, USE_FULLSCREEN, (setmodeneeded ? SDL_TRUE : SDL_FALSE));
-	Impl_VideoSetupBuffer();
+	SDL_bool center = setmodeneeded ? SDL_TRUE : SDL_FALSE;
 
-	if (rendermode == render_soft)
+	if (SDLSetMode(vid.width, vid.height, USE_FULLSCREEN, center) == SDL_FALSE)
 	{
-		if (bufSurface)
+		if (!graphics_started)
 		{
-			SDL_FreeSurface(bufSurface);
-			bufSurface = NULL;
+			// Guess I'll die
+			I_Error("Couldn't initialize video");
+		}
+		else
+		{
+			CONS_Printf("Couldn't initialize video\n");
+			return false;
 		}
+	}
 
+	if (rendererchanged)
+		vid.recalc = true;
+
+	if (rendermode == render_soft)
+	{
+		Impl_SetupSoftwareBuffer();
 		SCR_SetDrawFuncs();
 	}
 #ifdef HWRENDER
@@ -1626,32 +1464,44 @@ boolean VID_CheckRenderer(void)
 	return rendererchanged;
 }
 
-static UINT32 refresh_rate;
-static UINT32 VID_GetRefreshRate(void)
+#if 0
+static void Impl_GetCurrentDisplayMode(INT32 *width, INT32 *height)
 {
-	int index = SDL_GetWindowDisplayIndex(window);
-	SDL_DisplayMode m;
+	int i = SDL_GetWindowDisplayIndex(window);
+	SDL_DisplayMode resolution;
 
-	if (SDL_WasInit(SDL_INIT_VIDEO) == 0)
-	{
-		// Video not init yet.
-		return 0;
-	}
+	if (i < 0)
+		return;
 
-	if (SDL_GetCurrentDisplayMode(index, &m) != 0)
+	if (!SDL_GetCurrentDisplayMode(i, &resolution))
 	{
-		// Error has occurred.
-		return 0;
+		if ((*width) == 0)
+			(*width) = (INT32)(resolution.w);
+		if ((*height) == 0)
+			(*height) = (INT32)(resolution.h);
 	}
+}
 
-	return m.refresh_rate;
+void VID_GetNativeResolution(INT32 *width, INT32 *height)
+{
+	INT32 w = 0, h = 0;
+
+	if (!w || !h)
+		Impl_GetCurrentDisplayMode(&w, &h);
+
+	if (!w) w = BASEVIDWIDTH;
+	if (!h) h = BASEVIDHEIGHT;
+
+	if (width) *width = w;
+	if (height) *height = h;
 }
+#endif
 
 INT32 VID_SetMode(INT32 modeNum)
 {
 	SDLdoUngrabMouse();
 
-	vid.recalc = 1;
+	vid.recalc = true;
 	vid.bpp = 1;
 
 	if (modeNum < 0)
@@ -1663,13 +1513,8 @@ INT32 VID_SetMode(INT32 modeNum)
 	vid.height = windowedModes[modeNum][1];
 	vid.modenum = modeNum;
 
-	//Impl_SetWindowName("SRB2 "VERSIONSTRING);
-	src_rect.w = vid.width;
-	src_rect.h = vid.height;
-
-	refresh_rate = VID_GetRefreshRate();
-
 	VID_CheckRenderer();
+
 	return SDL_TRUE;
 }
 
@@ -1677,11 +1522,8 @@ static SDL_bool Impl_CreateWindow(SDL_bool fullscreen)
 {
 	int flags = 0;
 
-	if (rendermode == render_none) // dedicated
-		return SDL_TRUE; // Monster Iestyn -- not sure if it really matters what we return here tbh
-
 	if (window != NULL)
-		return SDL_FALSE;
+		return SDL_TRUE;
 
 	if (fullscreen)
 		flags |= SDL_WINDOW_FULLSCREEN_DESKTOP;
@@ -1690,8 +1532,7 @@ static SDL_bool Impl_CreateWindow(SDL_bool fullscreen)
 		flags |= SDL_WINDOW_BORDERLESS;
 
 #ifdef HWRENDER
-	if (vid.glstate == VID_GL_LIBRARY_LOADED)
-		flags |= SDL_WINDOW_OPENGL;
+	flags |= SDL_WINDOW_OPENGL;
 
 	// Without a 24-bit depth buffer many visuals are ruined by z-fighting.
 	// Some GPU drivers may give us a 16-bit depth buffer since the
@@ -1699,40 +1540,34 @@ static SDL_bool Impl_CreateWindow(SDL_bool fullscreen)
 	SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
 #endif
 
-	// Create a window
-	window = SDL_CreateWindow("SRB2 "VERSIONSTRING, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
-			realwidth, realheight, flags);
-
+#if defined(__ANDROID__)
+	Impl_SetColorBufferDepth(8, 8, 8, 8);
+#endif
 
+	// Create a window
+	window = SDL_CreateWindow("SRB2 "VERSIONSTRING, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, realwidth, realheight, flags);
 	if (window == NULL)
 	{
-		CONS_Printf(M_GetText("Couldn't create window: %s\n"), SDL_GetError());
+		VIDEO_INIT_ERROR("Couldn't create window: %s");
 		return SDL_FALSE;
 	}
 
+#ifdef USE_WINDOW_ICON
 	Impl_SetWindowIcon();
+#endif
 
-	return Impl_CreateContext();
-}
-
-/*
-static void Impl_SetWindowName(const char *title)
-{
-	if (window == NULL)
-	{
-		return;
-	}
-	SDL_SetWindowTitle(window, title);
+	return SDL_TRUE;
 }
-*/
 
+#ifdef USE_WINDOW_ICON
 static void Impl_SetWindowIcon(void)
 {
 	if (window && icoSurface)
 		SDL_SetWindowIcon(window, icoSurface);
 }
+#endif
 
-static void Impl_VideoSetupSDLBuffer(void)
+static void Impl_VideoSetupBuffer(void)
 {
 	if (bufSurface != NULL)
 	{
@@ -1760,18 +1595,59 @@ static void Impl_VideoSetupSDLBuffer(void)
 	}
 }
 
-static void Impl_VideoSetupBuffer(void)
+#ifdef HAVE_GLES
+static void Impl_InitGLESDriver(void)
 {
-	// Set up game's software render buffer
-	vid.rowbytes = vid.width * vid.bpp;
-	vid.direct = NULL;
-	if (vid.buffer)
-		free(vid.buffer);
-	vid.buffer = calloc(vid.rowbytes*vid.height, NUMSCREENS);
-	if (!vid.buffer)
+	const char *driver_name = NULL;
+	int version_major, version_minor;
+
+#ifdef HAVE_GLES2
+	driver_name = "opengles2";
+	version_major = 2;
+	version_minor = 0;
+#else
+	driver_name = "opengles";
+	version_major = 1;
+	version_minor = 1;
+#endif
+
+	SDL_SetHint(SDL_HINT_RENDER_DRIVER, driver_name);
+	SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);
+	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, version_major);
+	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, version_minor);
+}
+#endif
+
+#if defined(__ANDROID__)
+static void Impl_SetColorBufferDepth(INT32 red, INT32 green, INT32 blue, INT32 alpha)
+{
+	SDL_GL_SetAttribute(SDL_GL_RED_SIZE, red);
+	SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, green);
+	SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, blue);
+	SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, alpha);
+}
+#endif
+
+static void Impl_InitVideoSubSystem(void)
+{
+	if (video_init)
+		return;
+
+	if (SDL_InitSubSystem(SDL_INIT_VIDEO) < 0)
 	{
-		I_Error("%s", M_GetText("Not enough memory for video buffer\n"));
+		CONS_Printf(M_GetText("Couldn't initialize SDL's Video System: %s\n"), SDL_GetError());
+		return;
 	}
+
+#ifdef HAVE_GLES
+	Impl_InitGLESDriver();
+#endif
+
+#ifdef MOBILE_PLATFORM
+	SDL_SetHint(SDL_HINT_ORIENTATIONS, "LandscapeLeft LandscapeRight");
+#endif
+
+	video_init = true;
 }
 
 void I_StartupGraphics(void)
@@ -1794,28 +1670,29 @@ void I_StartupGraphics(void)
 	disable_mouse = M_CheckParm("-nomouse");
 	disable_fullscreen = M_CheckParm("-win") ? 1 : 0;
 
+	// [REDACTED] was also initializing the microphone here for some reason
+	// (should really be in system init instead)
 	keyboard_started = true;
 
-#if !defined(HAVE_TTF)
-	// Previously audio was init here for questionable reasons?
-	if (SDL_InitSubSystem(SDL_INIT_VIDEO) < 0)
-	{
-		CONS_Printf(M_GetText("Couldn't initialize SDL's Video System: %s\n"), SDL_GetError());
-		return;
-	}
-#endif
+	// If it wasn't already initialized
+	if (!video_init)
+		Impl_InitVideoSubSystem();
+
+	const char *vd = SDL_GetCurrentVideoDriver();
+	if (vd)
 	{
-		const char *vd = SDL_GetCurrentVideoDriver();
 		//CONS_Printf(M_GetText("Starting up with video driver: %s\n"), vd);
-		if (vd && (
+		if (
 			strncasecmp(vd, "gcvideo", 8) == 0 ||
 			strncasecmp(vd, "fbcon", 6) == 0 ||
 			strncasecmp(vd, "wii", 4) == 0 ||
 			strncasecmp(vd, "psl1ght", 8) == 0
-		))
+		)
 			framebuffer = SDL_TRUE;
 	}
 
+	rendermode = render_soft;
+
 	// Renderer choices
 	// Takes priority over the config.
 	if (M_CheckParm("-renderer"))
@@ -1858,56 +1735,38 @@ void I_StartupGraphics(void)
 	usesdl2soft = M_CheckParm("-softblit");
 	borderlesswindow = M_CheckParm("-borderless");
 
-	//SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY>>1,SDL_DEFAULT_REPEAT_INTERVAL<<2);
-	//VID_Command_ModeList_f();
-
 #ifdef HWRENDER
 	if (rendermode == render_opengl)
-		VID_StartupOpenGL();
+		Impl_InitOpenGL();
 #endif
 
 	// Window icon
-#ifdef HAVE_IMAGE
+#ifdef USE_WINDOW_ICON
 	icoSurface = IMG_ReadXPMFromArray(SDL_icon_xpm);
 #endif
 
 	// Fury: we do window initialization after GL setup to allow
 	// SDL_GL_LoadLibrary to work well on Windows
+	vid.recalc = true;
+	vid.direct = NULL;
+	vid.bpp = 1;
+	vid.WndParent = NULL;
 
 	// Create window
-	//Impl_CreateWindow(USE_FULLSCREEN);
-	//Impl_SetWindowName("SRB2 "VERSIONSTRING);
-	VID_SetMode(VID_GetModeForSize(BASEVIDWIDTH, BASEVIDHEIGHT));
+	// Default size for startup
+	vid.width = BASEVIDWIDTH;
+	vid.height = BASEVIDHEIGHT;
 
-	vid.width = BASEVIDWIDTH; // Default size for startup
-	vid.height = BASEVIDHEIGHT; // BitsPerPixel is the SDL interface's
-	vid.recalc = true; // Set up the console stufff
-	vid.direct = NULL; // Maybe direct access?
-	vid.bpp = 1; // This is the game engine's Bpp
-	vid.WndParent = NULL; //For the window?
+	VID_SetMode(VID_GetModeForSize(vid.width, vid.height));
 
 #ifdef HAVE_TTF
 	I_ShutdownTTF();
 #endif
 
-	VID_SetMode(VID_GetModeForSize(BASEVIDWIDTH, BASEVIDHEIGHT));
-
 	if (M_CheckParm("-nomousegrab"))
 		mousegrabok = SDL_FALSE;
-#if 0 // defined (_DEBUG)
-	else
-	{
-		char videodriver[4] = {'S','D','L',0};
-		if (!M_CheckParm("-mousegrab") &&
-		    *strncpy(videodriver, SDL_GetCurrentVideoDriver(), 4) != '\0' &&
-		    strncasecmp("x11",videodriver,4) == 0)
-			mousegrabok = SDL_FALSE; //X11's XGrabPointer not good
-	}
-#endif
-	realwidth = (Uint16)vid.width;
-	realheight = (Uint16)vid.height;
 
-	//VID_Command_Info_f();
+	VID_Command_Info_f();
 	SDLdoUngrabMouse();
 
 	SDL_RaiseWindow(window);
@@ -1918,80 +1777,88 @@ void I_StartupGraphics(void)
 	graphics_started = true;
 }
 
-void VID_StartupOpenGL(void)
+static void Impl_InitOpenGL(void)
 {
 #ifdef HWRENDER
-	static boolean glstartup = false;
-	if (!glstartup)
-	{
-		CONS_Printf("VID_StartupOpenGL()...\n");
-		HWD.pfnInit             = hwSym("Init",NULL);
-		HWD.pfnFinishUpdate     = NULL;
-		HWD.pfnDraw2DLine       = hwSym("Draw2DLine",NULL);
-		HWD.pfnDrawPolygon      = hwSym("DrawPolygon",NULL);
-		HWD.pfnDrawIndexedTriangles = hwSym("DrawIndexedTriangles",NULL);
-		HWD.pfnRenderSkyDome    = hwSym("RenderSkyDome",NULL);
-		HWD.pfnSetBlend         = hwSym("SetBlend",NULL);
-		HWD.pfnClearBuffer      = hwSym("ClearBuffer",NULL);
-		HWD.pfnSetTexture       = hwSym("SetTexture",NULL);
-		HWD.pfnUpdateTexture    = hwSym("UpdateTexture",NULL);
-		HWD.pfnDeleteTexture    = hwSym("DeleteTexture",NULL);
-		HWD.pfnReadRect         = hwSym("ReadRect",NULL);
-		HWD.pfnGClipRect        = hwSym("GClipRect",NULL);
-		HWD.pfnClearMipMapCache = hwSym("ClearMipMapCache",NULL);
-		HWD.pfnSetSpecialState  = hwSym("SetSpecialState",NULL);
-		HWD.pfnSetPalette       = hwSym("SetPalette",NULL);
-		HWD.pfnGetTextureUsed   = hwSym("GetTextureUsed",NULL);
-		HWD.pfnDrawModel        = hwSym("DrawModel",NULL);
-		HWD.pfnCreateModelVBOs  = hwSym("CreateModelVBOs",NULL);
-		HWD.pfnSetTransform     = hwSym("SetTransform",NULL);
-		HWD.pfnPostImgRedraw    = hwSym("PostImgRedraw",NULL);
-		HWD.pfnFlushScreenTextures=hwSym("FlushScreenTextures",NULL);
-		HWD.pfnStartScreenWipe  = hwSym("StartScreenWipe",NULL);
-		HWD.pfnEndScreenWipe    = hwSym("EndScreenWipe",NULL);
-		HWD.pfnDoScreenWipe     = hwSym("DoScreenWipe",NULL);
-		HWD.pfnDrawIntermissionBG=hwSym("DrawIntermissionBG",NULL);
-		HWD.pfnMakeScreenTexture= hwSym("MakeScreenTexture",NULL);
-		HWD.pfnMakeScreenFinalTexture=hwSym("MakeScreenFinalTexture",NULL);
-		HWD.pfnDrawScreenFinalTexture=hwSym("DrawScreenFinalTexture",NULL);
-
-		HWD.pfnCompileShaders   = hwSym("CompileShaders",NULL);
-		HWD.pfnCleanShaders     = hwSym("CleanShaders",NULL);
-		HWD.pfnSetShader        = hwSym("SetShader",NULL);
-		HWD.pfnUnSetShader      = hwSym("UnSetShader",NULL);
-
-		HWD.pfnSetShaderInfo    = hwSym("SetShaderInfo",NULL);
-		HWD.pfnLoadCustomShader = hwSym("LoadCustomShader",NULL);
-
-		vid.glstate = HWD.pfnInit() ? VID_GL_LIBRARY_LOADED : VID_GL_LIBRARY_ERROR; // let load the OpenGL library
-
-		if (vid.glstate == VID_GL_LIBRARY_ERROR)
-		{
-			rendermode = render_soft;
+	if (vid.glstate == VID_GL_LIBRARY_LOADED)
+		return;
+
+	HWD.pfnInit             = hwSym("Init",NULL);
+	HWD.pfnFinishUpdate     = NULL;
+	HWD.pfnDraw2DLine       = hwSym("Draw2DLine",NULL);
+	HWD.pfnDrawPolygon      = hwSym("DrawPolygon",NULL);
+	HWD.pfnDrawIndexedTriangles = hwSym("DrawIndexedTriangles",NULL);
+	HWD.pfnRenderSkyDome    = hwSym("RenderSkyDome",NULL);
+	HWD.pfnSetBlend         = hwSym("SetBlend",NULL);
+	HWD.pfnClearBuffer      = hwSym("ClearBuffer",NULL);
+	HWD.pfnSetTexture       = hwSym("SetTexture",NULL);
+	HWD.pfnUpdateTexture    = hwSym("UpdateTexture",NULL);
+	HWD.pfnDeleteTexture    = hwSym("DeleteTexture",NULL);
+	HWD.pfnReadRect         = hwSym("ReadRect",NULL);
+	HWD.pfnGClipRect        = hwSym("GClipRect",NULL);
+	HWD.pfnClearMipMapCache = hwSym("ClearMipMapCache",NULL);
+	HWD.pfnSetSpecialState  = hwSym("SetSpecialState",NULL);
+	HWD.pfnSetPalette       = hwSym("SetPalette",NULL);
+	HWD.pfnGetTextureUsed   = hwSym("GetTextureUsed",NULL);
+	HWD.pfnDrawModel        = hwSym("DrawModel",NULL);
+	HWD.pfnCreateModelVBOs  = hwSym("CreateModelVBOs",NULL);
+	HWD.pfnSetTransform     = hwSym("SetTransform",NULL);
+	HWD.pfnPostImgRedraw    = hwSym("PostImgRedraw",NULL);
+	HWD.pfnFlushScreenTextures=hwSym("FlushScreenTextures",NULL);
+	HWD.pfnStartScreenWipe  = hwSym("StartScreenWipe",NULL);
+	HWD.pfnEndScreenWipe    = hwSym("EndScreenWipe",NULL);
+	HWD.pfnDoScreenWipe     = hwSym("DoScreenWipe",NULL);
+	HWD.pfnDrawIntermissionBG=hwSym("DrawIntermissionBG",NULL);
+	HWD.pfnMakeScreenTexture= hwSym("MakeScreenTexture",NULL);
+	HWD.pfnMakeScreenFinalTexture=hwSym("MakeScreenFinalTexture",NULL);
+	HWD.pfnDrawScreenFinalTexture=hwSym("DrawScreenFinalTexture",NULL);
+	HWD.pfnCompileShaders   = hwSym("CompileShaders",NULL);
+	HWD.pfnCleanShaders     = hwSym("CleanShaders",NULL);
+	HWD.pfnSetShader        = hwSym("SetShader",NULL);
+	HWD.pfnUnSetShader      = hwSym("UnSetShader",NULL);
+
+	HWD.pfnSetShaderInfo    = hwSym("SetShaderInfo",NULL);
+	HWD.pfnLoadCustomShader = hwSym("LoadCustomShader",NULL);
+
+	if (HWD.pfnInit())
+		vid.glstate = VID_GL_LIBRARY_LOADED;
+	else
+	{
+		vid.glstate = VID_GL_LIBRARY_ERROR;
+
+		CV_StealthSet(&cv_renderer, "Software");
+		rendermode = render_soft;
+
+		if (setrenderneeded)
 			setrenderneeded = 0;
-		}
-		glstartup = true;
 	}
 #endif
 }
 
 void I_ShutdownGraphics(void)
 {
-	const rendermode_t oldrendermode = rendermode;
-
-	rendermode = render_none;
-	if (icoSurface) SDL_FreeSurface(icoSurface);
+#ifdef USE_WINDOW_ICON
+	if (icoSurface)
+		SDL_FreeSurface(icoSurface);
 	icoSurface = NULL;
-	if (oldrendermode == render_soft)
+#endif
+
+	if (rendermode == render_soft)
 	{
-		if (vidSurface) SDL_FreeSurface(vidSurface);
+		if (vidSurface)
+			SDL_FreeSurface(vidSurface);
 		vidSurface = NULL;
-		if (vid.buffer) free(vid.buffer);
-		vid.buffer = NULL;
-		if (bufSurface) SDL_FreeSurface(bufSurface);
+
+		if (bufSurface)
+			SDL_FreeSurface(bufSurface);
 		bufSurface = NULL;
 	}
 
+	free(vid.buffer);
+	vid.buffer = NULL;
+
+	rendermode = render_none;
+
 	I_OutputMsg("I_ShutdownGraphics(): ");
 
 	// was graphics initialized anyway?
@@ -2004,8 +1871,10 @@ void I_ShutdownGraphics(void)
 	I_OutputMsg("shut down\n");
 
 #ifdef HWRENDER
+#ifndef HAVE_GLES
 	if (GLUhandle)
 		hwClose(GLUhandle);
+#endif
 	if (sdlglcontext)
 	{
 		SDL_GL_DeleteContext(sdlglcontext);
-- 
GitLab


From 36c0dbafcb10af197ff5ee6674e8f7f4b677d8dc Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Mon, 24 Jul 2023 16:10:14 -0300
Subject: [PATCH 02/27] Remove video modes Makes the window able to be dragged
 freely Deletes the remaining view border code and HU_Erase()

---
 src/console.c          |  12 ----
 src/console.h          |   1 -
 src/d_main.c           |   8 +--
 src/dummy/i_video.c    |   5 +-
 src/hardware/hw_draw.c | 132 +-----------------------------------
 src/hu_stuff.c         |  70 --------------------
 src/hu_stuff.h         |   1 -
 src/i_video.h          |  15 +----
 src/m_menu.c           | 142 +++++++++------------------------------
 src/m_menu.h           |   2 +-
 src/r_draw.c           | 143 ---------------------------------------
 src/r_draw.h           |  28 --------
 src/r_main.c           |   2 -
 src/screen.c           | 147 +++++++++++++++++++++++++++++------------
 src/screen.h           |  59 ++++++-----------
 src/sdl/i_video.c      |  83 ++++++++---------------
 src/st_stuff.c         |  10 +--
 src/st_stuff.h         |   1 -
 18 files changed, 193 insertions(+), 668 deletions(-)

diff --git a/src/console.c b/src/console.c
index 67d995f98a..cbfcb6e382 100644
--- a/src/console.c
+++ b/src/console.c
@@ -76,7 +76,6 @@ static UINT8  con_hudlines;             // number of console heads up message li
 static UINT32 con_hudtime[MAXHUDLINES]; // remaining time of display for hud msg lines
 
        INT32 con_clearlines;      // top screen lines to refresh when view reduced
-       boolean con_hudupdate;   // when messages scroll, we need a backgrnd refresh
 
 // console text output
 static char *con_line;          // console text output current line
@@ -1348,9 +1347,6 @@ static void CON_Linefeed(void)
 
 	con_line = &con_buffer[(con_cy%con_totallines)*con_width];
 	memset(con_line, ' ', con_width);
-
-	// make sure the view borders are refreshed if hud messages scroll
-	con_hudupdate = true; // see HU_Erase()
 }
 
 // Outputs text into the console text buffer
@@ -1579,13 +1575,6 @@ void CONS_Debug(INT32 debugflags, const char *fmt, ...)
 //
 void CONS_Error(const char *msg)
 {
-#if defined(RPC_NO_WINDOWS_H) && defined(_WINDOWS)
-	if (!graphics_started)
-	{
-		MessageBoxA(vid.WndParent, msg, "SRB2 Warning", MB_OK);
-		return;
-	}
-#endif
 	CONS_Printf("\x82%s", msg); // write error msg in different colour
 	CONS_Printf(M_GetText("Press ENTER to continue\n"));
 
@@ -1809,7 +1798,6 @@ static void CON_DrawConsole(void)
 
 	//FIXME: refresh borders only when console bg is translucent
 	con_clearlines = con_curlines; // clear console draw from view borders
-	con_hudupdate = true; // always refresh while console is on
 
 	// draw console background
 	if (cons_backpic.value || con_forcepic)
diff --git a/src/console.h b/src/console.h
index f22f8dcbc1..2794770eba 100644
--- a/src/console.h
+++ b/src/console.h
@@ -41,7 +41,6 @@ extern INT32 con_clipviewtop;
 extern INT32 con_destlines;
 
 extern INT32 con_clearlines; // lines of top of screen to refresh
-extern boolean con_hudupdate; // hud messages have changed, need refresh
 extern UINT32 con_scalefactor; // console text scale factor
 
 extern consvar_t cons_backcolor;
diff --git a/src/d_main.c b/src/d_main.c
index 5861f98865..e3143d22ce 100644
--- a/src/d_main.c
+++ b/src/d_main.c
@@ -325,7 +325,7 @@ static void D_Display(void)
 	// 4. The frame is ready to be drawn!
 
 	// Check for change of renderer or screen size (video mode)
-	if ((setrenderneeded || setmodeneeded) && !wipe)
+	if (vid.change.set && !wipe)
 		SCR_SetMode(); // change video mode
 
 	// Recalc the screen
@@ -405,13 +405,11 @@ static void D_Display(void)
 		case GS_LEVEL:
 			if (!gametic)
 				break;
-			HU_Erase();
 			AM_Drawer();
 			break;
 
 		case GS_INTERMISSION:
 			Y_IntermissionDrawer();
-			HU_Erase();
 			HU_Drawer();
 			break;
 
@@ -426,13 +424,11 @@ static void D_Display(void)
 
 		case GS_ENDING:
 			F_EndingDrawer();
-			HU_Erase();
 			HU_Drawer();
 			break;
 
 		case GS_CUTSCENE:
 			F_CutsceneDrawer();
-			HU_Erase();
 			HU_Drawer();
 			break;
 
@@ -442,7 +438,6 @@ static void D_Display(void)
 
 		case GS_EVALUATION:
 			F_GameEvaluationDrawer();
-			HU_Erase();
 			HU_Drawer();
 			break;
 
@@ -452,7 +447,6 @@ static void D_Display(void)
 
 		case GS_CREDITS:
 			F_CreditDrawer();
-			HU_Erase();
 			HU_Drawer();
 			break;
 
diff --git a/src/dummy/i_video.c b/src/dummy/i_video.c
index 3b0a12a328..3a1cbd2232 100644
--- a/src/dummy/i_video.c
+++ b/src/dummy/i_video.c
@@ -35,9 +35,10 @@ INT32 VID_GetModeForSize(INT32 w, INT32 h)
 
 void VID_PrepareModeList(void){}
 
-INT32 VID_SetMode(INT32 modenum)
+void VID_SetSize(INT32 width, INT32 height)
 {
-	(void)modenum;
+	(void)width;
+	(void)height;
 	return 0;
 }
 
diff --git a/src/hardware/hw_draw.c b/src/hardware/hw_draw.c
index eb0b9e3322..d9a0fefe6c 100644
--- a/src/hardware/hw_draw.c
+++ b/src/hardware/hw_draw.c
@@ -22,7 +22,7 @@
 #include "hw_drv.h"
 
 #include "../m_misc.h" //FIL_WriteFile()
-#include "../r_draw.h" //viewborderlump
+#include "../r_draw.h"
 #include "../r_main.h"
 #include "../w_wad.h"
 #include "../z_zone.h"
@@ -1005,136 +1005,6 @@ void HWR_DrawTutorialBack(UINT32 color, INT32 boxheight)
 	HWD.pfnDrawPolygon(&Surf, v, 4, PF_NoTexture|PF_Modulated|PF_Translucent|PF_NoDepthTest);
 }
 
-
-// ==========================================================================
-//                                                             R_DRAW.C STUFF
-// ==========================================================================
-
-// ------------------
-// HWR_DrawViewBorder
-// Fill the space around the view window with a Doom flat texture, draw the
-// beveled edges.
-// 'clearlines' is useful to clear the heads up messages, when the view
-// window is reduced, it doesn't refresh all the view borders.
-// ------------------
-void HWR_DrawViewBorder(INT32 clearlines)
-{
-	INT32 x, y;
-	INT32 top, side;
-	INT32 baseviewwidth, baseviewheight;
-	INT32 basewindowx, basewindowy;
-	patch_t *patch;
-
-//    if (gl_viewwidth == vid.width)
-//        return;
-
-	if (!clearlines)
-		clearlines = BASEVIDHEIGHT; // refresh all
-
-	// calc view size based on original game resolution
-	baseviewwidth =  FixedInt(FixedDiv(FLOAT_TO_FIXED(gl_viewwidth), vid.fdupx)); //(cv_viewsize.value * BASEVIDWIDTH/10)&~7;
-	baseviewheight = FixedInt(FixedDiv(FLOAT_TO_FIXED(gl_viewheight), vid.fdupy));
-	top = FixedInt(FixedDiv(FLOAT_TO_FIXED(gl_baseviewwindowy), vid.fdupy));
-	side = FixedInt(FixedDiv(FLOAT_TO_FIXED(gl_viewwindowx), vid.fdupx));
-
-	// top
-	HWR_DrawFlatFill(0, 0,
-		BASEVIDWIDTH, (top < clearlines ? top : clearlines),
-		st_borderpatchnum);
-
-	// left
-	if (top < clearlines)
-		HWR_DrawFlatFill(0, top, side,
-			(clearlines-top < baseviewheight ? clearlines-top : baseviewheight),
-			st_borderpatchnum);
-
-	// right
-	if (top < clearlines)
-		HWR_DrawFlatFill(side + baseviewwidth, top, side,
-			(clearlines-top < baseviewheight ? clearlines-top : baseviewheight),
-			st_borderpatchnum);
-
-	// bottom
-	if (top + baseviewheight < clearlines)
-		HWR_DrawFlatFill(0, top + baseviewheight,
-			BASEVIDWIDTH, BASEVIDHEIGHT, st_borderpatchnum);
-
-	//
-	// draw the view borders
-	//
-
-	basewindowx = (BASEVIDWIDTH - baseviewwidth)>>1;
-	if (baseviewwidth == BASEVIDWIDTH)
-		basewindowy = 0;
-	else
-		basewindowy = top;
-
-	// top edge
-	if (clearlines > basewindowy - 8)
-	{
-		patch = W_CachePatchNum(viewborderlump[BRDR_T], PU_PATCH);
-		for (x = 0; x < baseviewwidth; x += 8)
-			HWR_DrawPatch(patch, basewindowx + x, basewindowy - 8,
-				0);
-	}
-
-	// bottom edge
-	if (clearlines > basewindowy + baseviewheight)
-	{
-		patch = W_CachePatchNum(viewborderlump[BRDR_B], PU_PATCH);
-		for (x = 0; x < baseviewwidth; x += 8)
-			HWR_DrawPatch(patch, basewindowx + x,
-				basewindowy + baseviewheight, 0);
-	}
-
-	// left edge
-	if (clearlines > basewindowy)
-	{
-		patch = W_CachePatchNum(viewborderlump[BRDR_L], PU_PATCH);
-		for (y = 0; y < baseviewheight && basewindowy + y < clearlines;
-			y += 8)
-		{
-			HWR_DrawPatch(patch, basewindowx - 8, basewindowy + y,
-				0);
-		}
-	}
-
-	// right edge
-	if (clearlines > basewindowy)
-	{
-		patch = W_CachePatchNum(viewborderlump[BRDR_R], PU_PATCH);
-		for (y = 0; y < baseviewheight && basewindowy+y < clearlines;
-			y += 8)
-		{
-			HWR_DrawPatch(patch, basewindowx + baseviewwidth,
-				basewindowy + y, 0);
-		}
-	}
-
-	// Draw beveled corners.
-	if (clearlines > basewindowy - 8)
-		HWR_DrawPatch(W_CachePatchNum(viewborderlump[BRDR_TL],
-				PU_PATCH),
-			basewindowx - 8, basewindowy - 8, 0);
-
-	if (clearlines > basewindowy - 8)
-		HWR_DrawPatch(W_CachePatchNum(viewborderlump[BRDR_TR],
-				PU_PATCH),
-			basewindowx + baseviewwidth, basewindowy - 8, 0);
-
-	if (clearlines > basewindowy+baseviewheight)
-		HWR_DrawPatch(W_CachePatchNum(viewborderlump[BRDR_BL],
-				PU_PATCH),
-			basewindowx - 8, basewindowy + baseviewheight, 0);
-
-	if (clearlines > basewindowy + baseviewheight)
-		HWR_DrawPatch(W_CachePatchNum(viewborderlump[BRDR_BR],
-				PU_PATCH),
-			basewindowx + baseviewwidth,
-			basewindowy + baseviewheight, 0);
-}
-
-
 // ==========================================================================
 //                                                     AM_MAP.C DRAWING STUFF
 // ==========================================================================
diff --git a/src/hu_stuff.c b/src/hu_stuff.c
index 091e2b2fba..38e55872a1 100644
--- a/src/hu_stuff.c
+++ b/src/hu_stuff.c
@@ -2051,76 +2051,6 @@ void HU_Drawer(void)
 	}
 }
 
-//======================================================================
-//                 HUD MESSAGES CLEARING FROM SCREEN
-//======================================================================
-
-// Clear old messages from the borders around the view window
-// (only for reduced view, refresh the borders when needed)
-//
-// startline: y coord to start clear,
-// clearlines: how many lines to clear.
-//
-static INT32 oldclearlines;
-
-void HU_Erase(void)
-{
-	INT32 topline, bottomline;
-	INT32 y, yoffset;
-
-#ifdef HWRENDER
-	// clear hud msgs on double buffer (OpenGL mode)
-	boolean secondframe;
-	static INT32 secondframelines;
-#endif
-
-	if (con_clearlines == oldclearlines && !con_hudupdate && !chat_on)
-		return;
-
-#ifdef HWRENDER
-	// clear the other frame in double-buffer modes
-	secondframe = (con_clearlines != oldclearlines);
-	if (secondframe)
-		secondframelines = oldclearlines;
-#endif
-
-	// clear the message lines that go away, so use _oldclearlines_
-	bottomline = oldclearlines;
-	oldclearlines = con_clearlines;
-	if (chat_on && OLDCHAT)
-		if (bottomline < 8)
-			bottomline = 8; // only do it for consolechat. consolechat is gay.
-
-	if (automapactive || viewwindowx == 0) // hud msgs don't need to be cleared
-		return;
-
-	// software mode copies view border pattern & beveled edges from the backbuffer
-	if (rendermode == render_soft)
-	{
-		topline = 0;
-		for (y = topline, yoffset = y*vid.width; y < bottomline; y++, yoffset += vid.width)
-		{
-			if (y < viewwindowy || y >= viewwindowy + viewheight)
-				R_VideoErase(yoffset, vid.width); // erase entire line
-			else
-			{
-				R_VideoErase(yoffset, viewwindowx); // erase left border
-				// erase right border
-				R_VideoErase(yoffset + viewwindowx + viewwidth, viewwindowx);
-			}
-		}
-		con_hudupdate = false; // if it was set..
-	}
-#ifdef HWRENDER
-	else if (rendermode != render_none)
-	{
-		// refresh just what is needed from the view borders
-		HWR_DrawViewBorder(secondframelines);
-		con_hudupdate = secondframe;
-	}
-#endif
-}
-
 //======================================================================
 //                   IN-LEVEL MULTIPLAYER RANKINGS
 //======================================================================
diff --git a/src/hu_stuff.h b/src/hu_stuff.h
index 8647e4500c..b3069c215f 100644
--- a/src/hu_stuff.h
+++ b/src/hu_stuff.h
@@ -111,7 +111,6 @@ boolean HU_Responder(event_t *ev);
 void HU_Ticker(void);
 void HU_Drawer(void);
 char HU_dequeueChatChar(void);
-void HU_Erase(void);
 void HU_clearChatChars(void);
 void HU_drawPing(INT32 x, INT32 y, UINT32 ping, boolean notext, INT32 flags);	// Lat': Ping drawer for scoreboard.
 void HU_DrawTabRankings(INT32 x, INT32 y, playersort_t *tab, INT32 scorelines, INT32 whiteplayer);
diff --git a/src/i_video.h b/src/i_video.h
index 8efca5f9ab..117961e1d4 100644
--- a/src/i_video.h
+++ b/src/i_video.h
@@ -73,20 +73,9 @@ INT32 VID_NumModes(void);
 */
 INT32 VID_GetModeForSize(INT32 w, INT32 h);
 
-
-/**	\brief	The VID_SetMode function
-
-	Set the video mode right now,
-	the video mode change is delayed until the start of the next refresh
-	by setting the setmodeneeded to a value >0
-	setup a video mode, this is to be called from the menu
-
-
-	\param	modenum	video mode to set to
-
-	\return	current video mode
+/**	\brief Changes the current resolution
 */
-INT32 VID_SetMode(INT32 modenum);
+void VID_SetSize(INT32 width, INT32 height);
 
 /**	\brief Checks the render state
 	\return	true if the renderer changed
diff --git a/src/m_menu.c b/src/m_menu.c
index 12003f945c..6c75936d0c 100644
--- a/src/m_menu.c
+++ b/src/m_menu.c
@@ -167,7 +167,8 @@ static  INT32   (*setupcontrols)[2];  // pointer to the gamecontrols of the play
 
 // shhh... what am I doing... nooooo!
 static INT32 vidm_testingmode = 0;
-static INT32 vidm_previousmode;
+static INT32 vidm_previouswidth;
+static INT32 vidm_previousheight;
 static INT32 vidm_selected = 0;
 static INT32 vidm_nummodes;
 static INT32 vidm_column_size;
@@ -3872,7 +3873,7 @@ void M_Ticker(void)
 	{
 		// restore the previous video mode
 		if (--vidm_testingmode == 0)
-			setmodeneeded = vidm_previousmode + 1;
+			SCR_ChangeResolution(vidm_previouswidth, vidm_previousheight);
 	}
 
 	if (currentMenu == &OP_ScreenshotOptionsDef)
@@ -4106,53 +4107,6 @@ void M_DrawTextBox(INT32 x, INT32 y, INT32 width, INT32 boxlines)
 {
 	// Solid color textbox.
 	V_DrawFill(x+5, y+5, width*8+6, boxlines*8+6, 159);
-	//V_DrawFill(x+8, y+8, width*8, boxlines*8, 31);
-/*
-	patch_t *p;
-	INT32 cx, cy, n;
-	INT32 step, boff;
-
-	step = 8;
-	boff = 8;
-
-	// draw left side
-	cx = x;
-	cy = y;
-	V_DrawScaledPatch(cx, cy, 0, W_CachePatchNum(viewborderlump[BRDR_TL], PU_PATCH));
-	cy += boff;
-	p = W_CachePatchNum(viewborderlump[BRDR_L], PU_PATCH);
-	for (n = 0; n < boxlines; n++)
-	{
-		V_DrawScaledPatch(cx, cy, 0, p);
-		cy += step;
-	}
-	V_DrawScaledPatch(cx, cy, 0, W_CachePatchNum(viewborderlump[BRDR_BL], PU_PATCH));
-
-	// draw middle
-	V_DrawFlatFill(x + boff, y + boff, width*step, boxlines*step, st_borderpatchnum);
-
-	cx += boff;
-	cy = y;
-	while (width > 0)
-	{
-		V_DrawScaledPatch(cx, cy, 0, W_CachePatchNum(viewborderlump[BRDR_T], PU_PATCH));
-		V_DrawScaledPatch(cx, y + boff + boxlines*step, 0, W_CachePatchNum(viewborderlump[BRDR_B], PU_PATCH));
-		width--;
-		cx += step;
-	}
-
-	// draw right side
-	cy = y;
-	V_DrawScaledPatch(cx, cy, 0, W_CachePatchNum(viewborderlump[BRDR_TR], PU_PATCH));
-	cy += boff;
-	p = W_CachePatchNum(viewborderlump[BRDR_R], PU_PATCH);
-	for (n = 0; n < boxlines; n++)
-	{
-		V_DrawScaledPatch(cx, cy, 0, p);
-		cy += step;
-	}
-	V_DrawScaledPatch(cx, cy, 0, W_CachePatchNum(viewborderlump[BRDR_BR], PU_PATCH));
-*/
 }
 
 static fixed_t staticalong = 0;
@@ -13375,8 +13329,7 @@ static modedesc_t modedescs[MAXMODEDESCS];
 
 static void M_VideoModeMenu(INT32 choice)
 {
-	INT32 i, j, vdup, nummodes, width, height;
-	const char *desc;
+	INT32 i;
 
 	(void)choice;
 
@@ -13385,66 +13338,33 @@ static void M_VideoModeMenu(INT32 choice)
 #if defined (__unix__) || defined (UNIXCOMMON) || defined (HAVE_SDL)
 	VID_PrepareModeList(); // FIXME: hack
 #endif
+
 	vidm_nummodes = 0;
 	vidm_selected = 0;
-	nummodes = VID_NumModes();
 
-#ifdef _WINDOWS
-	// clean that later: skip windowed mode 0, video modes menu only shows FULL SCREEN modes
-	if (nummodes <= NUMSPECIALMODES)
-		i = 0; // unless we have nothing
-	else
-		i = NUMSPECIALMODES;
-#else
-	// DOS does not skip mode 0, because mode 0 is ALWAYS present
-	i = 0;
-#endif
-	for (; i < nummodes && vidm_nummodes < MAXMODEDESCS; i++)
+	INT32 nummodes = VID_NumModes();
+
+	for (i = 0; i < nummodes && vidm_nummodes < MAXMODEDESCS; i++)
 	{
-		desc = VID_GetModeName(i);
+		const char *desc = VID_GetModeName(i);
 		if (desc)
 		{
-			vdup = 0;
-
-			// when a resolution exists both under VGA and VESA, keep the
-			// VESA mode, which is always a higher modenum
-			for (j = 0; j < vidm_nummodes; j++)
-			{
-				if (!strcmp(modedescs[j].desc, desc))
-				{
-					// mode(0): 320x200 is always standard VGA, not vesa
-					if (modedescs[j].modenum)
-					{
-						modedescs[j].modenum = i;
-						vdup = 1;
-
-						if (i == vid.modenum)
-							vidm_selected = j;
-					}
-					else
-						vdup = 1;
+			// Pull out the width and height
+			INT32 width, height;
+			sscanf(desc, "%u%*c%u", &width, &height);
 
-					break;
-				}
-			}
-
-			if (!vdup)
-			{
-				modedescs[vidm_nummodes].modenum = i;
-				modedescs[vidm_nummodes].desc = desc;
-
-				if (i == vid.modenum)
-					vidm_selected = vidm_nummodes;
+			modedescs[vidm_nummodes].width = width;
+			modedescs[vidm_nummodes].height = height;
+			modedescs[vidm_nummodes].desc = desc;
 
-				// Pull out the width and height
-				sscanf(desc, "%u%*c%u", &width, &height);
+			if (width == vid.width && height == vid.height)
+				vidm_selected = vidm_nummodes;
 
-				// Show multiples of 320x200 as green.
-				if (SCR_IsAspectCorrect(width, height))
-					modedescs[vidm_nummodes].goodratio = 1;
+			// Show multiples of 320x200 as green.
+			if (SCR_IsAspectCorrect(width, height))
+				modedescs[vidm_nummodes].goodratio = 1;
 
-				vidm_nummodes++;
-			}
+			vidm_nummodes++;
 		}
 	}
 
@@ -13522,11 +13442,11 @@ static void M_DrawVideoMode(void)
 				vid.width, vid.height));
 		V_DrawCenteredString(BASEVIDWIDTH/2, OP_VideoModeDef.y + 116, (cv_fullscreen.value ? 0 : V_TRANSLUCENT),
 			va("Default mode is %c%dx%d",
-				(SCR_IsAspectCorrect(cv_scr_width.value, cv_scr_height.value)) ? 0x83 : (!(VID_GetModeForSize(cv_scr_width.value, cv_scr_height.value)+1) ? 0x85 : 0x80),
+				(SCR_IsAspectCorrect(cv_scr_width.value, cv_scr_height.value)) ? 0x83 : 0x80,
 				cv_scr_width.value, cv_scr_height.value));
 		V_DrawCenteredString(BASEVIDWIDTH/2, OP_VideoModeDef.y + 124, (cv_fullscreen.value ? V_TRANSLUCENT : 0),
 			va("Windowed mode is %c%dx%d",
-				(SCR_IsAspectCorrect(cv_scr_width_w.value, cv_scr_height_w.value)) ? 0x83 : (!(VID_GetModeForSize(cv_scr_width_w.value, cv_scr_height_w.value)+1) ? 0x85 : 0x80),
+				(SCR_IsAspectCorrect(cv_scr_width_w.value, cv_scr_height_w.value)) ? 0x83 : 0x80,
 				cv_scr_width_w.value, cv_scr_height_w.value));
 
 		V_DrawCenteredString(BASEVIDWIDTH/2, OP_VideoModeDef.y + 138,
@@ -13680,7 +13600,7 @@ static void M_HandleVideoMode(INT32 ch)
 	{
 		// change back to the previous mode quickly
 		case KEY_ESCAPE:
-			setmodeneeded = vidm_previousmode + 1;
+			SCR_ChangeResolution(vidm_previouswidth, vidm_previousheight);
 			vidm_testingmode = 0;
 			break;
 
@@ -13722,7 +13642,7 @@ static void M_HandleVideoMode(INT32 ch)
 			break;
 
 		case KEY_ENTER:
-			if (vid.modenum == modedescs[vidm_selected].modenum)
+			if (vid.width == modedescs[vidm_selected].width && vid.height == modedescs[vidm_selected].height)
 			{
 				S_StartSound(NULL, sfx_strpst);
 				SCR_SetDefaultMode();
@@ -13731,9 +13651,11 @@ static void M_HandleVideoMode(INT32 ch)
 			{
 				S_StartSound(NULL, sfx_menu1);
 				vidm_testingmode = 15*TICRATE;
-				vidm_previousmode = vid.modenum;
-				if (!setmodeneeded) // in case the previous setmode was not finished
-					setmodeneeded = modedescs[vidm_selected].modenum + 1;
+				vidm_previouswidth = vid.width;
+				vidm_previousheight = vid.height;
+
+				if (!vid.change.set) // in case the previous setmode was not finished
+					SCR_SetWindowSize(modedescs[vidm_selected].width, modedescs[vidm_selected].height);
 			}
 			break;
 
@@ -13751,9 +13673,9 @@ static void M_HandleVideoMode(INT32 ch)
 			CV_Set(&cv_scr_width_w, cv_scr_width_w.defaultvalue);
 			CV_Set(&cv_scr_height_w, cv_scr_height_w.defaultvalue);
 			if (cv_fullscreen.value)
-				setmodeneeded = VID_GetModeForSize(cv_scr_width.value, cv_scr_height.value)+1;
+				SCR_SetWindowSize(cv_scr_width.value, cv_scr_height.value);
 			else
-				setmodeneeded = VID_GetModeForSize(cv_scr_width_w.value, cv_scr_height_w.value)+1;
+				SCR_SetWindowSize(cv_scr_width_w.value, cv_scr_height_w.value);
 			break;
 
 		case KEY_F10: // Renderer toggle, also processed inside menus
diff --git a/src/m_menu.h b/src/m_menu.h
index c925c7f49c..ebb8dbde35 100644
--- a/src/m_menu.h
+++ b/src/m_menu.h
@@ -413,7 +413,7 @@ extern gtdesc_t gametypedesc[NUMGAMETYPES];
 // mode descriptions for video mode menu
 typedef struct
 {
-	INT32 modenum; // video mode number in the vidmodes list
+	INT32 width, height;
 	const char *desc;  // XXXxYYY
 	UINT8 goodratio; // aspect correct if 1
 } modedesc_t;
diff --git a/src/r_draw.c b/src/r_draw.c
index b0467e4f72..79ad9adde9 100644
--- a/src/r_draw.c
+++ b/src/r_draw.c
@@ -722,100 +722,6 @@ void R_InitViewBuffer(INT32 width, INT32 height)
 	}
 }
 
-/**	\brief viewborder patches lump numbers
-*/
-lumpnum_t viewborderlump[8];
-
-/**	\brief Store the lumpnumber of the viewborder patches
-*/
-
-void R_InitViewBorder(void)
-{
-	viewborderlump[BRDR_T] = W_GetNumForName("brdr_t");
-	viewborderlump[BRDR_B] = W_GetNumForName("brdr_b");
-	viewborderlump[BRDR_L] = W_GetNumForName("brdr_l");
-	viewborderlump[BRDR_R] = W_GetNumForName("brdr_r");
-	viewborderlump[BRDR_TL] = W_GetNumForName("brdr_tl");
-	viewborderlump[BRDR_BL] = W_GetNumForName("brdr_bl");
-	viewborderlump[BRDR_TR] = W_GetNumForName("brdr_tr");
-	viewborderlump[BRDR_BR] = W_GetNumForName("brdr_br");
-}
-
-#if 0
-/**	\brief R_FillBackScreen
-
-	Fills the back screen with a pattern for variable screen sizes
-	Also draws a beveled edge.
-*/
-void R_FillBackScreen(void)
-{
-	UINT8 *src, *dest;
-	patch_t *patch;
-	INT32 x, y, step, boff;
-
-	// quickfix, don't cache lumps in both modes
-	if (rendermode != render_soft)
-		return;
-
-	// draw pattern around the status bar too (when hires),
-	// so return only when in full-screen without status bar.
-	if (scaledviewwidth == vid.width && viewheight == vid.height)
-		return;
-
-	src = scr_borderpatch;
-	dest = screens[1];
-
-	for (y = 0; y < vid.height; y++)
-	{
-		for (x = 0; x < vid.width/128; x++)
-		{
-			M_Memcpy (dest, src+((y&127)<<7), 128);
-			dest += 128;
-		}
-
-		if (vid.width&127)
-		{
-			M_Memcpy(dest, src+((y&127)<<7), vid.width&127);
-			dest += (vid.width&127);
-		}
-	}
-
-	// don't draw the borders when viewwidth is full vid.width.
-	if (scaledviewwidth == vid.width)
-		return;
-
-	step = 8;
-	boff = 8;
-
-	patch = W_CacheLumpNum(viewborderlump[BRDR_T], PU_CACHE);
-	for (x = 0; x < scaledviewwidth; x += step)
-		V_DrawPatch(viewwindowx + x, viewwindowy - boff, 1, patch);
-
-	patch = W_CacheLumpNum(viewborderlump[BRDR_B], PU_CACHE);
-	for (x = 0; x < scaledviewwidth; x += step)
-		V_DrawPatch(viewwindowx + x, viewwindowy + viewheight, 1, patch);
-
-	patch = W_CacheLumpNum(viewborderlump[BRDR_L], PU_CACHE);
-	for (y = 0; y < viewheight; y += step)
-		V_DrawPatch(viewwindowx - boff, viewwindowy + y, 1, patch);
-
-	patch = W_CacheLumpNum(viewborderlump[BRDR_R],PU_CACHE);
-	for (y = 0; y < viewheight; y += step)
-		V_DrawPatch(viewwindowx + scaledviewwidth, viewwindowy + y, 1,
-			patch);
-
-	// Draw beveled corners.
-	V_DrawPatch(viewwindowx - boff, viewwindowy - boff, 1,
-		W_CacheLumpNum(viewborderlump[BRDR_TL], PU_CACHE));
-	V_DrawPatch(viewwindowx + scaledviewwidth, viewwindowy - boff, 1,
-		W_CacheLumpNum(viewborderlump[BRDR_TR], PU_CACHE));
-	V_DrawPatch(viewwindowx - boff, viewwindowy + viewheight, 1,
-		W_CacheLumpNum(viewborderlump[BRDR_BL], PU_CACHE));
-	V_DrawPatch(viewwindowx + scaledviewwidth, viewwindowy + viewheight, 1,
-		W_CacheLumpNum(viewborderlump[BRDR_BR], PU_CACHE));
-}
-#endif
-
 /**	\brief	The R_VideoErase function
 
 	Copy a screen buffer.
@@ -837,55 +743,6 @@ void R_VideoErase(size_t ofs, INT32 count)
 	M_Memcpy(screens[0] + ofs, screens[1] + ofs, count);
 }
 
-#if 0
-/**	\brief The R_DrawViewBorder
-
-  Draws the border around the view
-	for different size windows?
-*/
-void R_DrawViewBorder(void)
-{
-	INT32 top, side, ofs;
-
-	if (rendermode == render_none)
-		return;
-#ifdef HWRENDER
-	if (rendermode != render_soft)
-	{
-		HWR_DrawViewBorder(0);
-		return;
-	}
-	else
-#endif
-
-#ifdef DEBUG
-	fprintf(stderr,"RDVB: vidwidth %d vidheight %d scaledviewwidth %d viewheight %d\n",
-		vid.width, vid.height, scaledviewwidth, viewheight);
-#endif
-
-	if (scaledviewwidth == vid.width)
-		return;
-
-	top = (vid.height - viewheight)>>1;
-	side = (vid.width - scaledviewwidth)>>1;
-
-	// copy top and one line of left side
-	R_VideoErase(0, top*vid.width+side);
-
-	// copy one line of right side and bottom
-	ofs = (viewheight+top)*vid.width - side;
-	R_VideoErase(ofs, top*vid.width + side);
-
-	// copy sides using wraparound
-	ofs = top*vid.width + vid.width-side;
-	side <<= 1;
-
-    // simpler using our VID_Blit routine
-	VID_BlitLinearScreen(screens[1] + ofs, screens[0] + ofs, side, viewheight - 1,
-		vid.width, vid.width);
-}
-#endif
-
 // R_CalcTiltedLighting
 // Exactly what it says on the tin. I wish I wasn't too lazy to explain things properly.
 static INT32 tiltlighting[MAXVIDWIDTH];
diff --git a/src/r_draw.h b/src/r_draw.h
index ea03a8e3d5..09fd2fff2e 100644
--- a/src/r_draw.h
+++ b/src/r_draw.h
@@ -81,25 +81,6 @@ extern UINT32 nflatyshift;
 extern UINT32 nflatshiftup;
 extern UINT32 nflatmask;
 
-/// \brief Top border
-#define BRDR_T 0
-/// \brief Bottom border
-#define BRDR_B 1
-/// \brief Left border
-#define BRDR_L 2
-/// \brief Right border
-#define BRDR_R 3
-/// \brief Topleft border
-#define BRDR_TL 4
-/// \brief Topright border
-#define BRDR_TR 5
-/// \brief Bottomleft border
-#define BRDR_BL 6
-/// \brief Bottomright border
-#define BRDR_BR 7
-
-extern lumpnum_t viewborderlump[8];
-
 // ------------------------------------------------
 // r_draw.c COMMON ROUTINES FOR BOTH 8bpp and 16bpp
 // ------------------------------------------------
@@ -150,17 +131,8 @@ boolean R_BlendLevelVisible(INT32 blendmode, INT32 alphalevel);
 extern UINT8 skincolor_modified[];
 
 void R_InitViewBuffer(INT32 width, INT32 height);
-void R_InitViewBorder(void);
 void R_VideoErase(size_t ofs, INT32 count);
 
-// Rendering function.
-#if 0
-void R_FillBackScreen(void);
-
-// If the view size is not full screen, draws a border around it.
-void R_DrawViewBorder(void);
-#endif
-
 #define TRANSPARENTPIXEL 255
 
 // -----------------
diff --git a/src/r_main.c b/src/r_main.c
index 55bb9c4ffe..39231981c5 100644
--- a/src/r_main.c
+++ b/src/r_main.c
@@ -1016,8 +1016,6 @@ void R_Init(void)
 	//I_OutputMsg("\nR_InitData");
 	R_InitData();
 
-	//I_OutputMsg("\nR_InitViewBorder");
-	R_InitViewBorder();
 	R_SetViewSize(); // setsizeneeded is set true
 
 	//I_OutputMsg("\nR_InitPlanes");
diff --git a/src/screen.c b/src/screen.c
index fe5b399958..1017706eb3 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -62,8 +62,29 @@ void (*spanfuncs_npo2[SPANDRAWFUNC_MAX])(void);
 // global video state
 // ------------------
 viddef_t vid;
-INT32 setmodeneeded; //video mode change needed if > 0 (the mode number to set + 1)
-UINT8 setrenderneeded = 0;
+
+// windowed video modes from which to choose from.
+INT32 windowedModes[MAXWINMODES][2] =
+{
+	{1920,1200}, // 1.60,6.00
+	{1920,1080}, // 1.66
+	{1680,1050}, // 1.60,5.25
+	{1600,1200}, // 1.33
+	{1600, 900}, // 1.66
+	{1366, 768}, // 1.66
+	{1440, 900}, // 1.60,4.50
+	{1280,1024}, // 1.33?
+	{1280, 960}, // 1.33,4.00
+	{1280, 800}, // 1.60,4.00
+	{1280, 720}, // 1.66
+	{1152, 864}, // 1.33,3.60
+	{1024, 768}, // 1.33,3.20
+	{ 800, 600}, // 1.33,2.50
+	{ 640, 480}, // 1.33,2.00
+	{ 640, 400}, // 1.60,2.00
+	{ 320, 240}, // 1.33,1.00
+	{ 320, 200}, // 1.60,1.00
+};
 
 static CV_PossibleValue_t scr_depth_cons_t[] = {{8, "8 bits"}, {16, "16 bits"}, {24, "24 bits"}, {32, "32 bits"}, {0, NULL}};
 
@@ -95,13 +116,9 @@ consvar_t cv_fullscreen = CVAR_INIT ("fullscreen", "Yes", CV_SAVE|CV_CALL, CV_Ye
 // =========================================================================
 
 INT32 scr_bpp; // current video mode bytes per pixel
-UINT8 *scr_borderpatch; // flat used to fill the reduced view borders set at ST_Init()
 
 // =========================================================================
 
-//  Short and Tall sky drawer, for the current color mode
-void (*walldrawerfunc)(void);
-
 boolean R_ASM = true;
 boolean R_486 = false;
 boolean R_586 = false;
@@ -215,35 +232,26 @@ void SCR_SetMode(void)
 	if (dedicated)
 		return;
 
-	if (!(setmodeneeded || setrenderneeded) || WipeInAction)
+	if (!vid.change.set || WipeInAction)
 		return; // should never happen and don't change it during a wipe, BAD!
 
-	// Lactozilla: Renderer switching
-	if (setrenderneeded)
+	if (vid.change.renderer != -1)
 	{
-		// stop recording movies (APNG only)
-		if (setrenderneeded && (moviemode == MM_APNG))
+		if (moviemode == MM_APNG)
 			M_StopMovie();
-
-		// VID_SetMode will call VID_CheckRenderer itself,
-		// so no need to do this in here.
-		if (!setmodeneeded)
-			VID_CheckRenderer();
-
-		vid.recalc = 1;
 	}
 
-	// Set the video mode in the video interface.
-	if (setmodeneeded)
-		VID_SetMode(setmodeneeded - 1);
+	if (vid.change.set)
+		VID_SetSize(vid.change.width, vid.change.height);
 
 	V_SetPalette(0);
 
 	SCR_SetDrawFuncs();
 
-	// set the apprpriate drawer for the sky (tall or INT16)
-	setmodeneeded = 0;
-	setrenderneeded = 0;
+	vid.change.set = VID_RESOLUTION_UNCHANGED;
+	vid.change.width = -1;
+	vid.change.height = -1;
+	vid.change.renderer = -1;
 }
 
 // do some initial settings for the game loading screen
@@ -350,11 +358,41 @@ void SCR_Recalc(void)
 #endif
 }
 
+boolean SCR_IsValidResolution(INT32 width, INT32 height)
+{
+	if (width < BASEVIDWIDTH || width > MAXVIDWIDTH)
+		return false;
+	if (height < BASEVIDHEIGHT || height > MAXVIDHEIGHT)
+		return false;
+	return true;
+}
+
+void SCR_ChangeResolution(INT32 width, INT32 height)
+{
+	if (SCR_IsValidResolution(width, height))
+	{
+		vid.change.width = width;
+		vid.change.height = height;
+		vid.change.renderer = -1;
+		vid.change.set = VID_RESOLUTION_CHANGED;
+	}
+}
+
+void SCR_SetWindowSize(INT32 width, INT32 height)
+{
+	if (SCR_IsValidResolution(width, height))
+	{
+		vid.change.width = width;
+		vid.change.height = height;
+		vid.change.renderer = -1;
+		vid.change.set = VID_RESOLUTION_RESIZED_WINDOW;
+	}
+}
+
 // Check for screen cmd-line parms: to force a resolution.
 //
-// Set the video mode to set at the 1st display loop (setmodeneeded)
+// Set the video mode to set at the 1st display loop
 //
-
 void SCR_CheckDefaultMode(void)
 {
 	INT32 scr_forcex, scr_forcey; // resolution asked from the cmd-line
@@ -374,21 +412,35 @@ void SCR_CheckDefaultMode(void)
 	if (scr_forcex && scr_forcey)
 	{
 		CONS_Printf(M_GetText("Using resolution: %d x %d\n"), scr_forcex, scr_forcey);
-		// returns -1 if not found, thus will be 0 (no mode change) if not found
-		setmodeneeded = VID_GetModeForSize(scr_forcex, scr_forcey) + 1;
+		SCR_ChangeResolution(scr_forcex, scr_forcey);
 	}
 	else
 	{
 		CONS_Printf(M_GetText("Default resolution: %d x %d\n"), cv_scr_width.value, cv_scr_height.value);
 		CONS_Printf(M_GetText("Windowed resolution: %d x %d\n"), cv_scr_width_w.value, cv_scr_height_w.value);
 		CONS_Printf(M_GetText("Default bit depth: %d bits\n"), cv_scr_depth.value);
+
+		INT32 width, height;
+
 		if (cv_fullscreen.value)
-			setmodeneeded = VID_GetModeForSize(cv_scr_width.value, cv_scr_height.value) + 1; // see note above
+		{
+			width = cv_scr_width.value;
+			height = cv_scr_height.value;
+		}
 		else
-			setmodeneeded = VID_GetModeForSize(cv_scr_width_w.value, cv_scr_height_w.value) + 1; // see note above
+		{
+			width = cv_scr_width_w.value;
+			height = cv_scr_height_w.value;
+		}
 
-		if (setmodeneeded <= 0)
+		if (!SCR_IsValidResolution(width, height))
+		{
 			CONS_Alert(CONS_WARNING, "Invalid resolution given, defaulting to base resolution\n");
+			width = BASEVIDWIDTH;
+			height = BASEVIDHEIGHT;
+		}
+
+		SCR_ChangeResolution(width, height);
 	}
 
 	if (cv_renderer.value != (signed)rendermode)
@@ -422,31 +474,40 @@ void SCR_ChangeFullscreen(void)
 	if (graphics_started)
 	{
 		VID_PrepareModeList();
+
+		INT32 width, height;
+
 		if (cv_fullscreen.value)
-			setmodeneeded = VID_GetModeForSize(cv_scr_width.value, cv_scr_height.value) + 1;
+		{
+			width = cv_scr_width.value;
+			height = cv_scr_height.value;
+		}
 		else
-			setmodeneeded = VID_GetModeForSize(cv_scr_width_w.value, cv_scr_height_w.value) + 1;
+		{
+			width = cv_scr_width_w.value;
+			height = cv_scr_height_w.value;
+		}
 
-		if (setmodeneeded <= 0) // hacky safeguard
+		if (!SCR_IsValidResolution(width, height))
 		{
-			CONS_Alert(CONS_WARNING, "Invalid resolution given, defaulting to base resolution.\n");
-			setmodeneeded = VID_GetModeForSize(BASEVIDWIDTH, BASEVIDHEIGHT) + 1;
+			CONS_Alert(CONS_WARNING, "Invalid resolution given, defaulting to base resolution\n");
+			width = BASEVIDWIDTH;
+			height = BASEVIDHEIGHT;
 		}
+
+		SCR_ChangeResolution(width, height);
 	}
-	return;
 #endif
 }
 
 void SCR_ChangeRenderer(void)
 {
-	if (chosenrendermode != render_none
-	|| (signed)rendermode == cv_renderer.value)
+	if (chosenrendermode != render_none || (signed)rendermode == cv_renderer.value)
 		return;
 
 #ifdef HWRENDER
 	// Check if OpenGL loaded successfully (or wasn't disabled) before switching to it.
-	if ((vid.glstate == VID_GL_LIBRARY_ERROR)
-	&& (cv_renderer.value == render_opengl))
+	if (vid.glstate == VID_GL_LIBRARY_ERROR && cv_renderer.value == render_opengl)
 	{
 		if (M_CheckParm("-nogl"))
 			CONS_Alert(CONS_ERROR, "OpenGL rendering was disabled!\n");
@@ -457,11 +518,11 @@ void SCR_ChangeRenderer(void)
 
 	if (rendermode == render_opengl && (vid.glstate == VID_GL_LIBRARY_LOADED)) // Clear these out before switching to software
 		HWR_ClearAllTextures();
-
 #endif
 
 	// Set the new render mode
-	setrenderneeded = cv_renderer.value;
+	vid.change.renderer = cv_renderer.value;
+	vid.change.set = VID_RESOLUTION_CHANGED;
 }
 
 boolean SCR_IsAspectCorrect(INT32 width, INT32 height)
diff --git a/src/screen.h b/src/screen.h
index 65e82ff4df..6205356857 100644
--- a/src/screen.h
+++ b/src/screen.h
@@ -53,20 +53,20 @@ typedef struct viddef_s
 	size_t rowbytes; // bytes per scanline of the VIDEO mode
 	INT32 width; // PIXELS per scanline
 	INT32 height;
-	union { // don't need numpages for OpenGL, so we can use it for fullscreen/windowed mode
-		INT32 numpages; // always 1, page flipping todo
-		INT32 windowed; // windowed or fullscren mode?
-	} u;
 	INT32 recalc; // if true, recalc vid-based stuff
 	UINT8 *direct; // linear frame buffer, or vga base mem.
 	INT32 dupx, dupy; // scale 1, 2, 3 value for menus & overlays
-	INT32/*fixed_t*/ fdupx, fdupy; // same as dupx, dupy, but exact value when aspect ratio isn't 320/200
+	INT32 fdupx, fdupy; // same as dupx, dupy, but exact value when aspect ratio isn't 320/200
 	INT32 bpp; // BYTES per pixel: 1 = 256color, 2 = highcolor
 
-	INT32 baseratio; // Used to get the correct value for lighting walls
+	struct {
+		INT32 width;
+		INT32 height;
+		INT32 renderer;
+		UINT8 set;
+	} change;
 
 	// for Win32 version
-	DNWH WndParent; // handle of the application's window
 	UINT8 smalldupx, smalldupy; // factor for a little bit of scaling
 	UINT8 meddupx, meddupy; // factor for moderate, but not full, scaling
 #ifdef HWRENDER
@@ -76,41 +76,23 @@ typedef struct viddef_s
 #endif
 } viddef_t;
 
+enum
+{
+	VID_RESOLUTION_UNCHANGED = 0,
+	VID_RESOLUTION_CHANGED = 1,
+	VID_RESOLUTION_RESIZED_WINDOW = 2
+};
+
 enum
 {
 	VID_GL_LIBRARY_NOTLOADED  = 0,
 	VID_GL_LIBRARY_LOADED     = 1,
-	VID_GL_LIBRARY_ERROR      = -1,
+	VID_GL_LIBRARY_ERROR      = -1
 };
 
-// internal additional info for vesa modes only
-typedef struct
-{
-	INT32 vesamode; // vesa mode number plus LINEAR_MODE bit
-	void *plinearmem; // linear address of start of frame buffer
-} vesa_extra_t;
-// a video modes from the video modes list,
-// note: video mode 0 is always standard VGA320x200.
-typedef struct vmode_s
-{
-	struct vmode_s *pnext;
-	char *name;
-	UINT32 width, height;
-	UINT32 rowbytes; // bytes per scanline
-	UINT32 bytesperpixel; // 1 for 256c, 2 for highcolor
-	INT32 windowed; // if true this is a windowed mode
-	INT32 numpages;
-	vesa_extra_t *pextradata; // vesa mode extra data
-#ifdef _WIN32
-	INT32 (WINAPI *setmode)(viddef_t *lvid, struct vmode_s *pcurrentmode);
-#else
-	INT32 (*setmode)(viddef_t *lvid, struct vmode_s *pcurrentmode);
-#endif
-	INT32 misc; // misc for display driver (r_opengl.dll etc)
-} vmode_t;
+#define MAXWINMODES 18
 
-#define NUMSPECIALMODES  4
-extern vmode_t specialmodes[NUMSPECIALMODES];
+extern INT32 windowedModes[MAXWINMODES][2];
 
 // ---------------------------------------------
 // color mode dependent drawer function pointers
@@ -187,17 +169,18 @@ extern boolean R_SSE2;
 // screen variables
 // ----------------
 extern viddef_t vid;
-extern INT32 setmodeneeded; // mode number to set if needed, or 0
-extern UINT8 setrenderneeded;
 
 extern double averageFPS;
 
+void SCR_ChangeResolution(INT32 width, INT32 height);
+void SCR_SetWindowSize(INT32 width, INT32 height);
 void SCR_ChangeRenderer(void);
 
+boolean SCR_IsValidResolution(INT32 width, INT32 height);
+
 extern CV_PossibleValue_t cv_renderer_t[];
 
 extern INT32 scr_bpp;
-extern UINT8 *scr_borderpatch; // patch used to fill the view borders
 
 extern consvar_t cv_scr_width, cv_scr_height, cv_scr_width_w, cv_scr_height_w, cv_scr_depth, cv_fullscreen;
 extern consvar_t cv_renderview, cv_renderer;
diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index a90700fa99..846b4c742d 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -87,9 +87,6 @@
 #include "ogl_sdl.h"
 #endif
 
-// maximum number of windowed modes (see windowedModes[][])
-#define MAXWINMODES (18)
-
 rendermode_t rendermode = render_soft;
 rendermode_t chosenrendermode = render_none; // set by command line arguments
 
@@ -162,29 +159,6 @@ static void Impl_SetWindowIcon(void);
 static SDL_Surface *icoSurface = NULL;
 #endif
 
-// windowed video modes from which to choose from.
-static INT32 windowedModes[MAXWINMODES][2] =
-{
-	{1920,1200}, // 1.60,6.00
-	{1920,1080}, // 1.66
-	{1680,1050}, // 1.60,5.25
-	{1600,1200}, // 1.33
-	{1600, 900}, // 1.66
-	{1366, 768}, // 1.66
-	{1440, 900}, // 1.60,4.50
-	{1280,1024}, // 1.33?
-	{1280, 960}, // 1.33,4.00
-	{1280, 800}, // 1.60,4.00
-	{1280, 720}, // 1.66
-	{1152, 864}, // 1.33,3.60
-	{1024, 768}, // 1.33,3.20
-	{ 800, 600}, // 1.33,2.50
-	{ 640, 480}, // 1.33,2.00
-	{ 640, 400}, // 1.60,2.00
-	{ 320, 240}, // 1.33,1.00
-	{ 320, 200}, // 1.60,1.00
-};
-
 static char vidModeName[MAXWINMODES][32];
 static const char *fallback_resolution_name = "Fallback";
 
@@ -644,7 +618,14 @@ static void VID_Command_Mode_f (void)
 		CONS_Printf(M_GetText("Video mode not present\n"));
 	else
 	{
-		setmodeneeded = modenum + 1; // request vid mode change
+		if (modenum < 0)
+			modenum = 0;
+		if (modenum >= MAXWINMODES)
+			modenum = MAXWINMODES-1;
+
+		vid.change.width = windowedModes[modenum][0];
+		vid.change.height = windowedModes[modenum][1];
+		vid.change.set = VID_RESOLUTION_CHANGED;
 	}
 }
 
@@ -690,6 +671,7 @@ static void Impl_HandleWindowEvent(SDL_WindowEvent evt)
 		case SDL_WINDOWEVENT_MAXIMIZED:
 			break;
 		case SDL_WINDOWEVENT_SIZE_CHANGED:
+			SCR_SetWindowSize(evt.data1, evt.data2);
 			break;
 	}
 
@@ -1386,10 +1368,10 @@ void VID_CheckGLLoaded(rendermode_t oldrender)
 		rendermode = oldrender;
 		if (chosenrendermode == render_opengl) // fallback to software
 			rendermode = render_soft;
-		if (setrenderneeded)
+		if (vid.change.renderer != -1)
 		{
 			CV_StealthSetValue(&cv_renderer, oldrender);
-			setrenderneeded = 0;
+			vid.change.renderer = 0;
 		}
 	}
 #endif
@@ -1408,9 +1390,9 @@ boolean VID_CheckRenderer(void)
 	if (dedicated)
 		return 0;
 
-	if (setrenderneeded)
+	if (vid.change.renderer != -1)
 	{
-		rendermode = setrenderneeded;
+		rendermode = vid.change.renderer;
 		rendererchanged = true;
 
 #ifdef HWRENDER
@@ -1426,12 +1408,10 @@ boolean VID_CheckRenderer(void)
 		}
 #endif
 
-		setrenderneeded = 0;
+		vid.change.renderer = -1;
 	}
 
-	SDL_bool center = setmodeneeded ? SDL_TRUE : SDL_FALSE;
-
-	if (SDLSetMode(vid.width, vid.height, USE_FULLSCREEN, center) == SDL_FALSE)
+	if (SDLSetMode(vid.width, vid.height, USE_FULLSCREEN, vid.change.set != VID_RESOLUTION_RESIZED_WINDOW) == SDL_FALSE)
 	{
 		if (!graphics_started)
 		{
@@ -1497,30 +1477,24 @@ void VID_GetNativeResolution(INT32 *width, INT32 *height)
 }
 #endif
 
-INT32 VID_SetMode(INT32 modeNum)
+void VID_SetSize(INT32 width, INT32 height)
 {
 	SDLdoUngrabMouse();
 
 	vid.recalc = true;
-	vid.bpp = 1;
-
-	if (modeNum < 0)
-		modeNum = 0;
-	if (modeNum >= MAXWINMODES)
-		modeNum = MAXWINMODES-1;
 
-	vid.width = windowedModes[modeNum][0];
-	vid.height = windowedModes[modeNum][1];
-	vid.modenum = modeNum;
+	if (width > 0 && height > 0 && SCR_IsValidResolution(width, height))
+	{
+		vid.width = width;
+		vid.height = height;
+	}
 
 	VID_CheckRenderer();
-
-	return SDL_TRUE;
 }
 
 static SDL_bool Impl_CreateWindow(SDL_bool fullscreen)
 {
-	int flags = 0;
+	int flags = SDL_WINDOW_RESIZABLE;
 
 	if (window != NULL)
 		return SDL_TRUE;
@@ -1552,6 +1526,8 @@ static SDL_bool Impl_CreateWindow(SDL_bool fullscreen)
 		return SDL_FALSE;
 	}
 
+	SDL_SetWindowMinimumSize(window, BASEVIDWIDTH, BASEVIDHEIGHT);
+
 #ifdef USE_WINDOW_ICON
 	Impl_SetWindowIcon();
 #endif
@@ -1750,14 +1726,9 @@ void I_StartupGraphics(void)
 	vid.recalc = true;
 	vid.direct = NULL;
 	vid.bpp = 1;
-	vid.WndParent = NULL;
 
 	// Create window
-	// Default size for startup
-	vid.width = BASEVIDWIDTH;
-	vid.height = BASEVIDHEIGHT;
-
-	VID_SetMode(VID_GetModeForSize(vid.width, vid.height));
+	VID_SetSize(BASEVIDWIDTH, BASEVIDHEIGHT);
 
 #ifdef HAVE_TTF
 	I_ShutdownTTF();
@@ -1827,10 +1798,10 @@ static void Impl_InitOpenGL(void)
 		vid.glstate = VID_GL_LIBRARY_ERROR;
 
 		CV_StealthSet(&cv_renderer, "Software");
+
 		rendermode = render_soft;
 
-		if (setrenderneeded)
-			setrenderneeded = 0;
+		vid.change.renderer = -1;
 	}
 #endif
 }
diff --git a/src/st_stuff.c b/src/st_stuff.c
index c6e6befc62..0018f62062 100644
--- a/src/st_stuff.c
+++ b/src/st_stuff.c
@@ -254,10 +254,6 @@ void ST_LoadGraphics(void)
 {
 	int i;
 
-	// SRB2 border patch
-	// st_borderpatchnum = W_GetNumForName("GFZFLR01");
-	// scr_borderpatch = W_CacheLumpNum(st_borderpatchnum, PU_HUDGFX);
-
 	// the original Doom uses 'STF' as base name for all face graphics
 	// Graue 04-08-2004: face/name graphics are now indexed by skins
 	//                   but load them in R_AddSkins, that gets called
@@ -425,12 +421,8 @@ void ST_Start(void)
 }
 
 //
-// Initializes the status bar, sets the defaults border patch for the window borders.
+// Initializes the status bar
 //
-
-// used by OpenGL mode, holds lumpnum of flat used to fill space around the viewwindow
-lumpnum_t st_borderpatchnum;
-
 void ST_Init(void)
 {
 	INT32 i;
diff --git a/src/st_stuff.h b/src/st_stuff.h
index 603be3c309..1bf7c5f228 100644
--- a/src/st_stuff.h
+++ b/src/st_stuff.h
@@ -69,7 +69,6 @@ extern boolean st_overlay; // sb overlay on or off when fullscreen
 extern INT32 st_palette; // 0 is default, any others are special palettes.
 extern INT32 st_translucency;
 
-extern lumpnum_t st_borderpatchnum;
 // patches, also used in intermission
 extern patch_t *tallnum[10];
 extern patch_t *sboscore;
-- 
GitLab


From 923e9c4a3ba172a76020bb5479175b32fffc0c1c Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Mon, 24 Jul 2023 16:54:34 -0300
Subject: [PATCH 03/27] Simpler skyscale calculation

---
 src/r_sky.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/src/r_sky.c b/src/r_sky.c
index c47029f0b3..1b2c43d12b 100644
--- a/src/r_sky.c
+++ b/src/r_sky.c
@@ -75,6 +75,5 @@ void R_SetupSkyDraw(void)
 */
 void R_SetSkyScale(void)
 {
-	fixed_t difference = vid.fdupx-(vid.dupx<<FRACBITS);
-	skyscale = FixedDiv(fovtan, vid.fdupx+difference);
+	skyscale = FixedDiv(fovtan, FixedDiv(vid.width*FRACUNIT, BASEVIDWIDTH*FRACUNIT));
 }
-- 
GitLab


From 0d943e31b17f484a5b0dbdb07b314b5cfcb48315 Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Mon, 24 Jul 2023 16:57:30 -0300
Subject: [PATCH 04/27] Adjust field of view to the aspect ratio

---
 src/r_main.c | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/src/r_main.c b/src/r_main.c
index 39231981c5..dea402eec8 100644
--- a/src/r_main.c
+++ b/src/r_main.c
@@ -941,6 +941,11 @@ void R_ExecuteSetViewSize(void)
 	if (splitscreen == 1) // Splitscreen FOV should be adjusted to maintain expected vertical view
 		fovtan = 17*fovtan/10;
 
+	// Adjust field of view to the aspect ratio
+	fixed_t resmul = FixedDiv(vid.width * FRACUNIT, vid.height * FRACUNIT);
+	if (resmul > FRACUNIT)
+		fovtan = FixedMul(fovtan, resmul);
+
 	projection = projectiony = FixedDiv(centerxfrac, fovtan);
 
 	R_InitViewBuffer(scaledviewwidth, viewheight);
-- 
GitLab


From c162216db9d04bb163603d1cb6c3d459d1d7360a Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 01:06:55 -0300
Subject: [PATCH 05/27] Screen size-related limit removals

---
 src/d_main.c           |   4 +-
 src/doomdef.h          |   7 -
 src/doomstat.h         |   2 +-
 src/hardware/hw_main.c | 780 +----------------------------------------
 src/hardware/hw_main.h |   1 -
 src/r_defs.h           |   4 +-
 src/r_draw.c           |  41 ++-
 src/r_draw.h           |   8 +-
 src/r_fps.c            |   2 +-
 src/r_main.c           |  36 +-
 src/r_plane.c          | 104 ++++--
 src/r_plane.h          |  24 +-
 src/r_segs.c           |  29 +-
 src/r_segs.h           |   5 +-
 src/r_splats.c         |  22 +-
 src/r_splats.h         |   2 +
 src/r_state.h          |   2 +-
 src/r_things.c         |  48 ++-
 src/r_things.h         |   8 +-
 19 files changed, 258 insertions(+), 871 deletions(-)

diff --git a/src/d_main.c b/src/d_main.c
index e3143d22ce..3e97cb49ae 100644
--- a/src/d_main.c
+++ b/src/d_main.c
@@ -498,14 +498,14 @@ static void D_Display(void)
 					if (rendermode != render_none)
 					{
 						viewwindowy = vid.height / 2;
-						M_Memcpy(ylookup, ylookup2, viewheight*sizeof (ylookup[0]));
+						ylookup = ylookup2;
 
 						topleft = screens[0] + viewwindowy*vid.width + viewwindowx;
 
 						R_RenderPlayerView(&players[secondarydisplayplayer]);
 
 						viewwindowy = 0;
-						M_Memcpy(ylookup, ylookup1, viewheight*sizeof (ylookup[0]));
+						ylookup = ylookup1;
 					}
 				}
 
diff --git a/src/doomdef.h b/src/doomdef.h
index 84404d6edb..9f0de06065 100644
--- a/src/doomdef.h
+++ b/src/doomdef.h
@@ -677,13 +677,6 @@ extern const char *compdate, *comptime, *comprevision, *compbranch;
 /// Experimental attempts at preventing MF_PAPERCOLLISION objects from getting stuck in walls.
 //#define PAPER_COLLISIONCORRECTION
 
-/// FINALLY some real clipping that doesn't make walls dissappear AND speeds the game up
-/// (that was the original comment from SRB2CB, sadly it is a lie and actually slows game down)
-/// on the bright side it fixes some weird issues with translucent walls
-/// \note	SRB2CB port.
-///      	SRB2CB itself ported this from PrBoom+
-#define NEWCLIP
-
 /// OpenGL shaders
 #define GL_SHADERS
 
diff --git a/src/doomstat.h b/src/doomstat.h
index a812cc304f..3f40a49b7a 100644
--- a/src/doomstat.h
+++ b/src/doomstat.h
@@ -130,7 +130,7 @@ extern postimg_t postimgtype2;
 extern INT32 postimgparam2;
 
 extern INT32 viewwindowx, viewwindowy;
-extern INT32 viewwidth, scaledviewwidth;
+extern INT32 viewwidth;
 
 // Player taking events, and displaying.
 extern INT32 consoleplayer;
diff --git a/src/hardware/hw_main.c b/src/hardware/hw_main.c
index 36ff86abd7..a118784fea 100644
--- a/src/hardware/hw_main.c
+++ b/src/hardware/hw_main.c
@@ -41,11 +41,9 @@
 #include "../r_things.h" // R_GetShadowZ
 #include "../d_main.h"
 #include "../p_slopes.h"
-#include "hw_md2.h"
 
-#ifdef NEWCLIP
+#include "hw_md2.h"
 #include "hw_clip.h"
-#endif
 
 #define R_FAKEFLOORS
 #define HWPRECIP
@@ -81,19 +79,6 @@ boolean drawsky = true;
 #define FIELDOFVIEW ANGLE_90
 #define ABS(x) ((x) < 0 ? -(x) : (x))
 
-static angle_t gl_clipangle;
-
-// The viewangletox[viewangle + FINEANGLES/4] lookup
-// maps the visible view angles to screen X coordinates,
-// flattening the arc to a flat projection plane.
-// There will be many angles mapped to the same X.
-static INT32 gl_viewangletox[FINEANGLES/2];
-
-// The xtoviewangleangle[] table maps a screen pixel
-// to the lowest viewangle that maps back to x ranges
-// from clipangle to -clipangle.
-static angle_t gl_xtoviewangle[MAXVIDWIDTH+1];
-
 // ==========================================================================
 //                                                                    GLOBALS
 // ==========================================================================
@@ -786,41 +771,6 @@ static void HWR_ProjectWall(FOutVector *wallVerts, FSurfaceInfo *pSurf, FBITFIEL
 //                                                          BSP, CULL, ETC..
 // ==========================================================================
 
-// return the frac from the interception of the clipping line
-// (in fact a clipping plane that has a constant, so can clip with simple 2d)
-// with the wall segment
-//
-#ifndef NEWCLIP
-static float HWR_ClipViewSegment(INT32 x, polyvertex_t *v1, polyvertex_t *v2)
-{
-	float num, den;
-	float v1x, v1y, v1dx, v1dy, v2dx, v2dy;
-	angle_t pclipangle = gl_xtoviewangle[x];
-
-	// a segment of a polygon
-	v1x  = v1->x;
-	v1y  = v1->y;
-	v1dx = (v2->x - v1->x);
-	v1dy = (v2->y - v1->y);
-
-	// the clipping line
-	pclipangle = pclipangle + dup_viewangle; //back to normal angle (non-relative)
-	v2dx = FIXED_TO_FLOAT(FINECOSINE(pclipangle>>ANGLETOFINESHIFT));
-	v2dy = FIXED_TO_FLOAT(FINESINE(pclipangle>>ANGLETOFINESHIFT));
-
-	den = v2dy*v1dx - v2dx*v1dy;
-	if (den == 0)
-		return -1; // parallel
-
-	// calc the frac along the polygon segment,
-	//num = (v2x - v1x)*v2dy + (v1y - v2y)*v2dx;
-	//num = -v1x * v2dy + v1y * v2dx;
-	num = (gl_viewx - v1x)*v2dy + (v1y - gl_viewy)*v2dx;
-
-	return num / den;
-}
-#endif
-
 // SoM: split up and light walls according to the lightlist.
 // This may also include leaving out parts of the wall that can't be seen
 static void HWR_SplitWall(sector_t *sector, FOutVector *wallVerts, INT32 texnum, FSurfaceInfo* Surf, INT32 cutflag, ffloor_t *pfloor, FBITFIELD polyflags)
@@ -1846,7 +1796,6 @@ static void HWR_ProcessSeg(void) // Sort of like GLWall::Process in GZDoom
 //
 // e6y: Check whether the player can look beyond this line
 //
-#ifdef NEWCLIP
 boolean checkforemptylines = true;
 // Don't modify anything here, just check
 // Kalaron: Modified for sloped linedefs
@@ -1929,295 +1878,6 @@ static boolean CheckClip(seg_t * seg, sector_t * afrontsector, sector_t * abacks
 
 	return false;
 }
-#else
-//Hurdler: just like in r_bsp.c
-#if 1
-#define MAXSEGS         MAXVIDWIDTH/2+1
-#else
-//Alam_GBC: Or not (may cause overflow)
-#define MAXSEGS         128
-#endif
-
-// hw_newend is one past the last valid seg
-static cliprange_t *   hw_newend;
-static cliprange_t     gl_solidsegs[MAXSEGS];
-
-// needs fix: walls are incorrectly clipped one column less
-static consvar_t cv_glclipwalls = CVAR_INIT ("gr_clipwalls", "Off", 0, CV_OnOff, NULL);
-
-static void printsolidsegs(void)
-{
-	cliprange_t *       start;
-	if (!hw_newend)
-		return;
-	for (start = gl_solidsegs;start != hw_newend;start++)
-	{
-		CONS_Debug(DBG_RENDER, "%d-%d|",start->first,start->last);
-	}
-	CONS_Debug(DBG_RENDER, "\n\n");
-}
-
-//
-//
-//
-static void HWR_ClipSolidWallSegment(INT32 first, INT32 last)
-{
-	cliprange_t *next, *start;
-	float lowfrac, highfrac;
-	boolean poorhack = false;
-
-	// Find the first range that touches the range
-	//  (adjacent pixels are touching).
-	start = gl_solidsegs;
-	while (start->last < first-1)
-		start++;
-
-	if (first < start->first)
-	{
-		if (last < start->first-1)
-		{
-			// Post is entirely visible (above start),
-			//  so insert a new clippost.
-			HWR_StoreWallRange(first, last);
-
-			next = hw_newend;
-			hw_newend++;
-
-			while (next != start)
-			{
-				*next = *(next-1);
-				next--;
-			}
-
-			next->first = first;
-			next->last = last;
-			printsolidsegs();
-			return;
-		}
-
-		// There is a fragment above *start.
-		if (!cv_glclipwalls.value)
-		{
-			if (!poorhack) HWR_StoreWallRange(first, last);
-			poorhack = true;
-		}
-		else
-		{
-			highfrac = HWR_ClipViewSegment(start->first+1, (polyvertex_t *)gl_curline->pv1, (polyvertex_t *)gl_curline->pv2);
-			HWR_StoreWallRange(0, highfrac);
-		}
-		// Now adjust the clip size.
-		start->first = first;
-	}
-
-	// Bottom contained in start?
-	if (last <= start->last)
-	{
-		printsolidsegs();
-		return;
-	}
-	next = start;
-	while (last >= (next+1)->first-1)
-	{
-		// There is a fragment between two posts.
-		if (!cv_glclipwalls.value)
-		{
-			if (!poorhack) HWR_StoreWallRange(first,last);
-			poorhack = true;
-		}
-		else
-		{
-			lowfrac  = HWR_ClipViewSegment(next->last-1, (polyvertex_t *)gl_curline->pv1, (polyvertex_t *)gl_curline->pv2);
-			highfrac = HWR_ClipViewSegment((next+1)->first+1, (polyvertex_t *)gl_curline->pv1, (polyvertex_t *)gl_curline->pv2);
-			HWR_StoreWallRange(lowfrac, highfrac);
-		}
-		next++;
-
-		if (last <= next->last)
-		{
-			// Bottom is contained in next.
-			// Adjust the clip size.
-			start->last = next->last;
-			goto crunch;
-		}
-	}
-
-	if (first == next->first+1) // 1 line texture
-	{
-		if (!cv_glclipwalls.value)
-		{
-			if (!poorhack) HWR_StoreWallRange(first,last);
-			poorhack = true;
-		}
-		else
-			HWR_StoreWallRange(0, 1);
-	}
-	else
-	{
-	// There is a fragment after *next.
-		if (!cv_glclipwalls.value)
-		{
-			if (!poorhack) HWR_StoreWallRange(first,last);
-			poorhack = true;
-		}
-		else
-		{
-			lowfrac  = HWR_ClipViewSegment(next->last-1, (polyvertex_t *)gl_curline->pv1, (polyvertex_t *)gl_curline->pv2);
-			HWR_StoreWallRange(lowfrac, 1);
-		}
-	}
-
-	// Adjust the clip size.
-	start->last = last;
-
-	// Remove start+1 to next from the clip list,
-	// because start now covers their area.
-crunch:
-	if (next == start)
-	{
-		printsolidsegs();
-		// Post just extended past the bottom of one post.
-		return;
-	}
-
-
-	while (next++ != hw_newend)
-	{
-		// Remove a post.
-		*++start = *next;
-	}
-
-	hw_newend = start;
-	printsolidsegs();
-}
-
-//
-//  handle LineDefs with upper and lower texture (windows)
-//
-static void HWR_ClipPassWallSegment(INT32 first, INT32 last)
-{
-	cliprange_t *start;
-	float lowfrac, highfrac;
-	//to allow noclipwalls but still solidseg reject of non-visible walls
-	boolean poorhack = false;
-
-	// Find the first range that touches the range
-	//  (adjacent pixels are touching).
-	start = gl_solidsegs;
-	while (start->last < first - 1)
-		start++;
-
-	if (first < start->first)
-	{
-		if (last < start->first-1)
-		{
-			// Post is entirely visible (above start).
-			HWR_StoreWallRange(0, 1);
-			return;
-		}
-
-		// There is a fragment above *start.
-		if (!cv_glclipwalls.value)
-		{	//20/08/99: Changed by Hurdler (taken from faB's code)
-			if (!poorhack) HWR_StoreWallRange(0, 1);
-			poorhack = true;
-		}
-		else
-		{
-			highfrac = HWR_ClipViewSegment(min(start->first + 1,
-				start->last), (polyvertex_t *)gl_curline->pv1,
-				(polyvertex_t *)gl_curline->pv2);
-			HWR_StoreWallRange(0, highfrac);
-		}
-	}
-
-	// Bottom contained in start?
-	if (last <= start->last)
-		return;
-
-	while (last >= (start+1)->first-1)
-	{
-		// There is a fragment between two posts.
-		if (!cv_glclipwalls.value)
-		{
-			if (!poorhack) HWR_StoreWallRange(0, 1);
-			poorhack = true;
-		}
-		else
-		{
-			lowfrac  = HWR_ClipViewSegment(max(start->last-1,start->first), (polyvertex_t *)gl_curline->pv1, (polyvertex_t *)gl_curline->pv2);
-			highfrac = HWR_ClipViewSegment(min((start+1)->first+1,(start+1)->last), (polyvertex_t *)gl_curline->pv1, (polyvertex_t *)gl_curline->pv2);
-			HWR_StoreWallRange(lowfrac, highfrac);
-		}
-		start++;
-
-		if (last <= start->last)
-			return;
-	}
-
-	if (first == start->first+1) // 1 line texture
-	{
-		if (!cv_glclipwalls.value)
-		{
-			if (!poorhack) HWR_StoreWallRange(0, 1);
-			poorhack = true;
-		}
-		else
-			HWR_StoreWallRange(0, 1);
-	}
-	else
-	{
-		// There is a fragment after *next.
-		if (!cv_glclipwalls.value)
-		{
-			if (!poorhack) HWR_StoreWallRange(0,1);
-			poorhack = true;
-		}
-		else
-		{
-			lowfrac = HWR_ClipViewSegment(max(start->last - 1,
-				start->first), (polyvertex_t *)gl_curline->pv1,
-				(polyvertex_t *)gl_curline->pv2);
-			HWR_StoreWallRange(lowfrac, 1);
-		}
-	}
-}
-
-// --------------------------------------------------------------------------
-//  HWR_ClipToSolidSegs check if it is hide by wall (solidsegs)
-// --------------------------------------------------------------------------
-static boolean HWR_ClipToSolidSegs(INT32 first, INT32 last)
-{
-	cliprange_t * start;
-
-	// Find the first range that touches the range
-	//  (adjacent pixels are touching).
-	start = gl_solidsegs;
-	while (start->last < first-1)
-		start++;
-
-	if (first < start->first)
-		return true;
-
-	// Bottom contained in start?
-	if (last <= start->last)
-		return false;
-
-	return true;
-}
-
-//
-// HWR_ClearClipSegs
-//
-static void HWR_ClearClipSegs(void)
-{
-	gl_solidsegs[0].first = -0x7fffffff;
-	gl_solidsegs[0].last = -1;
-	gl_solidsegs[1].first = vid.width; //viewwidth;
-	gl_solidsegs[1].last = 0x7fffffff;
-	hw_newend = gl_solidsegs+2;
-}
-#endif // NEWCLIP
 
 // -----------------+
 // HWR_AddLine      : Clips the given segment and adds any visible pieces to the line list.
@@ -2227,11 +1887,6 @@ static void HWR_ClearClipSegs(void)
 static void HWR_AddLine(seg_t * line)
 {
 	angle_t angle1, angle2;
-#ifndef NEWCLIP
-	INT32 x1, x2;
-	angle_t span, tspan;
-	boolean bothceilingssky = false, bothfloorssky = false;
-#endif
 
 	// SoM: Backsector needs to be run through R_FakeFlat
 	static sector_t tempsec;
@@ -2251,7 +1906,6 @@ static void HWR_AddLine(seg_t * line)
 	angle1 = R_PointToAngle64(v1x, v1y);
 	angle2 = R_PointToAngle64(v2x, v2y);
 
-#ifdef NEWCLIP
 	 // PrBoom: Back side, i.e. backface culling - read: endAngle >= startAngle!
 	if (angle2 - angle1 < ANGLE_180)
 		return;
@@ -2264,90 +1918,9 @@ static void HWR_AddLine(seg_t * line)
     }
 
 	checkforemptylines = true;
-#else
-	// Clip to view edges.
-	span = angle1 - angle2;
-
-	// backface culling : span is < ANGLE_180 if ang1 > ang2 : the seg is facing
-	if (span >= ANGLE_180)
-		return;
-
-	// Global angle needed by segcalc.
-	//rw_angle1 = angle1;
-	angle1 -= dup_viewangle;
-	angle2 -= dup_viewangle;
-
-	tspan = angle1 + gl_clipangle;
-	if (tspan > 2*gl_clipangle)
-	{
-		tspan -= 2*gl_clipangle;
-
-		// Totally off the left edge?
-		if (tspan >= span)
-			return;
-
-		angle1 = gl_clipangle;
-	}
-	tspan = gl_clipangle - angle2;
-	if (tspan > 2*gl_clipangle)
-	{
-		tspan -= 2*gl_clipangle;
-
-		// Totally off the left edge?
-		if (tspan >= span)
-			return;
-
-		angle2 = (angle_t)-(signed)gl_clipangle;
-	}
-
-#if 0
-	{
-		float fx1,fx2,fy1,fy2;
-		//BP: test with a better projection than viewangletox[R_PointToAngle(angle)]
-		// do not enable this at release 4 mul and 2 div
-		fx1 = ((polyvertex_t *)(line->pv1))->x-gl_viewx;
-		fy1 = ((polyvertex_t *)(line->pv1))->y-gl_viewy;
-		fy2 = (fx1 * gl_viewcos + fy1 * gl_viewsin);
-		if (fy2 < 0)
-			// the point is back
-			fx1 = 0;
-		else
-			fx1 = gl_windowcenterx + (fx1 * gl_viewsin - fy1 * gl_viewcos) * gl_centerx / fy2;
-
-		fx2 = ((polyvertex_t *)(line->pv2))->x-gl_viewx;
-		fy2 = ((polyvertex_t *)(line->pv2))->y-gl_viewy;
-		fy1 = (fx2 * gl_viewcos + fy2 * gl_viewsin);
-		if (fy1 < 0)
-			// the point is back
-			fx2 = vid.width;
-		else
-			fx2 = gl_windowcenterx + (fx2 * gl_viewsin - fy2 * gl_viewcos) * gl_centerx / fy1;
-
-		x1 = fx1+0.5f;
-		x2 = fx2+0.5f;
-	}
-#else
-	// The seg is in the view range,
-	// but not necessarily visible.
-	angle1 = (angle1+ANGLE_90)>>ANGLETOFINESHIFT;
-	angle2 = (angle2+ANGLE_90)>>ANGLETOFINESHIFT;
-
-	x1 = gl_viewangletox[angle1];
-	x2 = gl_viewangletox[angle2];
-#endif
-	// Does not cross a pixel?
-//	if (x1 == x2)
-/*	{
-		// BP: HERE IS THE MAIN PROBLEM !
-		//CONS_Debug(DBG_RENDER, "tineline\n");
-		return;
-	}
-*/
-#endif
 
 	gl_backsector = line->backsector;
 
-#ifdef NEWCLIP
 	if (!line->backsector)
     {
 		gld_clipper_SafeAddClipRange(angle2, angle1);
@@ -2389,115 +1962,6 @@ static void HWR_AddLine(seg_t * line)
     }
 
 	HWR_ProcessSeg(); // Doesn't need arguments because they're defined globally :D
-	return;
-#else
-	// Single sided line?
-	if (!gl_backsector)
-		goto clipsolid;
-
-	gl_backsector = R_FakeFlat(gl_backsector, &tempsec, NULL, NULL, true);
-
-	if (gl_backsector->ceilingpic == skyflatnum && gl_frontsector->ceilingpic == skyflatnum)
-		bothceilingssky = true;
-	if (gl_backsector->floorpic == skyflatnum && gl_frontsector->floorpic == skyflatnum)
-		bothfloorssky = true;
-
-	if (bothceilingssky && bothfloorssky) // everything's sky? let's save us a bit of time then
-	{
-		if (!line->polyseg &&
-			!line->sidedef->midtexture
-			&& ((!gl_frontsector->ffloors && !gl_backsector->ffloors)
-				|| Tag_Compare(&gl_frontsector->tags, &gl_backsector->tags)))
-			return; // line is empty, don't even bother
-
-		goto clippass; // treat like wide open window instead
-	}
-
-	if (gl_frontsector->f_slope || gl_frontsector->c_slope || gl_backsector->f_slope || gl_backsector->c_slope)
-	{
-		fixed_t frontf1,frontf2, frontc1, frontc2; // front floor/ceiling ends
-		fixed_t backf1, backf2, backc1, backc2; // back floor ceiling ends
-
-#define SLOPEPARAMS(slope, end1, end2, normalheight) \
-		end1 = P_GetZAt(slope, v1x, v1y, normalheight); \
-		end2 = P_GetZAt(slope, v2x, v2y, normalheight);
-
-		SLOPEPARAMS(gl_frontsector->f_slope, frontf1, frontf2, gl_frontsector->  floorheight)
-		SLOPEPARAMS(gl_frontsector->c_slope, frontc1, frontc2, gl_frontsector->ceilingheight)
-		SLOPEPARAMS( gl_backsector->f_slope,  backf1,  backf2,  gl_backsector->  floorheight)
-		SLOPEPARAMS( gl_backsector->c_slope,  backc1,  backc2,  gl_backsector->ceilingheight)
-#undef SLOPEPARAMS
-		// if both ceilings are skies, consider it always "open"
-		// same for floors
-		if (!bothceilingssky && !bothfloorssky)
-		{
-			// Closed door.
-			if ((backc1 <= frontf1 && backc2 <= frontf2)
-				|| (backf1 >= frontc1 && backf2 >= frontc2))
-			{
-				goto clipsolid;
-			}
-
-			// Check for automap fix.
-			if (backc1 <= backf1 && backc2 <= backf2
-			&& ((backc1 >= frontc1 && backc2 >= frontc2) || gl_curline->sidedef->toptexture)
-			&& ((backf1 <= frontf1 && backf2 >= frontf2) || gl_curline->sidedef->bottomtexture))
-				goto clipsolid;
-		}
-
-		// Window.
-		if (!bothceilingssky) // ceilings are always the "same" when sky
-			if (backc1 != frontc1 || backc2 != frontc2)
-				goto clippass;
-		if (!bothfloorssky)	// floors are always the "same" when sky
-			if (backf1 != frontf1 || backf2 != frontf2)
-				goto clippass;
-	}
-	else
-	{
-		// if both ceilings are skies, consider it always "open"
-		// same for floors
-		if (!bothceilingssky && !bothfloorssky)
-		{
-			// Closed door.
-			if (gl_backsector->ceilingheight <= gl_frontsector->floorheight ||
-				gl_backsector->floorheight >= gl_frontsector->ceilingheight)
-				goto clipsolid;
-
-			// Check for automap fix.
-			if (gl_backsector->ceilingheight <= gl_backsector->floorheight
-			&& ((gl_backsector->ceilingheight >= gl_frontsector->ceilingheight) || gl_curline->sidedef->toptexture)
-			&& ((gl_backsector->floorheight <= gl_backsector->floorheight) || gl_curline->sidedef->bottomtexture))
-				goto clipsolid;
-		}
-
-		// Window.
-		if (!bothceilingssky) // ceilings are always the "same" when sky
-			if (gl_backsector->ceilingheight != gl_frontsector->ceilingheight)
-				goto clippass;
-		if (!bothfloorssky)	// floors are always the "same" when sky
-			if (gl_backsector->floorheight != gl_frontsector->floorheight)
-				goto clippass;
-	}
-
-	// Reject empty lines used for triggers and special events.
-	// Identical floor and ceiling on both sides,
-	//  identical light levels on both sides,
-	//  and no middle texture.
-	if (R_IsEmptyLine(gl_curline, gl_frontsector, gl_backsector))
-		return;
-
-clippass:
-	if (x1 == x2)
-		{  x2++;x1 -= 2; }
-	HWR_ClipPassWallSegment(x1, x2-1);
-	return;
-
-clipsolid:
-	if (x1 == x2)
-		goto clippass;
-	HWR_ClipSolidWallSegment(x1, x2-1);
-#endif
 }
 
 // HWR_CheckBBox
@@ -2512,10 +1976,6 @@ static boolean HWR_CheckBBox(fixed_t *bspcoord)
 	INT32 boxpos;
 	fixed_t px1, py1, px2, py2;
 	angle_t angle1, angle2;
-#ifndef NEWCLIP
-	INT32 sx1, sx2;
-	angle_t span, tspan;
-#endif
 
 	// Find the corners of the box
 	// that define the edges from current viewpoint.
@@ -2541,59 +2001,9 @@ static boolean HWR_CheckBBox(fixed_t *bspcoord)
 	px2 = bspcoord[checkcoord[boxpos][2]];
 	py2 = bspcoord[checkcoord[boxpos][3]];
 
-#ifdef NEWCLIP
 	angle1 = R_PointToAngle64(px1, py1);
 	angle2 = R_PointToAngle64(px2, py2);
 	return gld_clipper_SafeCheckRange(angle2, angle1);
-#else
-	// check clip list for an open space
-	angle1 = R_PointToAngle2(dup_viewx>>1, dup_viewy>>1, px1>>1, py1>>1) - dup_viewangle;
-	angle2 = R_PointToAngle2(dup_viewx>>1, dup_viewy>>1, px2>>1, py2>>1) - dup_viewangle;
-
-	span = angle1 - angle2;
-
-	// Sitting on a line?
-	if (span >= ANGLE_180)
-		return true;
-
-	tspan = angle1 + gl_clipangle;
-
-	if (tspan > 2*gl_clipangle)
-	{
-		tspan -= 2*gl_clipangle;
-
-		// Totally off the left edge?
-		if (tspan >= span)
-			return false;
-
-		angle1 = gl_clipangle;
-	}
-	tspan = gl_clipangle - angle2;
-	if (tspan > 2*gl_clipangle)
-	{
-		tspan -= 2*gl_clipangle;
-
-		// Totally off the left edge?
-		if (tspan >= span)
-			return false;
-
-		angle2 = (angle_t)-(signed)gl_clipangle;
-	}
-
-	// Find the first clippost
-	//  that touches the source post
-	//  (adjacent pixels are touching).
-	angle1 = (angle1+ANGLE_90)>>ANGLETOFINESHIFT;
-	angle2 = (angle2+ANGLE_90)>>ANGLETOFINESHIFT;
-	sx1 = gl_viewangletox[angle1];
-	sx2 = gl_viewangletox[angle2];
-
-	// Does not cross a pixel.
-	if (sx1 == sx2)
-		return false;
-
-	return HWR_ClipToSolidSegs(sx1, sx2 - 1);
-#endif
 }
 
 //
@@ -3317,100 +2727,6 @@ static void HWR_RenderBSPNode(INT32 bspnum)
 	}
 }
 
-/*
-//
-// Clear 'stack' of subsectors to draw
-//
-static void HWR_ClearDrawSubsectors(void)
-{
-	gl_drawsubsector_p = gl_drawsubsectors;
-}
-
-//
-// Draw subsectors pushed on the drawsubsectors 'stack', back to front
-//
-static void HWR_RenderSubsectors(void)
-{
-	while (gl_drawsubsector_p > gl_drawsubsectors)
-	{
-		HWR_RenderBSPNode(
-		lastsubsec->nextsubsec = bspnum & (~NF_SUBSECTOR);
-	}
-}
-*/
-
-// ==========================================================================
-//                                                              FROM R_MAIN.C
-// ==========================================================================
-
-//BP : exactely the same as R_InitTextureMapping
-void HWR_InitTextureMapping(void)
-{
-	angle_t i;
-	INT32 x;
-	INT32 t;
-	fixed_t focallength;
-	fixed_t grcenterx;
-	fixed_t grcenterxfrac;
-	INT32 grviewwidth;
-
-#define clipanglefov (FIELDOFVIEW>>ANGLETOFINESHIFT)
-
-	grviewwidth = vid.width;
-	grcenterx = grviewwidth/2;
-	grcenterxfrac = grcenterx<<FRACBITS;
-
-	// Use tangent table to generate viewangletox:
-	//  viewangletox will give the next greatest x
-	//  after the view angle.
-	//
-	// Calc focallength
-	//  so FIELDOFVIEW angles covers SCREENWIDTH.
-	focallength = FixedDiv(grcenterxfrac,
-		FINETANGENT(FINEANGLES/4+clipanglefov/2));
-
-	for (i = 0; i < FINEANGLES/2; i++)
-	{
-		if (FINETANGENT(i) > FRACUNIT*2)
-			t = -1;
-		else if (FINETANGENT(i) < -FRACUNIT*2)
-			t = grviewwidth+1;
-		else
-		{
-			t = FixedMul(FINETANGENT(i), focallength);
-			t = (grcenterxfrac - t+FRACUNIT-1)>>FRACBITS;
-
-			if (t < -1)
-				t = -1;
-			else if (t > grviewwidth+1)
-				t = grviewwidth+1;
-		}
-		gl_viewangletox[i] = t;
-	}
-
-	// Scan viewangletox[] to generate xtoviewangle[]:
-	//  xtoviewangle will give the smallest view angle
-	//  that maps to x.
-	for (x = 0; x <= grviewwidth; x++)
-	{
-		i = 0;
-		while (gl_viewangletox[i]>x)
-			i++;
-		gl_xtoviewangle[x] = (i<<ANGLETOFINESHIFT) - ANGLE_90;
-	}
-
-	// Take out the fencepost cases from viewangletox.
-	for (i = 0; i < FINEANGLES/2; i++)
-	{
-		if (gl_viewangletox[i] == -1)
-			gl_viewangletox[i] = 0;
-		else if (gl_viewangletox[i] == grviewwidth+1)
-			gl_viewangletox[i]  = grviewwidth;
-	}
-
-	gl_clipangle = gl_xtoviewangle[0];
-}
-
 // ==========================================================================
 // gl_things.c
 // ==========================================================================
@@ -5967,7 +5283,7 @@ static void HWR_DrawSkyBackground(player_t *player)
 		// software doesn't draw any further than 1024 for skies anyway, but this doesn't overlap properly
 		// The only time this will probably be an issue is when a sky wider than 1024 is used as a sky AND a regular wall texture
 
-		angle = (dup_viewangle + gl_xtoviewangle[0]);
+		angle = (dup_viewangle + xtoviewangle[0]);
 
 		dimensionmultiply = ((float)textures[texturetranslation[skytexture]]->width/256.0f);
 
@@ -6217,18 +5533,11 @@ void HWR_RenderSkyboxView(INT32 viewnumber, player_t *player)
 
 	drawcount = 0;
 
-#ifdef NEWCLIP
-	if (rendermode == render_opengl)
-	{
-		angle_t a1 = gld_FrustumAngle(gl_aimingangle);
-		gld_clipper_Clear();
-		gld_clipper_SafeAddClipRange(viewangle + a1, viewangle - a1);
+	angle_t a1 = gld_FrustumAngle(gl_aimingangle);
+	gld_clipper_Clear();
+	gld_clipper_SafeAddClipRange(viewangle + a1, viewangle - a1);
 #ifdef HAVE_SPHEREFRUSTRUM
-		gld_FrustrumSetup();
-#endif
-	}
-#else
-	HWR_ClearClipSegs();
+	gld_FrustrumSetup();
 #endif
 
 	//04/01/2000: Hurdler: added for T&L
@@ -6245,35 +5554,6 @@ void HWR_RenderSkyboxView(INT32 viewnumber, player_t *player)
 
 	HWR_RenderBSPNode((INT32)numnodes-1);
 
-#ifndef NEWCLIP
-	// Make a viewangle int so we can render things based on mouselook
-	if (player == &players[consoleplayer])
-		viewangle = localaiming;
-	else if (splitscreen && player == &players[secondarydisplayplayer])
-		viewangle = localaiming2;
-
-	// Handle stuff when you are looking farther up or down.
-	if ((gl_aimingangle || cv_fov.value+player->fovadd > 90*FRACUNIT))
-	{
-		dup_viewangle += ANGLE_90;
-		HWR_ClearClipSegs();
-		HWR_RenderBSPNode((INT32)numnodes-1); //left
-
-		dup_viewangle += ANGLE_90;
-		if (((INT32)gl_aimingangle > ANGLE_45 || (INT32)gl_aimingangle<-ANGLE_45))
-		{
-			HWR_ClearClipSegs();
-			HWR_RenderBSPNode((INT32)numnodes-1); //back
-		}
-
-		dup_viewangle += ANGLE_90;
-		HWR_ClearClipSegs();
-		HWR_RenderBSPNode((INT32)numnodes-1); //right
-
-		dup_viewangle += ANGLE_90;
-	}
-#endif
-
 	if (cv_glbatching.value)
 		HWR_RenderBatches();
 
@@ -6433,18 +5713,11 @@ void HWR_RenderPlayerView(INT32 viewnumber, player_t *player)
 
 	drawcount = 0;
 
-#ifdef NEWCLIP
-	if (rendermode == render_opengl)
-	{
-		angle_t a1 = gld_FrustumAngle(gl_aimingangle);
-		gld_clipper_Clear();
-		gld_clipper_SafeAddClipRange(viewangle + a1, viewangle - a1);
+	angle_t a1 = gld_FrustumAngle(gl_aimingangle);
+	gld_clipper_Clear();
+	gld_clipper_SafeAddClipRange(viewangle + a1, viewangle - a1);
 #ifdef HAVE_SPHEREFRUSTRUM
-		gld_FrustrumSetup();
-#endif
-	}
-#else
-	HWR_ClearClipSegs();
+	gld_FrustrumSetup();
 #endif
 
 	//04/01/2000: Hurdler: added for T&L
@@ -6465,35 +5738,6 @@ void HWR_RenderPlayerView(INT32 viewnumber, player_t *player)
 
 	HWR_RenderBSPNode((INT32)numnodes-1);
 
-#ifndef NEWCLIP
-	// Make a viewangle int so we can render things based on mouselook
-	if (player == &players[consoleplayer])
-		viewangle = localaiming;
-	else if (splitscreen && player == &players[secondarydisplayplayer])
-		viewangle = localaiming2;
-
-	// Handle stuff when you are looking farther up or down.
-	if ((gl_aimingangle || cv_fov.value+player->fovadd > 90*FRACUNIT))
-	{
-		dup_viewangle += ANGLE_90;
-		HWR_ClearClipSegs();
-		HWR_RenderBSPNode((INT32)numnodes-1); //left
-
-		dup_viewangle += ANGLE_90;
-		if (((INT32)gl_aimingangle > ANGLE_45 || (INT32)gl_aimingangle<-ANGLE_45))
-		{
-			HWR_ClearClipSegs();
-			HWR_RenderBSPNode((INT32)numnodes-1); //back
-		}
-
-		dup_viewangle += ANGLE_90;
-		HWR_ClearClipSegs();
-		HWR_RenderBSPNode((INT32)numnodes-1); //right
-
-		dup_viewangle += ANGLE_90;
-	}
-#endif
-
 	PS_STOP_TIMING(ps_bsptime);
 
 	if (cv_glbatching.value)
@@ -6646,10 +5890,6 @@ void HWR_AddCommands(void)
 	CV_RegisterVar(&cv_glsolvetjoin);
 
 	CV_RegisterVar(&cv_glbatching);
-
-#ifndef NEWCLIP
-	CV_RegisterVar(&cv_glclipwalls);
-#endif
 }
 
 void HWR_AddSessionCommands(void)
diff --git a/src/hardware/hw_main.h b/src/hardware/hw_main.h
index 9450ca2c56..fbc365c113 100644
--- a/src/hardware/hw_main.h
+++ b/src/hardware/hw_main.h
@@ -37,7 +37,6 @@ void HWR_ClearSkyDome(void);
 void HWR_BuildSkyDome(void);
 void HWR_DrawViewBorder(INT32 clearlines);
 void HWR_DrawFlatFill(INT32 x, INT32 y, INT32 w, INT32 h, lumpnum_t flatlumpnum);
-void HWR_InitTextureMapping(void);
 void HWR_SetViewSize(void);
 void HWR_DrawPatch(patch_t *gpatch, INT32 x, INT32 y, INT32 option);
 void HWR_DrawStretchyFixedPatch(patch_t *gpatch, fixed_t x, fixed_t y, fixed_t pscale, fixed_t vscale, INT32 option, const UINT8 *colormap);
diff --git a/src/r_defs.h b/src/r_defs.h
index a9b9a4a083..bef0d9ba2a 100644
--- a/src/r_defs.h
+++ b/src/r_defs.h
@@ -764,11 +764,11 @@ typedef struct drawseg_s
 	struct ffloor_s *thicksides[MAXFFLOORS];
 	INT16 *thicksidecol;
 	INT32 numthicksides;
-	fixed_t frontscale[MAXVIDWIDTH];
+	fixed_t *frontscale;
 
 	UINT8 portalpass; // if > 0 and <= portalrender, do not affect sprite clipping
 
-	fixed_t maskedtextureheight[MAXVIDWIDTH]; // For handling sloped midtextures
+	fixed_t *maskedtextureheight; // For handling sloped midtextures
 
 	vertex_t leftpos, rightpos; // Used for rendering FOF walls with slopes
 } drawseg_t;
diff --git a/src/r_draw.c b/src/r_draw.c
index 79ad9adde9..4dd2046067 100644
--- a/src/r_draw.c
+++ b/src/r_draw.c
@@ -18,6 +18,7 @@
 #include "doomdef.h"
 #include "doomstat.h"
 #include "r_local.h"
+#include "r_splats.h"
 #include "st_stuff.h" // need ST_HEIGHT
 #include "i_video.h"
 #include "v_video.h"
@@ -37,24 +38,24 @@
 
 /**	\brief view info
 */
-INT32 viewwidth, scaledviewwidth, viewheight, viewwindowx, viewwindowy;
+INT32 viewwidth, viewheight, viewwindowx, viewwindowy;
 
 /**	\brief pointer to the start of each line of the screen,
 */
-UINT8 *ylookup[MAXVIDHEIGHT*4];
+UINT8 **ylookup;
 
 /**	\brief pointer to the start of each line of the screen, for view1 (splitscreen)
 */
-UINT8 *ylookup1[MAXVIDHEIGHT*4];
+UINT8 **ylookup1;
 
 /**	\brief pointer to the start of each line of the screen, for view2 (splitscreen)
 */
-UINT8 *ylookup2[MAXVIDHEIGHT*4];
+UINT8 **ylookup2;
 
 /**	\brief  x byte offset for columns inside the viewwindow,
 	so the first column starts at (SCRWIDTH - VIEWWIDTH)/2
 */
-INT32 columnofs[MAXVIDWIDTH*4];
+INT32 *columnofs;
 
 UINT8 *topleft;
 
@@ -121,6 +122,9 @@ float focallengthf, zeroheight;
 
 UINT32 nflatxshift, nflatyshift, nflatshiftup, nflatmask;
 
+// For, uh, tilted lighting, duh.
+static INT32 *tiltlighting;
+
 // =========================================================================
 //                   TRANSLATION COLORMAP CODE
 // =========================================================================
@@ -701,6 +705,29 @@ void R_InitViewBuffer(INT32 width, INT32 height)
 	if (bytesperpixel < 1 || bytesperpixel > 4)
 		I_Error("R_InitViewBuffer: wrong bytesperpixel value %d\n", bytesperpixel);
 
+	negonearray = Z_Realloc(negonearray, sizeof(*negonearray) * viewwidth, PU_STATIC, NULL);
+	screenheightarray = Z_Realloc(screenheightarray, sizeof(*screenheightarray) * viewwidth, PU_STATIC, NULL);
+
+	floorclip = Z_Realloc(floorclip, sizeof(*floorclip) * viewwidth, PU_STATIC, NULL);
+	ceilingclip = Z_Realloc(ceilingclip, sizeof(*ceilingclip) * viewwidth, PU_STATIC, NULL);
+
+	frontscale = Z_Realloc(frontscale, sizeof(*frontscale) * viewwidth, PU_STATIC, NULL);
+
+	ylookup1 = Z_Realloc(ylookup1, sizeof(*ylookup1) * (viewheight * 4), PU_STATIC, NULL);
+	ylookup2 = Z_Realloc(ylookup2, sizeof(*ylookup2) * (viewheight * 4), PU_STATIC, NULL);
+	ylookup = ylookup1;
+
+	columnofs = Z_Realloc(columnofs, sizeof(*columnofs) * (viewwidth * 4), PU_STATIC, NULL);
+
+	xtoviewangle = Z_Realloc(xtoviewangle, sizeof(*xtoviewangle) * (viewwidth + 1), PU_STATIC, NULL);
+
+	tiltlighting = Z_Realloc(tiltlighting, sizeof(*tiltlighting) * viewwidth, PU_STATIC, NULL);
+
+	R_AllocSegMemory();
+	R_AllocPlaneMemory();
+	R_AllocFloorSpriteTables();
+	R_AllocVisSpriteMemory();
+
 	// Handle resize, e.g. smaller view windows with border and/or status bar.
 	viewwindowx = (vid.width - width) >> 1;
 
@@ -717,7 +744,7 @@ void R_InitViewBuffer(INT32 width, INT32 height)
 	// Precalculate all row offsets.
 	for (i = 0; i < height; i++)
 	{
-		ylookup[i] = ylookup1[i] = screens[0] + (i+viewwindowy)*vid.width*bytesperpixel;
+		ylookup1[i] = screens[0] + (i+viewwindowy)*vid.width*bytesperpixel;
 		ylookup2[i] = screens[0] + (i+(vid.height>>1))*vid.width*bytesperpixel; // for splitscreen
 	}
 }
@@ -745,8 +772,6 @@ void R_VideoErase(size_t ofs, INT32 count)
 
 // R_CalcTiltedLighting
 // Exactly what it says on the tin. I wish I wasn't too lazy to explain things properly.
-static INT32 tiltlighting[MAXVIDWIDTH];
-
 static void R_CalcTiltedLighting(fixed_t start, fixed_t end)
 {
 	// ZDoom uses a different lighting setup to us, and I couldn't figure out how to adapt their version
diff --git a/src/r_draw.h b/src/r_draw.h
index 09fd2fff2e..a58a8a6580 100644
--- a/src/r_draw.h
+++ b/src/r_draw.h
@@ -19,10 +19,10 @@
 // -------------------------------
 // COMMON STUFF FOR 8bpp AND 16bpp
 // -------------------------------
-extern UINT8 *ylookup[MAXVIDHEIGHT*4];
-extern UINT8 *ylookup1[MAXVIDHEIGHT*4];
-extern UINT8 *ylookup2[MAXVIDHEIGHT*4];
-extern INT32 columnofs[MAXVIDWIDTH*4];
+extern UINT8 **ylookup;
+extern UINT8 **ylookup1;
+extern UINT8 **ylookup2;
+extern INT32 *columnofs;
 extern UINT8 *topleft;
 
 // -------------------------
diff --git a/src/r_fps.c b/src/r_fps.c
index c6eb594821..7aec22d262 100644
--- a/src/r_fps.c
+++ b/src/r_fps.c
@@ -122,7 +122,7 @@ static vector3_t *R_LerpVector3(const vector3_t *from, const vector3_t *to, fixe
 
 // recalc necessary stuff for mouseaiming
 // slopes are already calculated for the full possible view (which is 4*viewheight).
-// 18/08/18: (No it's actually 16*viewheight, thanks Jimita for finding this out)
+// 18/08/18: (No it's actually 16*viewheight, thanks Lactozilla for finding this out)
 static void R_SetupFreelook(player_t *player, boolean skybox)
 {
 #ifndef HWRENDER
diff --git a/src/r_main.c b/src/r_main.c
index dea402eec8..df4f676d57 100644
--- a/src/r_main.c
+++ b/src/r_main.c
@@ -95,7 +95,7 @@ INT32 viewangletox[FINEANGLES/2];
 // The xtoviewangleangle[] table maps a screen pixel
 // to the lowest viewangle that maps back to x ranges
 // from clipangle to -clipangle.
-angle_t xtoviewangle[MAXVIDWIDTH+1];
+angle_t *xtoviewangle;
 
 lighttable_t *scalelight[LIGHTLEVELS][MAXLIGHTSCALE];
 lighttable_t *scalelightfixed[MAXLIGHTSCALE];
@@ -606,7 +606,10 @@ static struct {
 	INT32 scrmapsize;
 
 	INT32 x1; // clip rendering horizontally for efficiency
-	INT16 ceilingclip[MAXVIDWIDTH], floorclip[MAXVIDWIDTH];
+	INT16 *ceilingclip, *floorclip;
+#ifdef WOUGHMP_WOUGHMP
+	float *fisheyemap;
+#endif
 
 	boolean use;
 } viewmorph = {
@@ -620,7 +623,10 @@ static struct {
 	0,
 
 	0,
-	{0}, {0},
+	NULL, NULL,
+#ifdef WOUGHMP_WOUGHMP
+	NULL,
+#endif
 
 	false
 };
@@ -632,9 +638,6 @@ void R_CheckViewMorph(void)
 	fixed_t temp;
 	INT32 end, vx, vy, pos, usedpos;
 	INT32 usedx, usedy, halfwidth = vid.width/2, halfheight = vid.height/2;
-#ifdef WOUGHMP_WOUGHMP
-	float fisheyemap[MAXVIDWIDTH/2 + 1];
-#endif
 
 	angle_t rollangle = players[displayplayer].viewrollangle;
 #ifdef WOUGHMP_WOUGHMP
@@ -677,10 +680,13 @@ void R_CheckViewMorph(void)
 
 	if (viewmorph.scrmapsize != vid.width*vid.height)
 	{
-		if (viewmorph.scrmap)
-			free(viewmorph.scrmap);
-		viewmorph.scrmap = malloc(vid.width*vid.height * sizeof(INT32));
 		viewmorph.scrmapsize = vid.width*vid.height;
+		viewmorph.scrmap = realloc(viewmorph.scrmap, vid.width*vid.height * sizeof(INT32));
+		viewmorph.ceilingclip = realloc(viewmorph.ceilingclip, vid.width * sizeof(INT16));
+		viewmorph.floorclip = realloc(viewmorph.floorclip, vid.width * sizeof(INT16));
+#ifdef WOUGHMP_WOUGHMP
+		viewmorph.fisheyemap = realloc(viewmorph.fisheyemap, (vid.width/2 + 1) * sizeof(float));
+#endif
 	}
 
 	temp = FINECOSINE(rollangle);
@@ -923,14 +929,12 @@ void R_ExecuteSetViewSize(void)
 	// status bar overlay
 	st_overlay = cv_showhud.value;
 
-	scaledviewwidth = vid.width;
+	viewwidth = vid.width;
 	viewheight = vid.height;
 
 	if (splitscreen)
 		viewheight >>= 1;
 
-	viewwidth = scaledviewwidth;
-
 	centerx = viewwidth/2;
 	centery = viewheight/2;
 	centerxfrac = centerx<<FRACBITS;
@@ -948,13 +952,16 @@ void R_ExecuteSetViewSize(void)
 
 	projection = projectiony = FixedDiv(centerxfrac, fovtan);
 
-	R_InitViewBuffer(scaledviewwidth, viewheight);
+	R_InitViewBuffer(viewwidth, viewheight);
 
 	R_InitTextureMapping();
 
 	// thing clipping
 	for (i = 0; i < viewwidth; i++)
+	{
+		negonearray[i] = -1;
 		screenheightarray[i] = (INT16)viewheight;
+	}
 
 	// setup sky scaling
 	R_SetSkyScale();
@@ -1023,9 +1030,6 @@ void R_Init(void)
 
 	R_SetViewSize(); // setsizeneeded is set true
 
-	//I_OutputMsg("\nR_InitPlanes");
-	R_InitPlanes();
-
 	// this is now done by SCR_Recalc() at the first mode set
 	//I_OutputMsg("\nR_InitLightTables");
 	R_InitLightTables();
diff --git a/src/r_plane.c b/src/r_plane.c
index c568484b6e..5a9218f69d 100644
--- a/src/r_plane.c
+++ b/src/r_plane.c
@@ -39,6 +39,7 @@
 //SoM: 3/23/2000: Use Boom visplane hashing.
 
 visplane_t *visplanes[MAXVISPLANES];
+static UINT16 numvisplanes;
 static visplane_t *freetail;
 static visplane_t **freehead = &freetail;
 
@@ -62,14 +63,14 @@ INT16 *openings, *lastopening; /// \todo free leak
 //  floorclip starts out SCREENHEIGHT
 //  ceilingclip starts out -1
 //
-INT16 floorclip[MAXVIDWIDTH], ceilingclip[MAXVIDWIDTH];
-fixed_t frontscale[MAXVIDWIDTH];
+INT16 *floorclip, *ceilingclip;
+fixed_t *frontscale;
 
 //
 // spanstart holds the start of a plane span
 // initialized to 0 at start
 //
-static INT32 spanstart[MAXVIDHEIGHT];
+static INT32 *spanstart;
 
 //
 // texture mapping
@@ -84,24 +85,75 @@ static fixed_t planeheight;
 //                (this is to calculate yslopes only when really needed)
 //                (when mouselookin', yslope is moving into yslopetab)
 //                Check R_SetupFrame, R_SetViewSize for more...
-fixed_t yslopetab[MAXVIDHEIGHT*16];
+fixed_t *yslopetab;
 fixed_t *yslope;
 
-fixed_t cachedheight[MAXVIDHEIGHT];
-fixed_t cacheddistance[MAXVIDHEIGHT];
-fixed_t cachedxstep[MAXVIDHEIGHT];
-fixed_t cachedystep[MAXVIDHEIGHT];
+fixed_t *cachedheight;
+fixed_t *cacheddistance;
+fixed_t *cachedxstep;
+fixed_t *cachedystep;
 
 static fixed_t xoffs, yoffs;
 static floatv3_t ds_slope_origin, ds_slope_u, ds_slope_v;
 
-//
-// R_InitPlanes
-// Only at game startup.
-//
-void R_InitPlanes(void)
+static INT16 *ffloor_f_clip;
+static INT16 *ffloor_c_clip;
+
+UINT16 *visplanes_top[MAXVISPLANES];
+UINT16 *visplanes_bottom[MAXVISPLANES];
+
+static void R_AllocVisplaneTables(unsigned i)
+{
+	// leave pads for [minx-1]/[maxx+1]
+	visplanes_top[i] = Z_Realloc(visplanes_top[i], sizeof(UINT16) * (viewwidth + 2), PU_STATIC, NULL);
+	visplanes_bottom[i] = Z_Realloc(visplanes_bottom[i], sizeof(UINT16) * (viewwidth + 2), PU_STATIC, NULL);
+}
+
+void R_AllocPlaneMemory(void)
 {
-	// FIXME: unused
+	// Alloc visplane top/bottom bounds
+	visplane_t *check;
+
+	for (unsigned i = 0; i < MAXVISPLANES; i++)
+	{
+		if (visplanes_top[i] || visplanes_bottom[i])
+			R_AllocVisplaneTables(i);
+
+		if ((check = visplanes[i]))
+		{
+			check->top = visplanes_top[check->id] + 1;
+			check->bottom = visplanes_bottom[check->id] + 1;
+		}
+	}
+
+	// Need to do it for "freed" visplanes too
+	check = freetail;
+
+	while (check)
+	{
+		check->top = visplanes_top[check->id] + 1;
+		check->bottom = visplanes_bottom[check->id] + 1;
+		check = check->next;
+	}
+
+	// Alloc ffloor clip tables
+	ffloor_f_clip = Z_Realloc(ffloor_f_clip, sizeof(*ffloor_f_clip) * (viewwidth * MAXFFLOORS), PU_STATIC, NULL);
+	ffloor_c_clip = Z_Realloc(ffloor_c_clip, sizeof(*ffloor_c_clip) * (viewwidth * MAXFFLOORS), PU_STATIC, NULL);
+
+	for (unsigned i = 0; i < MAXFFLOORS; i++)
+	{
+		ffloor[i].f_clip = ffloor_f_clip + (i * viewwidth);
+		ffloor[i].c_clip = ffloor_c_clip + (i * viewwidth);
+	}
+
+	yslopetab = Z_Realloc(yslopetab, sizeof(*yslopetab) * (viewheight * 16), PU_STATIC, NULL);
+
+	cachedheight = Z_Realloc(cachedheight, sizeof(*cachedheight) * viewheight, PU_STATIC, NULL);
+	cacheddistance = Z_Realloc(cacheddistance, sizeof(*cacheddistance) * viewheight, PU_STATIC, NULL);
+	cachedxstep = Z_Realloc(cachedxstep, sizeof(*cachedxstep) * viewheight, PU_STATIC, NULL);
+	cachedystep = Z_Realloc(cachedystep, sizeof(*cachedystep) * viewheight, PU_STATIC, NULL);
+
+	spanstart = Z_Realloc(spanstart, sizeof(*spanstart) * viewheight, PU_STATIC, NULL);
 }
 
 //
@@ -369,7 +421,7 @@ void R_ClearPlanes(void)
 	lastopening = openings;
 
 	// texture calculation
-	memset(cachedheight, 0, sizeof (cachedheight));
+	memset(cachedheight, 0, sizeof(*cachedheight) * viewheight);
 }
 
 static visplane_t *new_visplane(unsigned hash)
@@ -377,8 +429,10 @@ static visplane_t *new_visplane(unsigned hash)
 	visplane_t *check = freetail;
 	if (!check)
 	{
-		check = malloc(sizeof (*check));
+		check = calloc(1, sizeof (*check));
 		if (check == NULL) I_Error("%s: Out of memory", "new_visplane"); // FIXME: ugly
+		check->id = numvisplanes++;
+		R_AllocVisplaneTables(check->id);
 	}
 	else
 	{
@@ -486,8 +540,11 @@ visplane_t *R_FindPlane(fixed_t height, INT32 picnum, INT32 lightlevel,
 	check->polyobj = polyobj;
 	check->slope = slope;
 
-	memset(check->top, 0xff, sizeof (check->top));
-	memset(check->bottom, 0x00, sizeof (check->bottom));
+	check->top = visplanes_top[check->id] + 1;
+	check->bottom = visplanes_bottom[check->id] + 1;
+
+	memset(check->top, 0xff, sizeof(*check->top) * viewwidth);
+	memset(check->bottom, 0x00, sizeof(*check->bottom) * viewwidth);
 
 	return check;
 }
@@ -542,8 +599,7 @@ visplane_t *R_CheckPlane(visplane_t *pl, INT32 start, INT32 stop)
 		}
 		else
 		{
-			unsigned hash =
-				visplane_hash(pl->picnum, pl->lightlevel, pl->height);
+			unsigned hash = visplane_hash(pl->picnum, pl->lightlevel, pl->height);
 			new_pl = new_visplane(hash);
 		}
 
@@ -564,8 +620,10 @@ visplane_t *R_CheckPlane(visplane_t *pl, INT32 start, INT32 stop)
 		pl = new_pl;
 		pl->minx = start;
 		pl->maxx = stop;
-		memset(pl->top, 0xff, sizeof pl->top);
-		memset(pl->bottom, 0x00, sizeof pl->bottom);
+		pl->top = visplanes_top[pl->id] + 1;
+		pl->bottom = visplanes_bottom[pl->id] + 1;
+		memset(pl->top, 0xff, sizeof(*pl->top) * viewwidth);
+		memset(pl->bottom, 0x00, sizeof(*pl->bottom) * viewwidth);
 	}
 	return pl;
 }
@@ -1009,7 +1067,7 @@ void R_DrawSinglePlane(visplane_t *pl)
 		// Don't mess with angle on slopes! We'll handle this ourselves later
 		if (!pl->slope && viewangle != pl->viewangle+pl->plangle)
 		{
-			memset(cachedheight, 0, sizeof (cachedheight));
+			memset(cachedheight, 0, sizeof(*cachedheight) * viewheight);
 			viewangle = pl->viewangle+pl->plangle;
 		}
 
diff --git a/src/r_plane.h b/src/r_plane.h
index 9870a43e26..0d441b3ab3 100644
--- a/src/r_plane.h
+++ b/src/r_plane.h
@@ -31,6 +31,7 @@
 typedef struct visplane_s
 {
 	struct visplane_s *next;
+	UINT16 id;
 
 	fixed_t height;
 	fixed_t viewx, viewy, viewz;
@@ -43,9 +44,8 @@ typedef struct visplane_s
 	// colormaps per sector
 	extracolormap_t *extra_colormap;
 
-	// leave pads for [minx-1]/[maxx+1]
-	UINT16 padtopstart, top[MAXVIDWIDTH], padtopend;
-	UINT16 padbottomstart, bottom[MAXVIDWIDTH], padbottomend;
+	UINT16 *top;
+	UINT16 *bottom;
 	INT32 high, low; // R_PlaneBounds should set these.
 
 	fixed_t xoffs, yoffs; // Scrolling flats.
@@ -63,17 +63,17 @@ extern visplane_t *ceilingplane;
 extern INT16 *lastopening, *openings;
 extern size_t maxopenings;
 
-extern INT16 floorclip[MAXVIDWIDTH], ceilingclip[MAXVIDWIDTH];
-extern fixed_t frontscale[MAXVIDWIDTH], yslopetab[MAXVIDHEIGHT*16];
-extern fixed_t cachedheight[MAXVIDHEIGHT];
-extern fixed_t cacheddistance[MAXVIDHEIGHT];
-extern fixed_t cachedxstep[MAXVIDHEIGHT];
-extern fixed_t cachedystep[MAXVIDHEIGHT];
+extern INT16 *floorclip, *ceilingclip;
+extern fixed_t *frontscale, *yslopetab;
+extern fixed_t *cachedheight;
+extern fixed_t *cacheddistance;
+extern fixed_t *cachedxstep;
+extern fixed_t *cachedystep;
 
 extern fixed_t *yslope;
 extern lighttable_t **planezlight;
 
-void R_InitPlanes(void);
+void R_AllocPlaneMemory(void);
 void R_ClearPlanes(void);
 void R_ClearFFloorClips (void);
 
@@ -103,8 +103,8 @@ typedef struct planemgr_s
 	fixed_t b_pos; // B for Back sector
 	fixed_t f_frac, f_step;
 	fixed_t b_frac, b_step;
-	INT16 f_clip[MAXVIDWIDTH];
-	INT16 c_clip[MAXVIDWIDTH];
+	INT16 *f_clip;
+	INT16 *c_clip;
 
 	// For slope rendering; the height at the other end
 	fixed_t f_pos_slope;
diff --git a/src/r_segs.c b/src/r_segs.c
index facab62ab7..a11ee83e35 100644
--- a/src/r_segs.c
+++ b/src/r_segs.c
@@ -1512,6 +1512,33 @@ static INT64 R_CalcSegDist(seg_t* seg, INT64 x2, INT64 y2)
 	}
 }
 
+static size_t maxdrawsegs = 0;
+
+static fixed_t *frontscaletable = NULL;
+static fixed_t *maskedheighttable = NULL;
+
+void R_AllocSegMemory(void)
+{
+	if (!maxdrawsegs)
+		return;
+
+	frontscaletable = Z_Realloc(frontscaletable, sizeof(*frontscaletable) * (maxdrawsegs * viewwidth), PU_STATIC, NULL);
+	maskedheighttable = Z_Realloc(maskedheighttable, sizeof(*maskedheighttable) * (maxdrawsegs * viewwidth), PU_STATIC, NULL);
+
+	drawseg_t *lastseg = drawsegs + maxdrawsegs;
+
+	fixed_t *frontscale_p = frontscaletable;
+	fixed_t *maskedheight_p = maskedheighttable;
+
+	for (drawseg_t *ds = drawsegs; ds < lastseg; ds++)
+	{
+		ds->frontscale = frontscale_p;
+		ds->maskedtextureheight = maskedheight_p;
+		frontscale_p += viewwidth;
+		maskedheight_p += viewwidth;
+	}
+}
+
 //
 // R_StoreWallRange
 // A wall segment will be drawn
@@ -1530,7 +1557,6 @@ void R_StoreWallRange(INT32 start, INT32 stop)
 	INT32 range;
 	vertex_t segleft, segright;
 	fixed_t ceilingfrontslide, floorfrontslide, ceilingbackslide, floorbackslide;
-	static size_t maxdrawsegs = 0;
 
 	maskedtextureheight = NULL;
 	//initialize segleft and segright
@@ -1552,6 +1578,7 @@ void R_StoreWallRange(INT32 start, INT32 stop)
 		curdrawsegs = drawsegs + curpos;
 		if (firstseg)
 			firstseg = drawsegs + (size_t)firstseg;
+		R_AllocSegMemory();
 	}
 
 	sidedef = curline->sidedef;
diff --git a/src/r_segs.h b/src/r_segs.h
index 09c68b27e9..5c1fbed8b0 100644
--- a/src/r_segs.h
+++ b/src/r_segs.h
@@ -18,9 +18,12 @@
 #pragma interface
 #endif
 
-transnum_t R_GetLinedefTransTable(fixed_t alpha);
 void R_RenderMaskedSegRange(drawseg_t *ds, INT32 x1, INT32 x2);
 void R_RenderThickSideRange(drawseg_t *ds, INT32 x1, INT32 x2, ffloor_t *pffloor);
 void R_StoreWallRange(INT32 start, INT32 stop);
 
+void R_AllocSegMemory(void);
+
+transnum_t R_GetLinedefTransTable(fixed_t alpha);
+
 #endif
diff --git a/src/r_splats.c b/src/r_splats.c
index d182d628ba..aa5917e0f0 100644
--- a/src/r_splats.c
+++ b/src/r_splats.c
@@ -22,9 +22,17 @@
 
 struct rastery_s *prastertab; // for ASM code
 
-static struct rastery_s rastertab[MAXVIDHEIGHT];
+static struct rastery_s *rastertab;
 static void prepare_rastertab(void);
 
+static boolean *cliptable;
+
+void R_AllocFloorSpriteTables(void)
+{
+	cliptable = Z_Realloc(cliptable, sizeof(*cliptable) * (viewwidth + 1), PU_STATIC, NULL);
+	rastertab = Z_Realloc(rastertab, sizeof(*rastertab) * viewheight, PU_STATIC, NULL);
+}
+
 // ==========================================================================
 //                                                               FLOOR SPLATS
 // ==========================================================================
@@ -412,7 +420,7 @@ static void R_RasterizeFloorSplat(floorsplat_t *pSplat, vector2_t *verts, visspr
 
 		if (pSplat->angle)
 		{
-			memset(cachedheight, 0, sizeof(cachedheight));
+			memset(cachedheight, 0, sizeof(*cachedheight) * viewheight);
 
 			// Add the view offset, rotated by the plane angle.
 			fixed_t a = -pSplat->verts[0].x + vis->viewpoint.x;
@@ -463,8 +471,6 @@ static void R_RasterizeFloorSplat(floorsplat_t *pSplat, vector2_t *verts, visspr
 
 	for (y = miny; y <= maxy; y++)
 	{
-		boolean cliptab[MAXVIDWIDTH+1];
-
 		x1 = rastertab[y].minx>>FRACBITS;
 		x2 = rastertab[y].maxx>>FRACBITS;
 
@@ -487,10 +493,10 @@ static void R_RasterizeFloorSplat(floorsplat_t *pSplat, vector2_t *verts, visspr
 			continue;
 
 		for (i = x1; i <= x2; i++)
-			cliptab[i] = (y >= mfloorclip[i] || y <= mceilingclip[i]);
+			cliptable[i] = (y >= mfloorclip[i] || y <= mceilingclip[i]);
 
 		// clip left
-		while (cliptab[x1])
+		while (cliptable[x1])
 		{
 			x1++;
 			if (x1 >= viewwidth)
@@ -502,7 +508,7 @@ static void R_RasterizeFloorSplat(floorsplat_t *pSplat, vector2_t *verts, visspr
 
 		while (i > x1)
 		{
-			if (cliptab[i])
+			if (cliptable[i])
 				x2 = i-1;
 			i--;
 			if (i < 0)
@@ -562,7 +568,7 @@ static void R_RasterizeFloorSplat(floorsplat_t *pSplat, vector2_t *verts, visspr
 	}
 
 	if (pSplat->angle && !pSplat->slope)
-		memset(cachedheight, 0, sizeof(cachedheight));
+		memset(cachedheight, 0, sizeof(*cachedheight) * viewheight);
 }
 
 static void prepare_rastertab(void)
diff --git a/src/r_splats.h b/src/r_splats.h
index dcae2789c9..344380cd43 100644
--- a/src/r_splats.h
+++ b/src/r_splats.h
@@ -43,4 +43,6 @@ typedef struct floorsplat_s
 
 void R_DrawFloorSplat(vissprite_t *spr);
 
+void R_AllocFloorSpriteTables(void);
+
 #endif /*__R_SPLATS_H__*/
diff --git a/src/r_state.h b/src/r_state.h
index b36697f73c..1868fde792 100644
--- a/src/r_state.h
+++ b/src/r_state.h
@@ -97,7 +97,7 @@ extern angle_t clipangle;
 extern angle_t doubleclipangle;
 
 extern INT32 viewangletox[FINEANGLES/2];
-extern angle_t xtoviewangle[MAXVIDWIDTH+1];
+extern angle_t *xtoviewangle;
 
 extern fixed_t rw_distance;
 extern angle_t rw_normalangle;
diff --git a/src/r_things.c b/src/r_things.c
index 248357e11f..3423396c37 100644
--- a/src/r_things.c
+++ b/src/r_things.c
@@ -63,8 +63,8 @@ typedef struct
 static lighttable_t **spritelights;
 
 // constant arrays used for psprite clipping and initializing clipping
-INT16 negonearray[MAXVIDWIDTH];
-INT16 screenheightarray[MAXVIDWIDTH];
+INT16 *negonearray;
+INT16 *screenheightarray;
 
 spriteinfo_t spriteinfo[NUMSPRITES];
 
@@ -513,9 +513,6 @@ void R_InitSprites(void)
 	float fa;
 #endif
 
-	for (i = 0; i < MAXVIDWIDTH; i++)
-		negonearray[i] = -1;
-
 #ifdef ROTSPRITE
 	for (angle = 1; angle < ROTANGLES; angle++)
 	{
@@ -574,6 +571,34 @@ void R_ClearSprites(void)
 	visspritecount = clippedvissprites = 0;
 }
 
+static INT16 *vissprite_clipbot[MAXVISSPRITES >> VISSPRITECHUNKBITS];
+static INT16 *vissprite_cliptop[MAXVISSPRITES >> VISSPRITECHUNKBITS];
+
+static void R_AllocVisSpriteChunkMemory(UINT32 chunk)
+{
+	vissprite_clipbot[chunk] = Z_Realloc(vissprite_clipbot[chunk], sizeof(INT16) * (VISSPRITESPERCHUNK * viewwidth), PU_STATIC, NULL);
+	vissprite_cliptop[chunk] = Z_Realloc(vissprite_cliptop[chunk], sizeof(INT16) * (VISSPRITESPERCHUNK * viewwidth), PU_STATIC, NULL);
+
+	for (unsigned i = 0; i < VISSPRITESPERCHUNK; i++)
+	{
+		vissprite_t *sprite = visspritechunks[chunk] + i;
+
+		sprite->clipbot = vissprite_clipbot[chunk] + (viewwidth * i);
+		sprite->cliptop = vissprite_cliptop[chunk] + (viewwidth * i);
+	}
+}
+
+void R_AllocVisSpriteMemory(void)
+{
+	unsigned numchunks = MAXVISSPRITES >> VISSPRITECHUNKBITS;
+
+	for (unsigned i = 0; i < numchunks; i++)
+	{
+		if (visspritechunks[i])
+			R_AllocVisSpriteChunkMemory(i);
+	}
+}
+
 //
 // R_NewVisSprite
 //
@@ -581,13 +606,16 @@ static vissprite_t overflowsprite;
 
 static vissprite_t *R_GetVisSprite(UINT32 num)
 {
-		UINT32 chunk = num >> VISSPRITECHUNKBITS;
+	UINT32 chunk = num >> VISSPRITECHUNKBITS;
 
-		// Allocate chunk if necessary
-		if (!visspritechunks[chunk])
-			Z_Malloc(sizeof(vissprite_t) * VISSPRITESPERCHUNK, PU_LEVEL, &visspritechunks[chunk]);
+	// Allocate chunk if necessary
+	if (!visspritechunks[chunk])
+	{
+		Z_Malloc(sizeof(vissprite_t) * VISSPRITESPERCHUNK, PU_LEVEL, &visspritechunks[chunk]);
+		R_AllocVisSpriteChunkMemory(chunk);
+	}
 
-		return visspritechunks[chunk] + (num & VISSPRITEINDEXMASK);
+	return visspritechunks[chunk] + (num & VISSPRITEINDEXMASK);
 }
 
 static vissprite_t *R_NewVisSprite(void)
diff --git a/src/r_things.h b/src/r_things.h
index bb8a1e97b0..18e0113ef4 100644
--- a/src/r_things.h
+++ b/src/r_things.h
@@ -56,8 +56,8 @@ void R_DrawFlippedMaskedColumn(column_t *column);
 
 // Constant arrays used for psprite clipping
 //  and initializing clipping.
-extern INT16 negonearray[MAXVIDWIDTH];
-extern INT16 screenheightarray[MAXVIDWIDTH];
+extern INT16 *negonearray;
+extern INT16 *screenheightarray;
 
 fixed_t R_GetShadowZ(mobj_t *thing, pslope_t **shadowslope);
 
@@ -214,7 +214,7 @@ typedef struct vissprite_s
 
 	skincolornum_t color;
 
-	INT16 clipbot[MAXVIDWIDTH], cliptop[MAXVIDWIDTH];
+	INT16 *clipbot, *cliptop;
 
 	INT32 dispoffset; // copy of mobj->dispoffset, affects ordering but not drawing
 } vissprite_t;
@@ -224,6 +224,8 @@ extern UINT32 visspritecount;
 void R_ClipSprites(drawseg_t* dsstart, portal_t* portal);
 void R_ClipVisSprite(vissprite_t *spr, INT32 x1, INT32 x2, drawseg_t* dsstart, portal_t* portal);
 
+void R_AllocVisSpriteMemory(void);
+
 boolean R_SpriteIsFlashing(vissprite_t *vis);
 
 void R_DrawThingBoundingBox(vissprite_t *spr);
-- 
GitLab


From 14f2ca95a9e2b27f5cab1bc523dd75fd668638fb Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 01:14:27 -0300
Subject: [PATCH 06/27] Adjust field of view to the aspect ratio (for OpenGL)

---
 src/hardware/hw_clip.c |  8 ++------
 src/hardware/hw_clip.h |  2 +-
 src/hardware/hw_main.c | 28 +++++++++++++++++++++++-----
 3 files changed, 26 insertions(+), 12 deletions(-)

diff --git a/src/hardware/hw_clip.c b/src/hardware/hw_clip.c
index 86e0c58d25..e3f30edb61 100644
--- a/src/hardware/hw_clip.c
+++ b/src/hardware/hw_clip.c
@@ -320,18 +320,14 @@ void gld_clipper_Clear(void)
 
 #define RMUL (1.6f/1.333333f)
 
-angle_t gld_FrustumAngle(angle_t tiltangle)
+angle_t gld_FrustumAngle(float render_fov, angle_t tiltangle)
 {
 	double floatangle;
 	angle_t a1;
 
 	float tilt = (float)fabs(((double)(int)tiltangle) / ANG1);
 
-	// NEWCLIP TODO: SRB2CBTODO: make a global render_fov for this function
-
-	float render_fov = FIXED_TO_FLOAT(cv_fov.value);
-	float render_fovratio = (float)BASEVIDWIDTH / (float)BASEVIDHEIGHT; // SRB2CBTODO: NEWCLIPTODO: Is this right?
-	float render_multiplier = 64.0f / render_fovratio / RMUL;
+	float render_multiplier = 48.0f / RMUL;
 
 	if (tilt > 90.0f)
 	{
diff --git a/src/hardware/hw_clip.h b/src/hardware/hw_clip.h
index 27a2ed1efa..e3bb4c3193 100644
--- a/src/hardware/hw_clip.h
+++ b/src/hardware/hw_clip.h
@@ -17,7 +17,7 @@
 boolean gld_clipper_SafeCheckRange(angle_t startAngle, angle_t endAngle);
 void gld_clipper_SafeAddClipRange(angle_t startangle, angle_t endangle);
 void gld_clipper_Clear(void);
-angle_t gld_FrustumAngle(angle_t tiltangle);
+angle_t gld_FrustumAngle(float render_fov, angle_t tiltangle);
 #ifdef HAVE_SPHEREFRUSTRUM
 void gld_FrustrumSetup(void);
 boolean gld_SphereInFrustum(float x, float y, float z, float radius);
diff --git a/src/hardware/hw_main.c b/src/hardware/hw_main.c
index a118784fea..21e8c0c106 100644
--- a/src/hardware/hw_main.c
+++ b/src/hardware/hw_main.c
@@ -132,6 +132,7 @@ static float gl_viewludsin, gl_viewludcos; // look up down kik test
 static float gl_fovlud;
 
 static angle_t gl_aimingangle;
+static float HWR_GetFOV(player_t *player);
 static void HWR_SetTransformAiming(FTransform *trans, player_t *player, boolean skybox);
 
 // Render stats
@@ -5203,7 +5204,7 @@ static void HWR_DrawSkyBackground(player_t *player)
 	if (cv_glskydome.value)
 	{
 		FTransform dometransform;
-		const float fpov = FIXED_TO_FLOAT(cv_fov.value+player->fovadd);
+		const float fpov = HWR_GetFOV(player);
 		postimg_t *type;
 
 		if (splitscreen && player == &players[secondarydisplayplayer])
@@ -5396,6 +5397,23 @@ void HWR_SetViewSize(void)
 	HWD.pfnFlushScreenTextures();
 }
 
+float HWR_GetFOV(player_t *player)
+{
+	fixed_t pfov = cv_fov.value;
+	float fov;
+
+	if (player)
+		pfov += player->fovadd;
+
+	fov = FixedToFloat(pfov);
+
+	float resmul = (float)vid.width / (float)vid.height;
+	if (resmul > 1.0)
+		fov = atan(tan(fov * M_PI / 360) * resmul) * 360 / M_PI;
+
+	return fov;
+}
+
 // Set view aiming, for the sky dome, the skybox,
 // and the normal view, all with a single function.
 static void HWR_SetTransformAiming(FTransform *trans, player_t *player, boolean skybox)
@@ -5437,7 +5455,7 @@ static void HWR_SetShaderState(void)
 // ==========================================================================
 void HWR_RenderSkyboxView(INT32 viewnumber, player_t *player)
 {
-	const float fpov = FIXED_TO_FLOAT(cv_fov.value+player->fovadd);
+	const float fpov = HWR_GetFOV(player);
 	postimg_t *type;
 
 	if (splitscreen && player == &players[secondarydisplayplayer])
@@ -5533,7 +5551,7 @@ void HWR_RenderSkyboxView(INT32 viewnumber, player_t *player)
 
 	drawcount = 0;
 
-	angle_t a1 = gld_FrustumAngle(gl_aimingangle);
+	angle_t a1 = gld_FrustumAngle(fpov, gl_aimingangle);
 	gld_clipper_Clear();
 	gld_clipper_SafeAddClipRange(viewangle + a1, viewangle - a1);
 #ifdef HAVE_SPHEREFRUSTRUM
@@ -5596,7 +5614,7 @@ void HWR_RenderSkyboxView(INT32 viewnumber, player_t *player)
 // ==========================================================================
 void HWR_RenderPlayerView(INT32 viewnumber, player_t *player)
 {
-	const float fpov = FIXED_TO_FLOAT(cv_fov.value+player->fovadd);
+	const float fpov = HWR_GetFOV(player);
 	postimg_t *type;
 
 	const boolean skybox = (skyboxmo[0] && cv_skybox.value); // True if there's a skybox object and skyboxes are on
@@ -5713,7 +5731,7 @@ void HWR_RenderPlayerView(INT32 viewnumber, player_t *player)
 
 	drawcount = 0;
 
-	angle_t a1 = gld_FrustumAngle(gl_aimingangle);
+	angle_t a1 = gld_FrustumAngle(fpov, gl_aimingangle);
 	gld_clipper_Clear();
 	gld_clipper_SafeAddClipRange(viewangle + a1, viewangle - a1);
 #ifdef HAVE_SPHEREFRUSTRUM
-- 
GitLab


From 874dc9dd0d242059b3c81f4d97d0e6bac6b7e2e9 Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 01:17:45 -0300
Subject: [PATCH 07/27] Don't reposition the window when changing renderers

---
 src/screen.c | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/src/screen.c b/src/screen.c
index 1017706eb3..89e03e03dc 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -516,13 +516,17 @@ void SCR_ChangeRenderer(void)
 		return;
 	}
 
-	if (rendermode == render_opengl && (vid.glstate == VID_GL_LIBRARY_LOADED)) // Clear these out before switching to software
+	// Clear these out before switching to software
+	if (rendermode == render_opengl && vid.glstate == VID_GL_LIBRARY_LOADED)
 		HWR_ClearAllTextures();
 #endif
 
 	// Set the new render mode
 	vid.change.renderer = cv_renderer.value;
-	vid.change.set = VID_RESOLUTION_CHANGED;
+
+	// Don't reposition the window
+	if (vid.change.set == VID_RESOLUTION_UNCHANGED)
+		vid.change.set = VID_RESOLUTION_RESIZED_WINDOW;
 }
 
 boolean SCR_IsAspectCorrect(INT32 width, INT32 height)
-- 
GitLab


From 436b096f010bdfeefa22976917d43a2171062875 Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 01:29:16 -0300
Subject: [PATCH 08/27] Remove MAXSEGS limit

---
 src/r_bsp.c  | 19 +++++++++++++++----
 src/r_bsp.h  |  1 +
 src/r_draw.c |  1 +
 3 files changed, 17 insertions(+), 4 deletions(-)

diff --git a/src/r_bsp.c b/src/r_bsp.c
index 42e050adf8..6f5f3a3f4a 100644
--- a/src/r_bsp.c
+++ b/src/r_bsp.c
@@ -48,11 +48,22 @@ void R_ClearDrawSegs(void)
 }
 
 // Fix from boom.
-#define MAXSEGS (MAXVIDWIDTH/2+1)
+static UINT32 maxsegs;
 
 // newend is one past the last valid seg
 static cliprange_t *newend;
-static cliprange_t solidsegs[MAXSEGS];
+static cliprange_t *solidsegs;
+
+void R_AllocClipSegMemory(void)
+{
+	UINT32 newendpos = newend - solidsegs;
+
+	maxsegs = max(BASEVIDWIDTH/2+1, viewwidth/2+1);
+
+	solidsegs = Z_Realloc(solidsegs, sizeof(*solidsegs) * maxsegs, PU_STATIC, NULL);
+
+	newend = solidsegs + newendpos;
+}
 
 //
 // R_ClipSolidWallSegment
@@ -79,7 +90,7 @@ static void R_ClipSolidWallSegment(INT32 first, INT32 last)
 			next = newend;
 			newend++;
 			// NO MORE CRASHING!
-			if (newend - solidsegs > MAXSEGS)
+			if (newend - solidsegs > maxsegs)
 				I_Error("R_ClipSolidWallSegment: Solid Segs overflow!\n");
 
 			while (next != start)
@@ -134,7 +145,7 @@ crunch:
 	newend = start + 1;
 
 	// NO MORE CRASHING!
-	if (newend - solidsegs > MAXSEGS)
+	if (newend - solidsegs > maxsegs)
 		I_Error("R_ClipSolidWallSegment: Solid Segs overflow!\n");
 }
 
diff --git a/src/r_bsp.h b/src/r_bsp.h
index 55199405ae..81ca55a5de 100644
--- a/src/r_bsp.h
+++ b/src/r_bsp.h
@@ -37,6 +37,7 @@ extern INT32 doorclosed;
 // BSP?
 void R_ClearClipSegs(void);
 void R_PortalClearClipSegs(INT32 start, INT32 end);
+void R_AllocClipSegMemory(void);
 void R_ClearDrawSegs(void);
 void R_RenderBSPNode(INT32 bspnum);
 
diff --git a/src/r_draw.c b/src/r_draw.c
index 4dd2046067..84226f3bdc 100644
--- a/src/r_draw.c
+++ b/src/r_draw.c
@@ -724,6 +724,7 @@ void R_InitViewBuffer(INT32 width, INT32 height)
 	tiltlighting = Z_Realloc(tiltlighting, sizeof(*tiltlighting) * viewwidth, PU_STATIC, NULL);
 
 	R_AllocSegMemory();
+	R_AllocClipSegMemory();
 	R_AllocPlaneMemory();
 	R_AllocFloorSpriteTables();
 	R_AllocVisSpriteMemory();
-- 
GitLab


From 33b8211f2ea6a417e9b14a22407394af88a9a36f Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 01:30:35 -0300
Subject: [PATCH 09/27] Always center the window in the video mode menu

---
 src/m_menu.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/m_menu.c b/src/m_menu.c
index 6c75936d0c..6963d45ea6 100644
--- a/src/m_menu.c
+++ b/src/m_menu.c
@@ -13655,7 +13655,7 @@ static void M_HandleVideoMode(INT32 ch)
 				vidm_previousheight = vid.height;
 
 				if (!vid.change.set) // in case the previous setmode was not finished
-					SCR_SetWindowSize(modedescs[vidm_selected].width, modedescs[vidm_selected].height);
+					SCR_ChangeResolution(modedescs[vidm_selected].width, modedescs[vidm_selected].height);
 			}
 			break;
 
@@ -13673,9 +13673,9 @@ static void M_HandleVideoMode(INT32 ch)
 			CV_Set(&cv_scr_width_w, cv_scr_width_w.defaultvalue);
 			CV_Set(&cv_scr_height_w, cv_scr_height_w.defaultvalue);
 			if (cv_fullscreen.value)
-				SCR_SetWindowSize(cv_scr_width.value, cv_scr_height.value);
+				SCR_ChangeResolution(cv_scr_width.value, cv_scr_height.value);
 			else
-				SCR_SetWindowSize(cv_scr_width_w.value, cv_scr_height_w.value);
+				SCR_ChangeResolution(cv_scr_width_w.value, cv_scr_height_w.value);
 			break;
 
 		case KEY_F10: // Renderer toggle, also processed inside menus
-- 
GitLab


From dfaf27e9c9dba520d02fe399114c170f4000b832 Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 01:32:01 -0300
Subject: [PATCH 10/27] Change max screen size

---
 src/screen.h | 16 +++++++---------
 1 file changed, 7 insertions(+), 9 deletions(-)

diff --git a/src/screen.h b/src/screen.h
index 6205356857..edcfaadee2 100644
--- a/src/screen.h
+++ b/src/screen.h
@@ -34,15 +34,13 @@
 #define ST_HEIGHT 32
 #define ST_WIDTH 320
 
-// used now as a maximum video mode size for extra vesa modes.
-
-// we try to re-allocate a minimum of buffers for stability of the memory,
-// so all the small-enough tables based on screen size, are allocated once
-// and for all at the maximum size.
-#define MAXVIDWIDTH 1920 // don't set this too high because actually
-#define MAXVIDHEIGHT 1200 // lots of tables are allocated with the MAX size.
-#define BASEVIDWIDTH 320 // NEVER CHANGE THIS! This is the original
-#define BASEVIDHEIGHT 200 // resolution of the graphics.
+// NEVER CHANGE THIS! This is the original resolution of the graphics.
+#define BASEVIDWIDTH 320
+#define BASEVIDHEIGHT 200
+
+// Max screen size
+#define MAXVIDWIDTH 8192
+#define MAXVIDHEIGHT 4608
 
 // global video state
 typedef struct viddef_s
-- 
GitLab


From d7cbf12dfd173e978199fc3b2440711419a5b76e Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 01:37:09 -0300
Subject: [PATCH 11/27] Display resolutions as red on video mode menu if
 they're invalid

---
 src/m_menu.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/src/m_menu.c b/src/m_menu.c
index 6963d45ea6..592bb55de4 100644
--- a/src/m_menu.c
+++ b/src/m_menu.c
@@ -13442,11 +13442,11 @@ static void M_DrawVideoMode(void)
 				vid.width, vid.height));
 		V_DrawCenteredString(BASEVIDWIDTH/2, OP_VideoModeDef.y + 116, (cv_fullscreen.value ? 0 : V_TRANSLUCENT),
 			va("Default mode is %c%dx%d",
-				(SCR_IsAspectCorrect(cv_scr_width.value, cv_scr_height.value)) ? 0x83 : 0x80,
+				(SCR_IsAspectCorrect(cv_scr_width.value, cv_scr_height.value)) ? 0x83 : (!SCR_IsValidResolution(cv_scr_width.value, cv_scr_height.value) ? 0x85 : 0x80),
 				cv_scr_width.value, cv_scr_height.value));
 		V_DrawCenteredString(BASEVIDWIDTH/2, OP_VideoModeDef.y + 124, (cv_fullscreen.value ? V_TRANSLUCENT : 0),
 			va("Windowed mode is %c%dx%d",
-				(SCR_IsAspectCorrect(cv_scr_width_w.value, cv_scr_height_w.value)) ? 0x83 : 0x80,
+				(SCR_IsAspectCorrect(cv_scr_width_w.value, cv_scr_height_w.value)) ? 0x83 : (!SCR_IsValidResolution(cv_scr_width_w.value, cv_scr_height_w.value) ? 0x85 : 0x80),
 				cv_scr_width_w.value, cv_scr_height_w.value));
 
 		V_DrawCenteredString(BASEVIDWIDTH/2, OP_VideoModeDef.y + 138,
-- 
GitLab


From 9f76d50f19a151b6b5adb98646ea9b8f1941e755 Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 01:45:34 -0300
Subject: [PATCH 12/27] Save window size if it's resized

---
 src/m_menu.c      | 2 +-
 src/screen.c      | 6 +++---
 src/screen.h      | 4 ++--
 src/sdl/i_video.c | 6 +++++-
 4 files changed, 11 insertions(+), 7 deletions(-)

diff --git a/src/m_menu.c b/src/m_menu.c
index 592bb55de4..9e571eb6f5 100644
--- a/src/m_menu.c
+++ b/src/m_menu.c
@@ -13645,7 +13645,7 @@ static void M_HandleVideoMode(INT32 ch)
 			if (vid.width == modedescs[vidm_selected].width && vid.height == modedescs[vidm_selected].height)
 			{
 				S_StartSound(NULL, sfx_strpst);
-				SCR_SetDefaultMode();
+				SCR_SetDefaultMode(vid.width, vid.height);
 			}
 			else
 			{
diff --git a/src/screen.c b/src/screen.c
index 89e03e03dc..59d94e0faa 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -456,10 +456,10 @@ void SCR_CheckDefaultMode(void)
 }
 
 // sets the modenum as the new default video mode to be saved in the config file
-void SCR_SetDefaultMode(void)
+void SCR_SetDefaultMode(INT32 width, INT32 height)
 {
-	CV_SetValue(cv_fullscreen.value ? &cv_scr_width : &cv_scr_width_w, vid.width);
-	CV_SetValue(cv_fullscreen.value ? &cv_scr_height : &cv_scr_height_w, vid.height);
+	CV_SetValue(cv_fullscreen.value ? &cv_scr_width : &cv_scr_width_w, width);
+	CV_SetValue(cv_fullscreen.value ? &cv_scr_height : &cv_scr_height_w, height);
 }
 
 // Change fullscreen on/off according to cv_fullscreen
diff --git a/src/screen.h b/src/screen.h
index edcfaadee2..42d62aa990 100644
--- a/src/screen.h
+++ b/src/screen.h
@@ -202,8 +202,8 @@ void SCR_Recalc(void);
 // Check parms once at startup
 void SCR_CheckDefaultMode(void);
 
-// Set the mode number which is saved in the config
-void SCR_SetDefaultMode(void);
+// Set the resolution which is saved in the config
+void SCR_SetDefaultMode(INT32 width, INT32 height);
 
 void SCR_CalculateFPS(void);
 
diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index 846b4c742d..c29bafa7c1 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -671,7 +671,11 @@ static void Impl_HandleWindowEvent(SDL_WindowEvent evt)
 		case SDL_WINDOWEVENT_MAXIMIZED:
 			break;
 		case SDL_WINDOWEVENT_SIZE_CHANGED:
-			SCR_SetWindowSize(evt.data1, evt.data2);
+			if ((SDL_GetWindowFlags(window) & SDL_WINDOW_FULLSCREEN_DESKTOP) == 0)
+			{
+				SCR_SetWindowSize(evt.data1, evt.data2);
+				SCR_SetDefaultMode(evt.data1, evt.data2);
+			}
 			break;
 	}
 
-- 
GitLab


From 67954c7b602d1265cb2008705f64995d0f41dbe0 Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 01:52:11 -0300
Subject: [PATCH 13/27] Add vid_width and vid_height commands

---
 src/sdl/i_video.c | 53 +++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 44 insertions(+), 9 deletions(-)

diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index c29bafa7c1..053033f4db 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -604,24 +604,19 @@ static void VID_Command_ModeList_f(void)
 
 static void VID_Command_Mode_f (void)
 {
-	INT32 modenum;
-
-	if (COM_Argc()!= 2)
+	if (COM_Argc() != 2)
 	{
-		CONS_Printf(M_GetText("vid_mode <modenum> : set video mode, current video mode %i\n"), vid.modenum);
+		CONS_Printf(M_GetText("vid_mode <modenum>: set video mode\n"));
 		return;
 	}
 
-	modenum = atoi(COM_Argv(1));
-
-	if (modenum >= VID_NumModes())
+	INT32 modenum = atoi(COM_Argv(1));
+	if (modenum >= MAXWINMODES)
 		CONS_Printf(M_GetText("Video mode not present\n"));
 	else
 	{
 		if (modenum < 0)
 			modenum = 0;
-		if (modenum >= MAXWINMODES)
-			modenum = MAXWINMODES-1;
 
 		vid.change.width = windowedModes[modenum][0];
 		vid.change.height = windowedModes[modenum][1];
@@ -629,6 +624,44 @@ static void VID_Command_Mode_f (void)
 	}
 }
 
+static void VID_Command_Width_f (void)
+{
+	if (COM_Argc() != 2)
+	{
+		CONS_Printf(M_GetText("vid_width <width>: set window width\n"));
+		return;
+	}
+
+	INT32 width = atoi(COM_Argv(1));
+
+	if (!SCR_IsValidResolution(width, vid.height))
+	{
+		CONS_Alert(CONS_WARNING, "Invalid width given\n");
+		return;
+	}
+
+	SCR_SetWindowSize(width, vid.height);
+}
+
+static void VID_Command_Height_f (void)
+{
+	if (COM_Argc() != 2)
+	{
+		CONS_Printf(M_GetText("vid_height <height>: set window height\n"));
+		return;
+	}
+
+	INT32 height = atoi(COM_Argv(1));
+
+	if (!SCR_IsValidResolution(vid.width, height))
+	{
+		CONS_Alert(CONS_WARNING, "Invalid height given\n");
+		return;
+	}
+
+	SCR_SetWindowSize(vid.width, height);
+}
+
 static void Impl_SetFocused(boolean focused)
 {
 	window_notinfocus = !focused;
@@ -1644,6 +1677,8 @@ void I_StartupGraphics(void)
 	COM_AddCommand ("vid_info", VID_Command_Info_f, COM_LUA);
 	COM_AddCommand ("vid_modelist", VID_Command_ModeList_f, COM_LUA);
 	COM_AddCommand ("vid_mode", VID_Command_Mode_f, 0);
+	COM_AddCommand ("vid_width", VID_Command_Width_f, 0);
+	COM_AddCommand ("vid_height", VID_Command_Height_f, 0);
 	CV_RegisterVar (&cv_vidwait);
 	CV_RegisterVar (&cv_stretch);
 	CV_RegisterVar (&cv_alwaysgrabmouse);
-- 
GitLab


From f4f351f93295e4714451cd950504048ed0120d18 Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 02:17:46 -0300
Subject: [PATCH 14/27] Restore window on size changes

---
 src/i_video.h     |  4 ++++
 src/screen.c      | 26 +++++++++++++++++++++-----
 src/screen.h      |  1 +
 src/sdl/i_video.c | 20 ++++++++++++++------
 4 files changed, 40 insertions(+), 11 deletions(-)

diff --git a/src/i_video.h b/src/i_video.h
index 117961e1d4..213d362a47 100644
--- a/src/i_video.h
+++ b/src/i_video.h
@@ -97,8 +97,12 @@ void VID_CheckGLLoaded(rendermode_t oldrender);
 	\return	name of video mode
 */
 const char *VID_GetModeName(INT32 modenum);
+
 void VID_PrepareModeList(void); /// note hack for SDL
 
+boolean VID_IsMaximized(void);
+
+void VID_RestoreWindow(void);
 
 /**	\brief can video system do fullscreen
 */
diff --git a/src/screen.c b/src/screen.c
index 59d94e0faa..6e4a068b34 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -367,28 +367,44 @@ boolean SCR_IsValidResolution(INT32 width, INT32 height)
 	return true;
 }
 
-void SCR_ChangeResolution(INT32 width, INT32 height)
+static boolean SCR_SetSize(INT32 width, INT32 height)
 {
 	if (SCR_IsValidResolution(width, height))
 	{
 		vid.change.width = width;
 		vid.change.height = height;
 		vid.change.renderer = -1;
+	}
+}
+
+void SCR_ChangeResolution(INT32 width, INT32 height)
+{
+	if (SCR_SetSize(width, height))
+	{
+		if (VID_IsMaximized())
+			VID_RestoreWindow();
+
 		vid.change.set = VID_RESOLUTION_CHANGED;
 	}
 }
 
 void SCR_SetWindowSize(INT32 width, INT32 height)
 {
-	if (SCR_IsValidResolution(width, height))
+	if (SCR_SetSize(width, height))
 	{
-		vid.change.width = width;
-		vid.change.height = height;
-		vid.change.renderer = -1;
+		if (VID_IsMaximized())
+			VID_RestoreWindow();
+
 		vid.change.set = VID_RESOLUTION_RESIZED_WINDOW;
 	}
 }
 
+void SCR_SetSizeNoRestore(INT32 width, INT32 height)
+{
+	if (SCR_SetSize(width, height))
+		vid.change.set = VID_RESOLUTION_RESIZED_WINDOW;
+}
+
 // Check for screen cmd-line parms: to force a resolution.
 //
 // Set the video mode to set at the 1st display loop
diff --git a/src/screen.h b/src/screen.h
index 42d62aa990..43c01cf310 100644
--- a/src/screen.h
+++ b/src/screen.h
@@ -172,6 +172,7 @@ extern double averageFPS;
 
 void SCR_ChangeResolution(INT32 width, INT32 height);
 void SCR_SetWindowSize(INT32 width, INT32 height);
+void SCR_SetSizeNoRestore(INT32 width, INT32 height);
 void SCR_ChangeRenderer(void);
 
 boolean SCR_IsValidResolution(INT32 width, INT32 height);
diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index 053033f4db..14a9e13b75 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -701,14 +701,9 @@ static void Impl_HandleWindowEvent(SDL_WindowEvent evt)
 			kbfocus = SDL_FALSE;
 			mousefocus = SDL_FALSE;
 			break;
-		case SDL_WINDOWEVENT_MAXIMIZED:
-			break;
 		case SDL_WINDOWEVENT_SIZE_CHANGED:
 			if ((SDL_GetWindowFlags(window) & SDL_WINDOW_FULLSCREEN_DESKTOP) == 0)
-			{
-				SCR_SetWindowSize(evt.data1, evt.data2);
-				SCR_SetDefaultMode(evt.data1, evt.data2);
-			}
+				SCR_SetSizeNoRestore(evt.data1, evt.data2);
 			break;
 	}
 
@@ -1529,6 +1524,19 @@ void VID_SetSize(INT32 width, INT32 height)
 	VID_CheckRenderer();
 }
 
+boolean VID_IsMaximized(void)
+{
+	if (window)
+		return SDL_GetWindowFlags(window) & SDL_WINDOW_MAXIMIZED;
+	return false;
+}
+
+void VID_RestoreWindow(void)
+{
+	if (window)
+		SDL_RestoreWindow(window);
+}
+
 static SDL_bool Impl_CreateWindow(SDL_bool fullscreen)
 {
 	int flags = SDL_WINDOW_RESIZABLE;
-- 
GitLab


From 88bed12af6067d85e98fbab2b095bb963fb9326c Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 02:22:49 -0300
Subject: [PATCH 15/27] Clean up

---
 src/sdl/i_video.c | 57 +----------------------------------------------
 1 file changed, 1 insertion(+), 56 deletions(-)

diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index 14a9e13b75..a0a6b7bc38 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -99,10 +99,6 @@ consvar_t cv_vidwait = CVAR_INIT ("vid_wait", "On", CV_SAVE | CV_CALL, CV_OnOff,
 static consvar_t cv_stretch = CVAR_INIT ("stretch", "Off", CV_SAVE|CV_NOSHOWHELP, CV_OnOff, NULL);
 static consvar_t cv_alwaysgrabmouse = CVAR_INIT ("alwaysgrabmouse", "Off", CV_SAVE, CV_OnOff, NULL);
 
-#if defined(__ANDROID__)
-static void Impl_SetColorBufferDepth(INT32 red, INT32 green, INT32 blue, INT32 alpha);
-#endif
-
 UINT8 graphics_started = 0; // Is used in console.c and screen.c
 
 // To disable fullscreen at startup; is set in VID_PrepareModeList
@@ -150,7 +146,7 @@ static void Impl_SetupSoftwareBuffer(void);
 
 static void Impl_InitOpenGL(void);
 
-#if !defined(__ANDROID__) && defined(HAVE_IMAGE)
+#if defined(HAVE_IMAGE)
 #define USE_WINDOW_ICON
 #endif
 
@@ -269,13 +265,11 @@ static void Impl_VideoSetupSurfaces(int width, int height)
 	int bpp = 16;
 	int sw_texture_format = SDL_PIXELFORMAT_ABGR8888;
 
-#if !defined(__ANDROID__)
 	if (!usesdl2soft)
 	{
 		sw_texture_format = SDL_PIXELFORMAT_RGB565;
 	}
 	else
-#endif
 	{
 		bpp = 32;
 		sw_texture_format = SDL_PIXELFORMAT_RGBA8888;
@@ -1559,10 +1553,6 @@ static SDL_bool Impl_CreateWindow(SDL_bool fullscreen)
 	SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
 #endif
 
-#if defined(__ANDROID__)
-	Impl_SetColorBufferDepth(8, 8, 8, 8);
-#endif
-
 	// Create a window
 	window = SDL_CreateWindow("SRB2 "VERSIONSTRING, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, realwidth, realheight, flags);
 	if (window == NULL)
@@ -1616,39 +1606,6 @@ static void Impl_VideoSetupBuffer(void)
 	}
 }
 
-#ifdef HAVE_GLES
-static void Impl_InitGLESDriver(void)
-{
-	const char *driver_name = NULL;
-	int version_major, version_minor;
-
-#ifdef HAVE_GLES2
-	driver_name = "opengles2";
-	version_major = 2;
-	version_minor = 0;
-#else
-	driver_name = "opengles";
-	version_major = 1;
-	version_minor = 1;
-#endif
-
-	SDL_SetHint(SDL_HINT_RENDER_DRIVER, driver_name);
-	SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);
-	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, version_major);
-	SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, version_minor);
-}
-#endif
-
-#if defined(__ANDROID__)
-static void Impl_SetColorBufferDepth(INT32 red, INT32 green, INT32 blue, INT32 alpha)
-{
-	SDL_GL_SetAttribute(SDL_GL_RED_SIZE, red);
-	SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, green);
-	SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, blue);
-	SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, alpha);
-}
-#endif
-
 static void Impl_InitVideoSubSystem(void)
 {
 	if (video_init)
@@ -1660,14 +1617,6 @@ static void Impl_InitVideoSubSystem(void)
 		return;
 	}
 
-#ifdef HAVE_GLES
-	Impl_InitGLESDriver();
-#endif
-
-#ifdef MOBILE_PLATFORM
-	SDL_SetHint(SDL_HINT_ORIENTATIONS, "LandscapeLeft LandscapeRight");
-#endif
-
 	video_init = true;
 }
 
@@ -1693,8 +1642,6 @@ void I_StartupGraphics(void)
 	disable_mouse = M_CheckParm("-nomouse");
 	disable_fullscreen = M_CheckParm("-win") ? 1 : 0;
 
-	// [REDACTED] was also initializing the microphone here for some reason
-	// (should really be in system init instead)
 	keyboard_started = true;
 
 	// If it wasn't already initialized
@@ -1889,10 +1836,8 @@ void I_ShutdownGraphics(void)
 	I_OutputMsg("shut down\n");
 
 #ifdef HWRENDER
-#ifndef HAVE_GLES
 	if (GLUhandle)
 		hwClose(GLUhandle);
-#endif
 	if (sdlglcontext)
 	{
 		SDL_GL_DeleteContext(sdlglcontext);
-- 
GitLab


From 9c1e69e59d1a29c68be402269eb05572cbd34f5d Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 14:03:54 -0300
Subject: [PATCH 16/27] Improve FOV adjustment

---
 src/d_main.c           |  4 ++--
 src/hardware/hw_main.c | 30 +++++++++++++++---------------
 src/hardware/hw_main.h |  3 +--
 src/r_main.c           | 33 +++++++++++++++++++++++++--------
 src/r_main.h           |  5 ++++-
 src/screen.c           |  2 ++
 6 files changed, 49 insertions(+), 28 deletions(-)

diff --git a/src/d_main.c b/src/d_main.c
index 3e97cb49ae..488bb6917e 100644
--- a/src/d_main.c
+++ b/src/d_main.c
@@ -480,7 +480,7 @@ static void D_Display(void)
 					objectsdrawn = 0;
 	#ifdef HWRENDER
 					if (rendermode != render_soft)
-						HWR_RenderPlayerView(0, &players[displayplayer]);
+						HWR_RenderPlayerView(&players[displayplayer]);
 					else
 	#endif
 					if (rendermode != render_none)
@@ -492,7 +492,7 @@ static void D_Display(void)
 				{
 	#ifdef HWRENDER
 					if (rendermode != render_soft)
-						HWR_RenderPlayerView(1, &players[secondarydisplayplayer]);
+						HWR_RenderPlayerView(&players[secondarydisplayplayer]);
 					else
 	#endif
 					if (rendermode != render_none)
diff --git a/src/hardware/hw_main.c b/src/hardware/hw_main.c
index 21e8c0c106..2c5818fed2 100644
--- a/src/hardware/hw_main.c
+++ b/src/hardware/hw_main.c
@@ -5399,17 +5399,15 @@ void HWR_SetViewSize(void)
 
 float HWR_GetFOV(player_t *player)
 {
-	fixed_t pfov = cv_fov.value;
-	float fov;
+	float fov = FixedToFloat(R_GetFOV() + player->fovadd);
 
-	if (player)
-		pfov += player->fovadd;
-
-	fov = FixedToFloat(pfov);
-
-	float resmul = (float)vid.width / (float)vid.height;
-	if (resmul > 1.0)
-		fov = atan(tan(fov * M_PI / 360) * resmul) * 360 / M_PI;
+	// Adjust field of view to the aspect ratio
+	if (cv_fovadjust.value)
+	{
+		fixed_t ftan = FloatToFixed(tan(fov * M_PI / 360));
+		ftan = R_AdjustFOV(ftan);
+		fov = atan(FixedToFloat(ftan)) * 360 / M_PI;
+	}
 
 	return fov;
 }
@@ -5453,12 +5451,13 @@ static void HWR_SetShaderState(void)
 // ==========================================================================
 // Same as rendering the player view, but from the skybox object
 // ==========================================================================
-void HWR_RenderSkyboxView(INT32 viewnumber, player_t *player)
+static void HWR_RenderSkyboxView(player_t *player)
 {
+	INT32 viewnumber = splitscreen && player == &players[secondarydisplayplayer] ? 1 : 0;
 	const float fpov = HWR_GetFOV(player);
 	postimg_t *type;
 
-	if (splitscreen && player == &players[secondarydisplayplayer])
+	if (viewnumber == 1)
 		type = &postimgtype2;
 	else
 		type = &postimgtype;
@@ -5612,8 +5611,9 @@ void HWR_RenderSkyboxView(INT32 viewnumber, player_t *player)
 // ==========================================================================
 //
 // ==========================================================================
-void HWR_RenderPlayerView(INT32 viewnumber, player_t *player)
+void HWR_RenderPlayerView(player_t *player)
 {
+	INT32 viewnumber = splitscreen && player == &players[secondarydisplayplayer] ? 1 : 0;
 	const float fpov = HWR_GetFOV(player);
 	postimg_t *type;
 
@@ -5621,7 +5621,7 @@ void HWR_RenderPlayerView(INT32 viewnumber, player_t *player)
 
 	FRGBAFloat ClearColor;
 
-	if (splitscreen && player == &players[secondarydisplayplayer])
+	if (viewnumber == 1)
 		type = &postimgtype2;
 	else
 		type = &postimgtype;
@@ -5639,7 +5639,7 @@ void HWR_RenderPlayerView(INT32 viewnumber, player_t *player)
 
 	PS_START_TIMING(ps_hw_skyboxtime);
 	if (skybox && drawsky) // If there's a skybox and we should be drawing the sky, draw the skybox
-		HWR_RenderSkyboxView(viewnumber, player); // This is drawn before everything else so it is placed behind
+		HWR_RenderSkyboxView(player); // This is drawn before everything else so it is placed behind
 	PS_STOP_TIMING(ps_hw_skyboxtime);
 
 	{
diff --git a/src/hardware/hw_main.h b/src/hardware/hw_main.h
index fbc365c113..c954eb7fc8 100644
--- a/src/hardware/hw_main.h
+++ b/src/hardware/hw_main.h
@@ -31,8 +31,7 @@ void HWR_drawAMline(const fline_t *fl, INT32 color);
 void HWR_FadeScreenMenuBack(UINT16 color, UINT8 strength);
 void HWR_DrawConsoleBack(UINT32 color, INT32 height);
 void HWR_DrawTutorialBack(UINT32 color, INT32 boxheight);
-void HWR_RenderSkyboxView(INT32 viewnumber, player_t *player);
-void HWR_RenderPlayerView(INT32 viewnumber, player_t *player);
+void HWR_RenderPlayerView(player_t *player);
 void HWR_ClearSkyDome(void);
 void HWR_BuildSkyDome(void);
 void HWR_DrawViewBorder(INT32 clearlines);
diff --git a/src/r_main.c b/src/r_main.c
index df4f676d57..5c2f349cfb 100644
--- a/src/r_main.c
+++ b/src/r_main.c
@@ -168,6 +168,7 @@ consvar_t cv_drawdist_nights = CVAR_INIT ("drawdist_nights", "2048", CV_SAVE, dr
 consvar_t cv_drawdist_precip = CVAR_INIT ("drawdist_precip", "1024", CV_SAVE, drawdist_precip_cons_t, NULL);
 //consvar_t cv_precipdensity = CVAR_INIT ("precipdensity", "Moderate", CV_SAVE, precipdensity_cons_t, NULL);
 consvar_t cv_fov = CVAR_INIT ("fov", "90", CV_FLOAT|CV_CALL, fov_cons_t, Fov_OnChange);
+consvar_t cv_fovadjust = CVAR_INIT ("fovadjust", "On", CV_SAVE|CV_CALL, CV_OnOff, Fov_OnChange);
 
 // Okay, whoever said homremoval causes a performance hit should be shot.
 consvar_t cv_homremoval = CVAR_INIT ("homremoval", "No", CV_SAVE, homremoval_cons_t, NULL);
@@ -215,10 +216,6 @@ void SplitScreen_OnChange(void)
 }
 static void Fov_OnChange(void)
 {
-	// Shouldn't be needed with render parity?
-	//if ((netgame || multiplayer) && !cv_debug && cv_fov.value != 90*FRACUNIT)
-	//	CV_Set(&cv_fov, cv_fov.defaultvalue);
-
 	R_SetViewSize();
 }
 
@@ -940,15 +937,15 @@ void R_ExecuteSetViewSize(void)
 	centerxfrac = centerx<<FRACBITS;
 	centeryfrac = centery<<FRACBITS;
 
-	fov = FixedAngle(cv_fov.value/2) + ANGLE_90;
+	fov = FixedAngle(R_GetFOV()/2) + ANGLE_90;
 	fovtan = FixedMul(FINETANGENT(fov >> ANGLETOFINESHIFT), viewmorph.zoomneeded);
+
 	if (splitscreen == 1) // Splitscreen FOV should be adjusted to maintain expected vertical view
 		fovtan = 17*fovtan/10;
 
 	// Adjust field of view to the aspect ratio
-	fixed_t resmul = FixedDiv(vid.width * FRACUNIT, vid.height * FRACUNIT);
-	if (resmul > FRACUNIT)
-		fovtan = FixedMul(fovtan, resmul);
+	if (cv_fovadjust.value)
+		fovtan = R_AdjustFOV(fovtan);
 
 	projection = projectiony = FixedDiv(centerxfrac, fovtan);
 
@@ -1042,6 +1039,25 @@ void R_Init(void)
 	framecount = 0;
 }
 
+fixed_t R_GetFOV(void)
+{
+	return cv_fov.value;
+}
+
+fixed_t R_AdjustFOV(fixed_t ftan)
+{
+	fixed_t aspect = FixedDiv(vid.width, vid.height);
+	fixed_t baseaspect = FixedDiv(FRACUNIT, FixedDiv(BASEVIDWIDTH, BASEVIDHEIGHT));
+
+	// (vid.width / vid.height) * (1.0 / (BASEVIDWIDTH / BASEVIDHEIGHT))
+	fixed_t resmul = FixedMul(aspect, baseaspect);
+
+	if (resmul > FRACUNIT)
+		return FixedMul(ftan, resmul);
+
+	return ftan;
+}
+
 //
 // R_PointInSubsector
 //
@@ -1601,6 +1617,7 @@ void R_RegisterEngineStuff(void)
 	CV_RegisterVar(&cv_drawdist);
 	CV_RegisterVar(&cv_drawdist_nights);
 	CV_RegisterVar(&cv_drawdist_precip);
+	CV_RegisterVar(&cv_fovadjust);
 	CV_RegisterVar(&cv_fov);
 
 	CV_RegisterVar(&cv_chasecam);
diff --git a/src/r_main.h b/src/r_main.h
index f08070d0f3..9e5e462d6f 100644
--- a/src/r_main.h
+++ b/src/r_main.h
@@ -117,7 +117,7 @@ extern consvar_t cv_shadow;
 extern consvar_t cv_ffloorclip;
 extern consvar_t cv_translucency;
 extern consvar_t cv_drawdist, cv_drawdist_nights, cv_drawdist_precip;
-extern consvar_t cv_fov;
+extern consvar_t cv_fov, cv_fovadjust;
 extern consvar_t cv_skybox;
 extern consvar_t cv_tailspickup;
 
@@ -137,6 +137,9 @@ void R_ExecuteSetViewSize(void);
 void R_SetupFrame(player_t *player);
 void R_SkyboxFrame(player_t *player);
 
+fixed_t R_GetFOV(void);
+fixed_t R_AdjustFOV(fixed_t ftan);
+
 boolean R_ViewpointHasChasecam(player_t *player);
 boolean R_IsViewpointThirdPerson(player_t *player, boolean skybox);
 
diff --git a/src/screen.c b/src/screen.c
index 6e4a068b34..263ffe859c 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -374,7 +374,9 @@ static boolean SCR_SetSize(INT32 width, INT32 height)
 		vid.change.width = width;
 		vid.change.height = height;
 		vid.change.renderer = -1;
+		return true;
 	}
+	return false;
 }
 
 void SCR_ChangeResolution(INT32 width, INT32 height)
-- 
GitLab


From 758dcfd02c7912fee2a43913cab113a1f6752d5e Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 14:10:14 -0300
Subject: [PATCH 17/27] Reorganize video options menu entries

---
 src/m_menu.c | 113 ++++++++++++++++++++++++---------------------------
 1 file changed, 53 insertions(+), 60 deletions(-)

diff --git a/src/m_menu.c b/src/m_menu.c
index 9e571eb6f5..f69c8e3375 100644
--- a/src/m_menu.c
+++ b/src/m_menu.c
@@ -1302,70 +1302,67 @@ static menuitem_t OP_Camera2ExtendedOptionsMenu[] =
 enum
 {
 	op_video_resolution = 1,
-#if defined (__unix__) || defined (UNIXCOMMON) || defined (HAVE_SDL)
-	op_video_fullscreen,
-#endif
-	op_video_vsync,
-	op_video_renderer,
+	op_video_renderer = 5,
 };
 
 static menuitem_t OP_VideoOptionsMenu[] =
 {
 	{IT_HEADER, NULL, "Screen", NULL, 0},
-	{IT_STRING | IT_CALL,  NULL, "Set Resolution...",       M_VideoModeMenu,          6},
+	{IT_STRING | IT_CALL, NULL, "Set Resolution...",  M_VideoModeMenu,    6},  // op_video_resolution
+	{IT_STRING | IT_CVAR, NULL, "Fullscreen (F11)",   &cv_fullscreen,     11},
+	{IT_STRING | IT_CVAR, NULL, "Vertical Sync",      &cv_vidwait,        16},
 
-#if defined (__unix__) || defined (UNIXCOMMON) || defined (HAVE_SDL)
-	{IT_STRING|IT_CVAR,      NULL, "Fullscreen (F11)",          &cv_fullscreen,      11},
+	{IT_HEADER, NULL, "Renderer", NULL, 25},
+#ifdef HWRENDER
+	{IT_STRING | IT_CVAR, NULL, "Renderer (F10)",    &cv_renderer,        31}, // op_video_renderer
+#else
+	{IT_TRANSTEXT | IT_PAIR, "Renderer", "Software", &cv_renderer,        31},
 #endif
-	{IT_STRING | IT_CVAR, NULL, "Vertical Sync",                &cv_vidwait,         16},
+	{IT_STRING | IT_CVAR
+	 | IT_CV_FLOATSLIDER, NULL, "Field of view",     &cv_fov,             36},
+	{IT_STRING | IT_CVAR, NULL, "FPS Cap",           &cv_fpscap,          41},
 #ifdef HWRENDER
-	{IT_STRING | IT_CVAR, NULL, "Renderer (F10)",               &cv_renderer,        21},
+	{IT_CALL | IT_STRING, NULL, "OpenGL Options...", M_OpenGLOptionsMenu, 46},
 #else
-	{IT_TRANSTEXT | IT_PAIR, "Renderer", "Software",            &cv_renderer,        21},
+	{IT_TRANSTEXT,        NULL, "OpenGL Options...", NULL, 46},
 #endif
 
-	{IT_HEADER, NULL, "Color Profile", NULL, 30},
-	{IT_STRING | IT_CVAR | IT_CV_SLIDER, NULL, "Brightness", &cv_globalgamma,36},
-	{IT_STRING | IT_CVAR | IT_CV_SLIDER, NULL, "Saturation", &cv_globalsaturation, 41},
-	{IT_SUBMENU|IT_STRING, NULL, "Advanced Settings...",     &OP_ColorOptionsDef,  46},
+	{IT_HEADER, NULL, "Color Profile", NULL, 55},
+	{IT_STRING | IT_CVAR | IT_CV_SLIDER, NULL, "Brightness", &cv_globalgamma,      61},
+	{IT_STRING | IT_CVAR | IT_CV_SLIDER, NULL, "Saturation", &cv_globalsaturation, 66},
+	{IT_SUBMENU|IT_STRING, NULL, "Advanced Settings...",     &OP_ColorOptionsDef,  71},
 
-	{IT_HEADER, NULL, "Heads-Up Display", NULL, 55},
-	{IT_STRING | IT_CVAR, NULL, "Show HUD",                  &cv_showhud,          61},
+	{IT_HEADER, NULL, "Heads-Up Display", NULL, 80},
+	{IT_STRING | IT_CVAR, NULL, "Show HUD",           &cv_showhud,        86},
 	{IT_STRING | IT_CVAR | IT_CV_SLIDER,
-	                      NULL, "HUD Transparency",          &cv_translucenthud,   66},
-	{IT_STRING | IT_CVAR, NULL, "Score/Time/Rings",          &cv_timetic,          71},
-	{IT_STRING | IT_CVAR, NULL, "Show Powerups",             &cv_powerupdisplay,   76},
-	{IT_STRING | IT_CVAR, NULL, "Local ping display",		&cv_showping,			81}, // shows ping next to framerate if we want to.
-	{IT_STRING | IT_CVAR, NULL, "Show player names",         &cv_seenames,         86},
-
-	{IT_HEADER, NULL, "Console", NULL, 95},
-	{IT_STRING | IT_CVAR, NULL, "Background color",          &cons_backcolor,      101},
-	{IT_STRING | IT_CVAR, NULL, "Text Size",                 &cv_constextsize,    106},
-
-	{IT_HEADER, NULL, "Chat", NULL, 115},
-	{IT_STRING | IT_CVAR, NULL, "Chat Mode",            		 	 &cv_consolechat,  121},
-	{IT_STRING | IT_CVAR | IT_CV_SLIDER, NULL, "Chat Box Width",    &cv_chatwidth,     126},
-	{IT_STRING | IT_CVAR | IT_CV_SLIDER, NULL, "Chat Box Height",   &cv_chatheight,    131},
-	{IT_STRING | IT_CVAR, NULL, "Message Fadeout Time",              &cv_chattime,    136},
-	{IT_STRING | IT_CVAR, NULL, "Chat Notifications",           	 &cv_chatnotifications,  141},
-	{IT_STRING | IT_CVAR, NULL, "Spam Protection",           		 &cv_chatspamprotection,  146},
-	{IT_STRING | IT_CVAR, NULL, "Chat background tint",           	 &cv_chatbacktint,  151},
-
-	{IT_HEADER, NULL, "Level", NULL, 160},
-	{IT_STRING | IT_CVAR, NULL, "Draw Distance",             &cv_drawdist,        166},
-	{IT_STRING | IT_CVAR, NULL, "Weather Draw Dist.",        &cv_drawdist_precip, 171},
-	{IT_STRING | IT_CVAR, NULL, "NiGHTS Hoop Draw Dist.",    &cv_drawdist_nights, 176},
-
-	{IT_HEADER, NULL, "Diagnostic", NULL, 184},
-	{IT_STRING | IT_CVAR, NULL, "Show FPS",                  &cv_ticrate,         190},
-	{IT_STRING | IT_CVAR, NULL, "Clear Before Redraw",       &cv_homremoval,      195},
-	{IT_STRING | IT_CVAR, NULL, "Show \"FOCUS LOST\"",       &cv_showfocuslost,   200},
-
-#ifdef HWRENDER
-	{IT_HEADER, NULL, "Renderer", NULL, 208},
-	{IT_CALL | IT_STRING, NULL, "OpenGL Options...",         M_OpenGLOptionsMenu, 214},
-	{IT_STRING | IT_CVAR, NULL, "FPS Cap",                   &cv_fpscap,          219},
-#endif
+	                      NULL, "HUD Transparency",   &cv_translucenthud, 91},
+	{IT_STRING | IT_CVAR, NULL, "Score/Time/Rings",   &cv_timetic,        96},
+	{IT_STRING | IT_CVAR, NULL, "Show Powerups",      &cv_powerupdisplay, 101},
+	{IT_STRING | IT_CVAR, NULL, "Local ping display", &cv_showping,       106}, // shows ping next to framerate if we want to.
+	{IT_STRING | IT_CVAR, NULL, "Show player names",  &cv_seenames,       111},
+
+	{IT_HEADER, NULL, "Console", NULL, 120},
+	{IT_STRING | IT_CVAR, NULL, "Background color", &cons_backcolor,  126},
+	{IT_STRING | IT_CVAR, NULL, "Text Size",        &cv_constextsize, 131},
+
+	{IT_HEADER, NULL, "Chat", NULL, 140},
+	{IT_STRING | IT_CVAR, NULL, "Chat Mode",                      &cv_consolechat,        146},
+	{IT_STRING | IT_CVAR | IT_CV_SLIDER, NULL, "Chat Box Width",  &cv_chatwidth,          151},
+	{IT_STRING | IT_CVAR | IT_CV_SLIDER, NULL, "Chat Box Height", &cv_chatheight,         156},
+	{IT_STRING | IT_CVAR, NULL, "Message Fadeout Time",           &cv_chattime,           161},
+	{IT_STRING | IT_CVAR, NULL, "Chat Notifications",             &cv_chatnotifications,  166},
+	{IT_STRING | IT_CVAR, NULL, "Spam Protection",                &cv_chatspamprotection, 171},
+	{IT_STRING | IT_CVAR, NULL, "Chat background tint",           &cv_chatbacktint,       176},
+
+	{IT_HEADER, NULL, "Level", NULL, 185},
+	{IT_STRING | IT_CVAR, NULL, "Draw Distance",          &cv_drawdist,        191},
+	{IT_STRING | IT_CVAR, NULL, "Weather Draw Dist.",     &cv_drawdist_precip, 196},
+	{IT_STRING | IT_CVAR, NULL, "NiGHTS Hoop Draw Dist.", &cv_drawdist_nights, 201},
+
+	{IT_HEADER, NULL, "Diagnostic", NULL, 210},
+	{IT_STRING | IT_CVAR, NULL, "Show FPS",            &cv_ticrate,         216},
+	{IT_STRING | IT_CVAR, NULL, "Clear Before Redraw", &cv_homremoval,      221},
+	{IT_STRING | IT_CVAR, NULL, "Show \"FOCUS LOST\"", &cv_showfocuslost,   226},
 };
 
 static menuitem_t OP_VideoModeMenu[] =
@@ -1425,17 +1422,13 @@ static menuitem_t OP_OpenGLOptionsMenu[] =
 	{IT_HEADER, NULL, "General", NULL, 51},
 	{IT_STRING|IT_CVAR,         NULL, "Shaders",             &cv_glshaders,            63},
 	{IT_STRING|IT_CVAR,         NULL, "Lack of perspective", &cv_glshearing,           73},
-	{IT_STRING|IT_CVAR,         NULL, "Field of view",       &cv_fov,                  83},
 
-	{IT_HEADER, NULL, "Miscellaneous", NULL, 102},
-	{IT_STRING|IT_CVAR,         NULL, "Bit depth",           &cv_scr_depth,           114},
-	{IT_STRING|IT_CVAR,         NULL, "Texture filter",      &cv_glfiltermode,        124},
-	{IT_STRING|IT_CVAR,         NULL, "Anisotropic",         &cv_glanisotropicmode,   134},
+	{IT_HEADER, NULL, "Miscellaneous", NULL, 92},
+	{IT_STRING|IT_CVAR,         NULL, "Bit depth",           &cv_scr_depth,           104},
+	{IT_STRING|IT_CVAR,         NULL, "Texture filter",      &cv_glfiltermode,        114},
+	{IT_STRING|IT_CVAR,         NULL, "Anisotropic",         &cv_glanisotropicmode,   124},
 #ifdef ALAM_LIGHTING
-	{IT_SUBMENU|IT_STRING,      NULL, "Lighting...",         &OP_OpenGLLightingDef,   144},
-#endif
-#if defined (_WINDOWS) && (!(defined (__unix__) || defined (UNIXCOMMON) || defined (HAVE_SDL)))
-	{IT_STRING|IT_CVAR,         NULL, "Fullscreen",          &cv_fullscreen,          154},
+	{IT_SUBMENU|IT_STRING,      NULL, "Lighting...",         &OP_OpenGLLightingDef,   134},
 #endif
 };
 
-- 
GitLab


From 9d9be887f6ec9f9393e74c524cd2cd4feb0ac4ad Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 14:11:14 -0300
Subject: [PATCH 18/27] Save window dimensions if the user resizes it

---
 src/sdl/i_video.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index a0a6b7bc38..f4922472d4 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -697,7 +697,10 @@ static void Impl_HandleWindowEvent(SDL_WindowEvent evt)
 			break;
 		case SDL_WINDOWEVENT_SIZE_CHANGED:
 			if ((SDL_GetWindowFlags(window) & SDL_WINDOW_FULLSCREEN_DESKTOP) == 0)
+			{
 				SCR_SetSizeNoRestore(evt.data1, evt.data2);
+				SCR_SetDefaultMode(evt.data1, evt.data2);
+			}
 			break;
 	}
 
-- 
GitLab


From 22d3524893a047a72c6f357f12bb872a45ce204e Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 14:29:33 -0300
Subject: [PATCH 19/27] Set fullscreen resolution defaults to the current
 display's size

---
 src/i_video.h     |  8 ++++++
 src/sdl/i_video.c | 69 +++++++++++++++++++++++++++++++++++++----------
 2 files changed, 63 insertions(+), 14 deletions(-)

diff --git a/src/i_video.h b/src/i_video.h
index 213d362a47..258c919e81 100644
--- a/src/i_video.h
+++ b/src/i_video.h
@@ -100,10 +100,18 @@ const char *VID_GetModeName(INT32 modenum);
 
 void VID_PrepareModeList(void); /// note hack for SDL
 
+/**	\brief Returns true if the window is maximized, and false if not
+*/
 boolean VID_IsMaximized(void);
 
+/**	\brief Restores the window
+*/
 void VID_RestoreWindow(void);
 
+/**	\brief Gets the current display's size; returns true if it succeeded, and false if not
+*/
+boolean VID_GetNativeResolution(INT32 *width, INT32 *height);
+
 /**	\brief can video system do fullscreen
 */
 extern boolean allow_fullscreen;
diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index f4922472d4..373ee689cc 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -146,6 +146,8 @@ static void Impl_SetupSoftwareBuffer(void);
 
 static void Impl_InitOpenGL(void);
 
+static void Impl_SetDefaultWindowSizes(void);
+
 #if defined(HAVE_IMAGE)
 #define USE_WINDOW_ICON
 #endif
@@ -360,6 +362,8 @@ static SDL_bool SDLSetMode(INT32 width, INT32 height, SDL_bool fullscreen, SDL_b
 		SDL_SetWindowSize(window, width, height);
 		if (fullscreen)
 			SDL_SetWindowFullscreen(window, fullscreen_type);
+
+		Impl_SetDefaultWindowSizes();
 	}
 
 	if (Impl_RenderContextReset() == SDL_FALSE)
@@ -410,6 +414,36 @@ static UINT32 VID_GetRefreshRate(void)
 	return m.refresh_rate;
 }
 
+static void Impl_SetDefaultWindowSizes(void)
+{
+	INT32 native_width, native_height;
+
+	if (!VID_GetNativeResolution(&native_width, &native_height))
+		return;
+
+	char *result, *buffer1, *buffer2;
+
+	result = va("%d", native_width);
+	buffer1 = malloc(strlen(result) + 1);
+	if (!buffer1)
+		return;
+
+	strcpy(buffer1, result);
+
+	result = va("%d", native_height);
+	buffer2 = malloc(strlen(result) + 1);
+	if (!buffer2)
+	{
+		free(buffer1);
+		return;
+	}
+
+	strcpy(buffer2, result);
+
+	cv_scr_width.defaultvalue = buffer1;
+	cv_scr_height.defaultvalue = buffer2;
+}
+
 static INT32 Impl_SDL_Scancode_To_Keycode(SDL_Scancode code)
 {
 	if (code >= SDL_SCANCODE_A && code <= SDL_SCANCODE_Z)
@@ -1473,38 +1507,45 @@ boolean VID_CheckRenderer(void)
 	return rendererchanged;
 }
 
-#if 0
-static void Impl_GetCurrentDisplayMode(INT32 *width, INT32 *height)
+static boolean Impl_GetCurrentDisplayMode(INT32 *width, INT32 *height)
 {
 	int i = SDL_GetWindowDisplayIndex(window);
-	SDL_DisplayMode resolution;
-
 	if (i < 0)
-		return;
+		return false;
+
+	SDL_DisplayMode resolution;
 
-	if (!SDL_GetCurrentDisplayMode(i, &resolution))
+	if (SDL_GetCurrentDisplayMode(i, &resolution) == 0)
 	{
 		if ((*width) == 0)
 			(*width) = (INT32)(resolution.w);
 		if ((*height) == 0)
 			(*height) = (INT32)(resolution.h);
+		return true;
 	}
+
+	return false;
 }
 
-void VID_GetNativeResolution(INT32 *width, INT32 *height)
+boolean VID_GetNativeResolution(INT32 *width, INT32 *height)
 {
 	INT32 w = 0, h = 0;
 
-	if (!w || !h)
-		Impl_GetCurrentDisplayMode(&w, &h);
+	boolean success = Impl_GetCurrentDisplayMode(&w, &h);
 
-	if (!w) w = BASEVIDWIDTH;
-	if (!h) h = BASEVIDHEIGHT;
+	if (!success)
+	{
+		w = BASEVIDWIDTH;
+		h = BASEVIDHEIGHT;
+	}
+
+	if (width)
+		*width = w;
+	if (height)
+		*height = h;
 
-	if (width) *width = w;
-	if (height) *height = h;
+	return success;
 }
-#endif
 
 void VID_SetSize(INT32 width, INT32 height)
 {
-- 
GitLab


From bf9ff41115ee6c90b9e075f91b0b02c9f1056f6e Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Tue, 25 Jul 2023 14:36:22 -0300
Subject: [PATCH 20/27] Set fullscreen resolution defaults whenever the display
 changes

---
 src/sdl/i_video.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index 373ee689cc..9ffe89d41f 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -416,8 +416,10 @@ static UINT32 VID_GetRefreshRate(void)
 
 static void Impl_SetDefaultWindowSizes(void)
 {
-	INT32 native_width, native_height;
+	static char *default_width = NULL;
+	static char *default_height = NULL;
 
+	INT32 native_width, native_height;
 	if (!VID_GetNativeResolution(&native_width, &native_height))
 		return;
 
@@ -440,6 +442,12 @@ static void Impl_SetDefaultWindowSizes(void)
 
 	strcpy(buffer2, result);
 
+	free(default_width);
+	free(default_height);
+
+	default_width = buffer1;
+	default_height = buffer2;
+
 	cv_scr_width.defaultvalue = buffer1;
 	cv_scr_height.defaultvalue = buffer2;
 }
@@ -736,6 +744,9 @@ static void Impl_HandleWindowEvent(SDL_WindowEvent evt)
 				SCR_SetDefaultMode(evt.data1, evt.data2);
 			}
 			break;
+		case SDL_WINDOWEVENT_DISPLAY_CHANGED:
+			Impl_SetDefaultWindowSizes();
+			break;
 	}
 
 	if (mousefocus && kbfocus)
-- 
GitLab


From 041fa04db12278ecc2f613f50b27828ded994667 Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Wed, 26 Jul 2023 17:01:02 -0300
Subject: [PATCH 21/27] Fix R_SplitSprite

---
 src/r_things.c | 29 +++++++++++++++++------------
 1 file changed, 17 insertions(+), 12 deletions(-)

diff --git a/src/r_things.c b/src/r_things.c
index 3423396c37..fc3bbc1e6d 100644
--- a/src/r_things.c
+++ b/src/r_things.c
@@ -1070,17 +1070,13 @@ static void R_DrawPrecipitationVisSprite(vissprite_t *vis)
 
 //
 // R_SplitSprite
-// runs through a sector's lightlist and Knuckles
+// runs through a sector's lightlist and splits the sprite according to the heights
+//
 static void R_SplitSprite(vissprite_t *sprite)
 {
-	INT32 i, lightnum, lindex;
-	INT16 cutfrac;
-	sector_t *sector;
-	vissprite_t *newsprite;
-
-	sector = sprite->sector;
+	sector_t *sector = sprite->sector;
 
-	for (i = 1; i < sector->numlights; i++)
+	for (INT32 i = 1; i < sector->numlights; i++)
 	{
 		fixed_t testheight;
 
@@ -1094,7 +1090,7 @@ static void R_SplitSprite(vissprite_t *sprite)
 		if (testheight <= sprite->gz)
 			return;
 
-		cutfrac = (INT16)((centeryfrac - FixedMul(testheight - viewz, sprite->linkscale))>>FRACBITS);
+		INT16 cutfrac = (INT16)((centeryfrac - FixedMul(testheight - viewz, sprite->linkscale))>>FRACBITS);
 		if (cutfrac < 0)
 			continue;
 		if (cutfrac > viewheight)
@@ -1102,7 +1098,16 @@ static void R_SplitSprite(vissprite_t *sprite)
 
 		// Found a split! Make a new sprite, copy the old sprite to it, and
 		// adjust the heights.
-		newsprite = M_Memcpy(R_NewVisSprite(), sprite, sizeof (vissprite_t));
+		vissprite_t *newsprite = R_NewVisSprite();
+
+		// Needs to keep the new sprite's clipping tables
+		INT16 *cliptop = newsprite->cliptop;
+		INT16 *clipbot = newsprite->clipbot;
+
+		M_Memcpy(newsprite, sprite, sizeof (vissprite_t));
+
+		newsprite->cliptop = cliptop;
+		newsprite->clipbot = clipbot;
 
 		newsprite->cut |= (sprite->cut & SC_FLAGMASK);
 
@@ -1127,7 +1132,7 @@ static void R_SplitSprite(vissprite_t *sprite)
 		newsprite->cut |= SC_TOP;
 		if (!(sector->lightlist[i].caster->fofflags & FOF_NOSHADE))
 		{
-			lightnum = (*sector->lightlist[i].lightlevel >> LIGHTSEGSHIFT);
+			INT32 lightnum = (*sector->lightlist[i].lightlevel >> LIGHTSEGSHIFT);
 
 			if (lightnum < 0)
 				spritelights = scalelight[0];
@@ -1141,7 +1146,7 @@ static void R_SplitSprite(vissprite_t *sprite)
 			if (!(newsprite->cut & SC_FULLBRIGHT)
 				|| (newsprite->extra_colormap && (newsprite->extra_colormap->flags & CMF_FADEFULLBRIGHTSPRITES)))
 			{
-				lindex = FixedMul(sprite->xscale, LIGHTRESOLUTIONFIX)>>(LIGHTSCALESHIFT);
+				INT32 lindex = FixedMul(sprite->xscale, LIGHTRESOLUTIONFIX)>>(LIGHTSCALESHIFT);
 
 				if (lindex >= MAXLIGHTSCALE)
 					lindex = MAXLIGHTSCALE-1;
-- 
GitLab


From c1cb487e9db684febae26c6ed5cf73d7370bf3e6 Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Wed, 26 Jul 2023 17:15:35 -0300
Subject: [PATCH 22/27] Remove last traces of vid.modenum

---
 src/g_demo.c           |  6 ++---
 src/hardware/hw_draw.c | 61 ------------------------------------------
 src/hardware/hw_main.h |  1 -
 src/screen.c           |  4 +--
 src/screen.h           | 14 ++++------
 src/sdl/i_video.c      |  2 --
 src/v_video.c          | 21 ++-------------
 7 files changed, 11 insertions(+), 98 deletions(-)

diff --git a/src/g_demo.c b/src/g_demo.c
index 0403da16da..9650777ac4 100644
--- a/src/g_demo.c
+++ b/src/g_demo.c
@@ -2475,7 +2475,7 @@ static void G_StopTimingDemo(void)
 	{
 		FILE *f;
 		const char *csvpath = va("%s"PATHSEP"%s", srb2home, "timedemo.csv");
-		const char *header = "id,demoname,seconds,avgfps,leveltime,demotime,framecount,ticrate,rendermode,vidmode,vidwidth,vidheight,procbits\n";
+		const char *header = "id,demoname,seconds,avgfps,leveltime,demotime,framecount,ticrate,rendermode,vidwidth,vidheight,procbits\n";
 		const char *rowformat = "\"%s\",\"%s\",%f,%f,%u,%d,%u,%u,%u,%u,%u,%u,%u\n";
 		boolean headerrow = !FIL_FileExists(csvpath);
 		UINT8 procbits = 0;
@@ -2493,7 +2493,7 @@ static void G_StopTimingDemo(void)
 			if (headerrow)
 				fputs(header, f);
 			fprintf(f, rowformat,
-				timedemo_csv_id,timedemo_name,f1/TICRATE,f2/f1,leveltime,demotime,(UINT32)framecount,TICRATE,rendermode,vid.modenum,vid.width,vid.height,procbits);
+				timedemo_csv_id,timedemo_name,f1/TICRATE,f2/f1,leveltime,demotime,(UINT32)framecount,TICRATE,rendermode,vid.width,vid.height,procbits);
 			fclose(f);
 			CONS_Printf("Timedemo results saved to '%s'\n", csvpath);
 		}
@@ -2502,7 +2502,7 @@ static void G_StopTimingDemo(void)
 			// Just print the CSV output to console
 			CON_LogMessage(header);
 			CONS_Printf(rowformat,
-				timedemo_csv_id,timedemo_name,f1/TICRATE,f2/f1,leveltime,demotime,(UINT32)framecount,TICRATE,rendermode,vid.modenum,vid.width,vid.height,procbits);
+				timedemo_csv_id,timedemo_name,f1/TICRATE,f2/f1,leveltime,demotime,(UINT32)framecount,TICRATE,rendermode,vid.width,vid.height,procbits);
 		}
 	}
 
diff --git a/src/hardware/hw_draw.c b/src/hardware/hw_draw.c
index d9a0fefe6c..7f47f73763 100644
--- a/src/hardware/hw_draw.c
+++ b/src/hardware/hw_draw.c
@@ -62,67 +62,6 @@ static UINT8 softwaretranstogl[11]    = {  0, 25, 51, 76,102,127,153,178,204,229
 static UINT8 softwaretranstogl_hi[11] = {  0, 51,102,153,204,255,255,255,255,255,255};
 static UINT8 softwaretranstogl_lo[11] = {  0, 12, 24, 36, 48, 60, 71, 83, 95,111,127};
 
-//
-// -----------------+
-// HWR_DrawPatch    : Draw a 'tile' graphic
-// Notes            : x,y : positions relative to the original Doom resolution
-//                  : textes(console+score) + menus + status bar
-// -----------------+
-void HWR_DrawPatch(patch_t *gpatch, INT32 x, INT32 y, INT32 option)
-{
-	FOutVector v[4];
-	FBITFIELD flags;
-	GLPatch_t *hwrPatch;
-
-//  3--2
-//  | /|
-//  |/ |
-//  0--1
-	float sdupx = FIXED_TO_FLOAT(vid.fdupx)*2.0f;
-	float sdupy = FIXED_TO_FLOAT(vid.fdupy)*2.0f;
-	float pdupx = FIXED_TO_FLOAT(vid.fdupx)*2.0f;
-	float pdupy = FIXED_TO_FLOAT(vid.fdupy)*2.0f;
-
-	// make patch ready in hardware cache
-	HWR_GetPatch(gpatch);
-	hwrPatch = ((GLPatch_t *)gpatch->hardware);
-
-	switch (option & V_SCALEPATCHMASK)
-	{
-	case V_NOSCALEPATCH:
-		pdupx = pdupy = 2.0f;
-		break;
-	case V_SMALLSCALEPATCH:
-		pdupx = 2.0f * FIXED_TO_FLOAT(vid.fsmalldupx);
-		pdupy = 2.0f * FIXED_TO_FLOAT(vid.fsmalldupy);
-		break;
-	case V_MEDSCALEPATCH:
-		pdupx = 2.0f * FIXED_TO_FLOAT(vid.fmeddupx);
-		pdupy = 2.0f * FIXED_TO_FLOAT(vid.fmeddupy);
-		break;
-	}
-
-	if (option & V_NOSCALESTART)
-		sdupx = sdupy = 2.0f;
-
-	v[0].x = v[3].x = (x*sdupx-(gpatch->leftoffset)*pdupx)/vid.width - 1;
-	v[2].x = v[1].x = (x*sdupx+(gpatch->width-gpatch->leftoffset)*pdupx)/vid.width - 1;
-	v[0].y = v[1].y = 1-(y*sdupy-(gpatch->topoffset)*pdupy)/vid.height;
-	v[2].y = v[3].y = 1-(y*sdupy+(gpatch->height-gpatch->topoffset)*pdupy)/vid.height;
-
-	v[0].z = v[1].z = v[2].z = v[3].z = 1.0f;
-
-	v[0].s = v[3].s = 0.0f;
-	v[2].s = v[1].s = hwrPatch->max_s;
-	v[0].t = v[1].t = 0.0f;
-	v[2].t = v[3].t = hwrPatch->max_t;
-
-	flags = PF_Translucent|PF_NoDepthTest;
-
-	// clip it since it is used for bunny scroll in doom I
-	HWD.pfnDrawPolygon(NULL, v, 4, flags);
-}
-
 void HWR_DrawStretchyFixedPatch(patch_t *gpatch, fixed_t x, fixed_t y, fixed_t pscale, fixed_t vscale, INT32 option, const UINT8 *colormap)
 {
 	FOutVector v[4];
diff --git a/src/hardware/hw_main.h b/src/hardware/hw_main.h
index c954eb7fc8..82777ab3dd 100644
--- a/src/hardware/hw_main.h
+++ b/src/hardware/hw_main.h
@@ -37,7 +37,6 @@ void HWR_BuildSkyDome(void);
 void HWR_DrawViewBorder(INT32 clearlines);
 void HWR_DrawFlatFill(INT32 x, INT32 y, INT32 w, INT32 h, lumpnum_t flatlumpnum);
 void HWR_SetViewSize(void);
-void HWR_DrawPatch(patch_t *gpatch, INT32 x, INT32 y, INT32 option);
 void HWR_DrawStretchyFixedPatch(patch_t *gpatch, fixed_t x, fixed_t y, fixed_t pscale, fixed_t vscale, INT32 option, const UINT8 *colormap);
 void HWR_DrawCroppedPatch(patch_t *gpatch, fixed_t x, fixed_t y, fixed_t pscale, fixed_t vscale, INT32 option, const UINT8 *colormap, fixed_t sx, fixed_t sy, fixed_t w, fixed_t h);
 void HWR_MakePatch(const patch_t *patch, GLPatch_t *grPatch, GLMipmap_t *grMipmap, boolean makebitmap);
diff --git a/src/screen.c b/src/screen.c
index 263ffe859c..e756f9442f 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -309,8 +309,6 @@ void SCR_Startup(void)
 		return;
 	}
 
-	vid.modenum = 0;
-
 	V_Init();
 	V_Recalc();
 
@@ -473,7 +471,7 @@ void SCR_CheckDefaultMode(void)
 	}
 }
 
-// sets the modenum as the new default video mode to be saved in the config file
+// sets the resolution as the new default to be saved in the config file
 void SCR_SetDefaultMode(INT32 width, INT32 height)
 {
 	CV_SetValue(cv_fullscreen.value ? &cv_scr_width : &cv_scr_width_w, width);
diff --git a/src/screen.h b/src/screen.h
index 43c01cf310..0f9191deeb 100644
--- a/src/screen.h
+++ b/src/screen.h
@@ -45,15 +45,16 @@
 // global video state
 typedef struct viddef_s
 {
-	INT32 modenum; // vidmode num indexes videomodes list
-
 	UINT8 *buffer; // invisible screens buffer
 	size_t rowbytes; // bytes per scanline of the VIDEO mode
 	INT32 width; // PIXELS per scanline
 	INT32 height;
 	INT32 recalc; // if true, recalc vid-based stuff
-	UINT8 *direct; // linear frame buffer, or vga base mem.
+
 	INT32 dupx, dupy; // scale 1, 2, 3 value for menus & overlays
+	UINT8 smalldupx, smalldupy; // factor for a little bit of scaling
+	UINT8 meddupx, meddupy; // factor for moderate, but not full, scaling
+
 	INT32 fdupx, fdupy; // same as dupx, dupy, but exact value when aspect ratio isn't 320/200
 	INT32 bpp; // BYTES per pixel: 1 = 256color, 2 = highcolor
 
@@ -64,13 +65,8 @@ typedef struct viddef_s
 		UINT8 set;
 	} change;
 
-	// for Win32 version
-	UINT8 smalldupx, smalldupy; // factor for a little bit of scaling
-	UINT8 meddupx, meddupy; // factor for moderate, but not full, scaling
 #ifdef HWRENDER
-	INT32/*fixed_t*/ fsmalldupx, fsmalldupy;
-	INT32/*fixed_t*/ fmeddupx, fmeddupy;
-	INT32 glstate;
+	UINT8 glstate;
 #endif
 } viddef_t;
 
diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index 9ffe89d41f..fe099640a6 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -299,7 +299,6 @@ static void Impl_SetupSoftwareBuffer(void)
 	size_t size;
 
 	vid.rowbytes = vid.width * vid.bpp;
-	vid.direct = NULL;
 
 	free(vid.buffer);
 
@@ -1773,7 +1772,6 @@ void I_StartupGraphics(void)
 	// Fury: we do window initialization after GL setup to allow
 	// SDL_GL_LoadLibrary to work well on Windows
 	vid.recalc = true;
-	vid.direct = NULL;
 	vid.bpp = 1;
 
 	// Create window
diff --git a/src/v_video.c b/src/v_video.c
index 461a5e3bc7..63d49ec153 100644
--- a/src/v_video.c
+++ b/src/v_video.c
@@ -3778,9 +3778,6 @@ void V_Init(void)
 			screens[i] = base + i*screensize;
 	}
 
-	if (vid.direct)
-		screens[0] = vid.direct;
-
 #ifdef DEBUG
 	CONS_Debug(DBG_RENDER, "V_Init done:\n");
 	for (i = 0; i < NUMSCREENS; i++)
@@ -3795,28 +3792,14 @@ void V_Recalc(void)
 	vid.dupx = vid.width / BASEVIDWIDTH;
 	vid.dupy = vid.height / BASEVIDHEIGHT;
 	vid.dupx = vid.dupy = (vid.dupx < vid.dupy ? vid.dupx : vid.dupy);
+
 	vid.fdupx = FixedDiv(vid.width*FRACUNIT, BASEVIDWIDTH*FRACUNIT);
 	vid.fdupy = FixedDiv(vid.height*FRACUNIT, BASEVIDHEIGHT*FRACUNIT);
-
-#ifdef HWRENDER
-	//if (rendermode != render_opengl && rendermode != render_none) // This was just placing it incorrectly at non aspect correct resolutions in opengl
-	// 13/11/18:
-	// The above is no longer necessary, since we want OpenGL to be just like software now
-	// -- Monster Iestyn
-#endif
-		vid.fdupx = vid.fdupy = (vid.fdupx < vid.fdupy ? vid.fdupx : vid.fdupy);
+	vid.fdupx = vid.fdupy = (vid.fdupx < vid.fdupy ? vid.fdupx : vid.fdupy);
 
 	vid.meddupx = (UINT8)(vid.dupx >> 1) + 1;
 	vid.meddupy = (UINT8)(vid.dupy >> 1) + 1;
-#ifdef HWRENDER
-	vid.fmeddupx = vid.meddupx*FRACUNIT;
-	vid.fmeddupy = vid.meddupy*FRACUNIT;
-#endif
 
 	vid.smalldupx = (UINT8)(vid.dupx / 3) + 1;
 	vid.smalldupy = (UINT8)(vid.dupy / 3) + 1;
-#ifdef HWRENDER
-	vid.fsmalldupx = vid.smalldupx*FRACUNIT;
-	vid.fsmalldupy = vid.smalldupy*FRACUNIT;
-#endif
 }
-- 
GitLab


From 527b617eef36b202acfde5fd6937c3e70b8d6815 Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Wed, 26 Jul 2023 17:25:44 -0300
Subject: [PATCH 23/27] Move all remaining traces of video modes out of
 i_video.c

---
 src/android/i_video.c | 20 -------------------
 src/d_main.c          |  4 +---
 src/dummy/i_video.c   | 20 -------------------
 src/i_video.h         | 23 ----------------------
 src/m_menu.c          | 42 +++++++++++++++-------------------------
 src/m_menu.h          |  2 +-
 src/screen.c          | 29 ++++++++++++++++++++++++++--
 src/screen.h          | 15 +++++++++------
 src/sdl/i_video.c     | 45 +++----------------------------------------
 9 files changed, 57 insertions(+), 143 deletions(-)

diff --git a/src/android/i_video.c b/src/android/i_video.c
index bf0decb741..fff88fc2c4 100644
--- a/src/android/i_video.c
+++ b/src/android/i_video.c
@@ -29,23 +29,8 @@ void I_SetPalette(RGBA_t *palette)
   (void)palette;
 }
 
-INT32 VID_NumModes(void)
-{
-  return 1;
-}
-
-INT32 VID_GetModeForSize(INT32 w, INT32 h)
-{
-  (void)w;
-  (void)h;
-  return 0;
-}
-
-void VID_PrepareModeList(void){}
-
 INT32 VID_SetMode(INT32 modenum)
 {
-  vid.modenum = 0;
   vid.width = 320;
   vid.height = 240;
   vid.bpp = 1;
@@ -63,11 +48,6 @@ void VID_CheckGLLoaded(rendermode_t oldrender)
 	(void)oldrender;
 }
 
-const char *VID_GetModeName(INT32 modenum)
-{
-  return "A320x240";
-}
-
 void I_UpdateNoBlit(void){}
 
 void I_FinishUpdate(void) {
diff --git a/src/d_main.c b/src/d_main.c
index 488bb6917e..821c5f19b2 100644
--- a/src/d_main.c
+++ b/src/d_main.c
@@ -1480,9 +1480,7 @@ void D_SRB2Main(void)
 	G_LoadGameData(clientGamedata);
 	M_CopyGameData(serverGamedata, clientGamedata);
 
-#if defined (__unix__) || defined (UNIXCOMMON) || defined (HAVE_SDL)
-	VID_PrepareModeList(); // Regenerate Modelist according to cv_fullscreen
-#endif
+	allow_fullscreen = true;
 
 	// set user default mode or mode set at cmdline
 	SCR_CheckDefaultMode();
diff --git a/src/dummy/i_video.c b/src/dummy/i_video.c
index 3a1cbd2232..a0d1b64aa2 100644
--- a/src/dummy/i_video.c
+++ b/src/dummy/i_video.c
@@ -21,20 +21,6 @@ void I_SetPalette(RGBA_t *palette)
 	(void)palette;
 }
 
-INT32 VID_NumModes(void)
-{
-	return 0;
-}
-
-INT32 VID_GetModeForSize(INT32 w, INT32 h)
-{
-	(void)w;
-	(void)h;
-	return 0;
-}
-
-void VID_PrepareModeList(void){}
-
 void VID_SetSize(INT32 width, INT32 height)
 {
 	(void)width;
@@ -52,12 +38,6 @@ void VID_CheckGLLoaded(rendermode_t oldrender)
 	(void)oldrender;
 }
 
-const char *VID_GetModeName(INT32 modenum)
-{
-	(void)modenum;
-	return NULL;
-}
-
 void I_UpdateNoBlit(void){}
 
 void I_FinishUpdate(void){}
diff --git a/src/i_video.h b/src/i_video.h
index 258c919e81..13b18c5796 100644
--- a/src/i_video.h
+++ b/src/i_video.h
@@ -60,19 +60,6 @@ void I_ShutdownGraphics(void);
 */
 void I_SetPalette(RGBA_t *palette);
 
-/**	\brief return the number of video modes
-*/
-INT32 VID_NumModes(void);
-
-/**	\brief	The VID_GetModeForSize function
-
-	\param	w	width
-	\param	h	height
-
-	\return	vidmode closest to w : h
-*/
-INT32 VID_GetModeForSize(INT32 w, INT32 h);
-
 /**	\brief Changes the current resolution
 */
 void VID_SetSize(INT32 width, INT32 height);
@@ -90,16 +77,6 @@ void VID_StartupOpenGL(void);
 */
 void VID_CheckGLLoaded(rendermode_t oldrender);
 
-/**	\brief	The VID_GetModeName function
-
-	\param	modenum	video mode number
-
-	\return	name of video mode
-*/
-const char *VID_GetModeName(INT32 modenum);
-
-void VID_PrepareModeList(void); /// note hack for SDL
-
 /**	\brief Returns true if the window is maximized, and false if not
 */
 boolean VID_IsMaximized(void);
diff --git a/src/m_menu.c b/src/m_menu.c
index f69c8e3375..16bb24505f 100644
--- a/src/m_menu.c
+++ b/src/m_menu.c
@@ -13322,46 +13322,36 @@ static modedesc_t modedescs[MAXMODEDESCS];
 
 static void M_VideoModeMenu(INT32 choice)
 {
-	INT32 i;
-
 	(void)choice;
 
 	memset(modedescs, 0, sizeof(modedescs));
 
-#if defined (__unix__) || defined (UNIXCOMMON) || defined (HAVE_SDL)
-	VID_PrepareModeList(); // FIXME: hack
-#endif
-
 	vidm_nummodes = 0;
 	vidm_selected = 0;
 
-	INT32 nummodes = VID_NumModes();
-
-	for (i = 0; i < nummodes && vidm_nummodes < MAXMODEDESCS; i++)
+	for (INT32 i = 0; i < MAXWINMODES && vidm_nummodes < MAXMODEDESCS; i++)
 	{
-		const char *desc = VID_GetModeName(i);
-		if (desc)
-		{
-			// Pull out the width and height
-			INT32 width, height;
-			sscanf(desc, "%u%*c%u", &width, &height);
+		modedesc_t *desc = &modedescs[vidm_nummodes];
 
-			modedescs[vidm_nummodes].width = width;
-			modedescs[vidm_nummodes].height = height;
-			modedescs[vidm_nummodes].desc = desc;
+		INT32 width = windowedModes[i][0];
+		INT32 height = windowedModes[i][1];
 
-			if (width == vid.width && height == vid.height)
-				vidm_selected = vidm_nummodes;
+		desc->width = width;
+		desc->height = height;
 
-			// Show multiples of 320x200 as green.
-			if (SCR_IsAspectCorrect(width, height))
-				modedescs[vidm_nummodes].goodratio = 1;
+		snprintf(desc->desc, sizeof desc->desc, "%dx%d", width, height);
 
-			vidm_nummodes++;
-		}
+		if (width == vid.width && height == vid.height)
+			vidm_selected = vidm_nummodes;
+
+		// Show multiples of 320x200 as green.
+		if (SCR_IsAspectCorrect(width, height))
+			desc->goodratio = 1;
+
+		vidm_nummodes++;
 	}
 
-	vidm_column_size = (vidm_nummodes+2) / 3;
+	vidm_column_size = (vidm_nummodes + 2) / 3;
 
 	M_SetupNextMenu(&OP_VideoModeDef);
 }
diff --git a/src/m_menu.h b/src/m_menu.h
index ebb8dbde35..08f56b0f03 100644
--- a/src/m_menu.h
+++ b/src/m_menu.h
@@ -414,7 +414,7 @@ extern gtdesc_t gametypedesc[NUMGAMETYPES];
 typedef struct
 {
 	INT32 width, height;
-	const char *desc;  // XXXxYYY
+	char desc[12]; // XXXXXxYYYYY
 	UINT8 goodratio; // aspect correct if 1
 } modedesc_t;
 
diff --git a/src/screen.c b/src/screen.c
index e756f9442f..77d9f202f4 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -489,8 +489,6 @@ void SCR_ChangeFullscreen(void)
 
 	if (graphics_started)
 	{
-		VID_PrepareModeList();
-
 		INT32 width, height;
 
 		if (cv_fullscreen.value)
@@ -554,6 +552,33 @@ boolean SCR_IsAspectCorrect(INT32 width, INT32 height)
 	 );
 }
 
+const char *SCR_GetModeName(INT32 modeNum)
+{
+	static char vidModeName[MAXWINMODES][32];
+
+	if (modeNum == -1)
+		return "Fallback";
+	else if (modeNum > MAXWINMODES)
+		return NULL;
+
+	snprintf(&vidModeName[modeNum][0], 32, "%dx%d", windowedModes[modeNum][0], windowedModes[modeNum][1]);
+
+	return &vidModeName[modeNum][0];
+}
+
+INT32 SCR_GetModeForSize(INT32 w, INT32 h)
+{
+	int i;
+	for (i = 0; i < MAXWINMODES; i++)
+	{
+		if (windowedModes[i][0] == w && windowedModes[i][1] == h)
+		{
+			return i;
+		}
+	}
+	return -1;
+}
+
 double averageFPS = 0.0f;
 
 #define USE_FPS_SAMPLES
diff --git a/src/screen.h b/src/screen.h
index 0f9191deeb..eb3ad2ede1 100644
--- a/src/screen.h
+++ b/src/screen.h
@@ -72,16 +72,16 @@ typedef struct viddef_s
 
 enum
 {
-	VID_RESOLUTION_UNCHANGED = 0,
-	VID_RESOLUTION_CHANGED = 1,
-	VID_RESOLUTION_RESIZED_WINDOW = 2
+	VID_RESOLUTION_UNCHANGED,
+	VID_RESOLUTION_CHANGED,
+	VID_RESOLUTION_RESIZED_WINDOW
 };
 
 enum
 {
-	VID_GL_LIBRARY_NOTLOADED  = 0,
-	VID_GL_LIBRARY_LOADED     = 1,
-	VID_GL_LIBRARY_ERROR      = -1
+	VID_GL_LIBRARY_NOTLOADED,
+	VID_GL_LIBRARY_LOADED,
+	VID_GL_LIBRARY_ERROR
 };
 
 #define MAXWINMODES 18
@@ -171,6 +171,9 @@ void SCR_SetWindowSize(INT32 width, INT32 height);
 void SCR_SetSizeNoRestore(INT32 width, INT32 height);
 void SCR_ChangeRenderer(void);
 
+const char *SCR_GetModeName(INT32 modeNum);
+INT32 SCR_GetModeForSize(INT32 w, INT32 h);
+
 boolean SCR_IsValidResolution(INT32 width, INT32 height);
 
 extern CV_PossibleValue_t cv_renderer_t[];
diff --git a/src/sdl/i_video.c b/src/sdl/i_video.c
index fe099640a6..f4da81ef4c 100644
--- a/src/sdl/i_video.c
+++ b/src/sdl/i_video.c
@@ -101,8 +101,9 @@ static consvar_t cv_alwaysgrabmouse = CVAR_INIT ("alwaysgrabmouse", "Off", CV_SA
 
 UINT8 graphics_started = 0; // Is used in console.c and screen.c
 
-// To disable fullscreen at startup; is set in VID_PrepareModeList
+// To disable fullscreen at startup
 boolean allow_fullscreen = false;
+
 static SDL_bool disable_fullscreen = SDL_FALSE;
 
 #define USE_FULLSCREEN (disable_fullscreen||!allow_fullscreen)?0:cv_fullscreen.value
@@ -157,9 +158,6 @@ static void Impl_SetWindowIcon(void);
 static SDL_Surface *icoSurface = NULL;
 #endif
 
-static char vidModeName[MAXWINMODES][32];
-static const char *fallback_resolution_name = "Fallback";
-
 #define VIDEO_INIT_ERROR(str) { \
 	if (!graphics_started) \
 		I_Error(str, SDL_GetError()); \
@@ -598,7 +596,7 @@ void I_SetMouseGrab(boolean grab)
 
 static void VID_Command_NumModes_f (void)
 {
-	CONS_Printf(M_GetText("%d video mode(s) available(s)\n"), VID_NumModes());
+	CONS_Printf(M_GetText("%d video mode(s) available(s)\n"), MAXWINMODES);
 }
 
 // SDL2 doesn't have SDL_GetVideoSurface or a lot of the SDL_Surface flags that SDL 1.2 had
@@ -1395,43 +1393,6 @@ void I_SetPalette(RGBA_t *palette)
 	if (bufSurface) SDL_SetPaletteColors(bufSurface->format->palette, localPalette, 0, 256);
 }
 
-// return number of fullscreen + X11 modes
-INT32 VID_NumModes(void)
-{
-	return MAXWINMODES;
-}
-
-const char *VID_GetModeName(INT32 modeNum)
-{
-	if (modeNum == -1)
-		return fallback_resolution_name;
-	else if (modeNum > MAXWINMODES)
-		return NULL;
-
-	snprintf(&vidModeName[modeNum][0], 32, "%dx%d", windowedModes[modeNum][0], windowedModes[modeNum][1]);
-
-	return &vidModeName[modeNum][0];
-}
-
-INT32 VID_GetModeForSize(INT32 w, INT32 h)
-{
-	int i;
-	for (i = 0; i < MAXWINMODES; i++)
-	{
-		if (windowedModes[i][0] == w && windowedModes[i][1] == h)
-		{
-			return i;
-		}
-	}
-	return -1;
-}
-
-void VID_PrepareModeList(void)
-{
-	// Under SDL2, we just use the windowed modes list, and scale in windowed fullscreen.
-	allow_fullscreen = true;
-}
-
 void VID_CheckGLLoaded(rendermode_t oldrender)
 {
 	(void)oldrender;
-- 
GitLab


From e7b7bd8ddb2736aefad4f212c12b82bbe27787df Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Fri, 4 Aug 2023 15:36:11 -0300
Subject: [PATCH 24/27] Clean up SCR_SetDrawFuncs

---
 src/screen.c | 124 ++++++++++++++++++++-------------------------------
 1 file changed, 49 insertions(+), 75 deletions(-)

diff --git a/src/screen.c b/src/screen.c
index 732fd7f610..d862d1729c 100644
--- a/src/screen.c
+++ b/src/screen.c
@@ -125,81 +125,55 @@ boolean R_SSE2 = false;
 
 void SCR_SetDrawFuncs(void)
 {
-	//
-	//  setup the right draw routines for either 8bpp or 16bpp
-	//
-	if (true)//vid.bpp == 1) //Always run in 8bpp. todo: remove all 16bpp code?
-	{
-		colfuncs[BASEDRAWFUNC] = R_DrawColumn_8;
-		spanfuncs[BASEDRAWFUNC] = R_DrawSpan_8;
-
-		colfunc = colfuncs[BASEDRAWFUNC];
-		spanfunc = spanfuncs[BASEDRAWFUNC];
-
-		colfuncs[COLDRAWFUNC_FUZZY] = R_DrawTranslucentColumn_8;
-		colfuncs[COLDRAWFUNC_TRANS] = R_DrawTranslatedColumn_8;
-		colfuncs[COLDRAWFUNC_SHADE] = R_DrawShadeColumn_8;
-		colfuncs[COLDRAWFUNC_SHADOWED] = R_DrawColumnShadowed_8;
-		colfuncs[COLDRAWFUNC_TRANSTRANS] = R_DrawTranslatedTranslucentColumn_8;
-		colfuncs[COLDRAWFUNC_TWOSMULTIPATCH] = R_Draw2sMultiPatchColumn_8;
-		colfuncs[COLDRAWFUNC_TWOSMULTIPATCHTRANS] = R_Draw2sMultiPatchTranslucentColumn_8;
-		colfuncs[COLDRAWFUNC_FOG] = R_DrawFogColumn_8;
-
-		spanfuncs[SPANDRAWFUNC_TRANS] = R_DrawTranslucentSpan_8;
-		spanfuncs[SPANDRAWFUNC_TILTED] = R_DrawTiltedSpan_8;
-		spanfuncs[SPANDRAWFUNC_TILTEDTRANS] = R_DrawTiltedTranslucentSpan_8;
-		spanfuncs[SPANDRAWFUNC_SPLAT] = R_DrawSplat_8;
-		spanfuncs[SPANDRAWFUNC_TRANSSPLAT] = R_DrawTranslucentSplat_8;
-		spanfuncs[SPANDRAWFUNC_TILTEDSPLAT] = R_DrawTiltedSplat_8;
-		spanfuncs[SPANDRAWFUNC_SPRITE] = R_DrawFloorSprite_8;
-		spanfuncs[SPANDRAWFUNC_TRANSSPRITE] = R_DrawTranslucentFloorSprite_8;
-		spanfuncs[SPANDRAWFUNC_TILTEDSPRITE] = R_DrawTiltedFloorSprite_8;
-		spanfuncs[SPANDRAWFUNC_TILTEDTRANSSPRITE] = R_DrawTiltedTranslucentFloorSprite_8;
-		spanfuncs[SPANDRAWFUNC_WATER] = R_DrawWaterSpan_8;
-		spanfuncs[SPANDRAWFUNC_TILTEDWATER] = R_DrawTiltedWaterSpan_8;
-		spanfuncs[SPANDRAWFUNC_SOLID] = R_DrawSolidColorSpan_8;
-		spanfuncs[SPANDRAWFUNC_TRANSSOLID] = R_DrawTransSolidColorSpan_8;
-		spanfuncs[SPANDRAWFUNC_TILTEDSOLID] = R_DrawTiltedSolidColorSpan_8;
-		spanfuncs[SPANDRAWFUNC_TILTEDTRANSSOLID] = R_DrawTiltedTransSolidColorSpan_8;
-		spanfuncs[SPANDRAWFUNC_WATERSOLID] = R_DrawWaterSolidColorSpan_8;
-		spanfuncs[SPANDRAWFUNC_TILTEDWATERSOLID] = R_DrawTiltedWaterSolidColorSpan_8;
-		spanfuncs[SPANDRAWFUNC_FOG] = R_DrawFogSpan_8;
-		spanfuncs[SPANDRAWFUNC_TILTEDFOG] = R_DrawTiltedFogSpan_8;
-
-		// Lactozilla: Non-powers-of-two
-		spanfuncs_npo2[BASEDRAWFUNC] = R_DrawSpan_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_TRANS] = R_DrawTranslucentSpan_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_TILTED] = R_DrawTiltedSpan_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_TILTEDTRANS] = R_DrawTiltedTranslucentSpan_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_SPLAT] = R_DrawSplat_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_TRANSSPLAT] = R_DrawTranslucentSplat_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_TILTEDSPLAT] = R_DrawTiltedSplat_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_SPRITE] = R_DrawFloorSprite_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_TRANSSPRITE] = R_DrawTranslucentFloorSprite_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_TILTEDSPRITE] = R_DrawTiltedFloorSprite_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_TILTEDTRANSSPRITE] = R_DrawTiltedTranslucentFloorSprite_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_WATER] = R_DrawWaterSpan_NPO2_8;
-		spanfuncs_npo2[SPANDRAWFUNC_TILTEDWATER] = R_DrawTiltedWaterSpan_NPO2_8;
-
-	}
-/*	else if (vid.bpp > 1)
-	{
-		I_OutputMsg("using highcolor mode\n");
-		spanfunc = basespanfunc = R_DrawSpan_16;
-		transcolfunc = R_DrawTranslatedColumn_16;
-		transtransfunc = R_DrawTranslucentColumn_16; // No 16bit operation for this function
-
-		colfunc = basecolfunc = R_DrawColumn_16;
-		shadecolfunc = NULL; // detect error if used somewhere..
-		fuzzcolfunc = R_DrawTranslucentColumn_16;
-		walldrawerfunc = R_DrawWallColumn_16;
-	}*/
-	else
-		I_Error("unknown bytes per pixel mode %d\n", vid.bpp);
-/*
-	if (SCR_IsAspectCorrect(vid.width, vid.height))
-		CONS_Alert(CONS_WARNING, M_GetText("Resolution is not aspect-correct!\nUse a multiple of %dx%d\n"), BASEVIDWIDTH, BASEVIDHEIGHT);
-*/
+	colfuncs[BASEDRAWFUNC] = R_DrawColumn_8;
+	spanfuncs[BASEDRAWFUNC] = R_DrawSpan_8;
+
+	colfunc = colfuncs[BASEDRAWFUNC];
+	spanfunc = spanfuncs[BASEDRAWFUNC];
+
+	colfuncs[COLDRAWFUNC_FUZZY] = R_DrawTranslucentColumn_8;
+	colfuncs[COLDRAWFUNC_TRANS] = R_DrawTranslatedColumn_8;
+	colfuncs[COLDRAWFUNC_SHADE] = R_DrawShadeColumn_8;
+	colfuncs[COLDRAWFUNC_SHADOWED] = R_DrawColumnShadowed_8;
+	colfuncs[COLDRAWFUNC_TRANSTRANS] = R_DrawTranslatedTranslucentColumn_8;
+	colfuncs[COLDRAWFUNC_TWOSMULTIPATCH] = R_Draw2sMultiPatchColumn_8;
+	colfuncs[COLDRAWFUNC_TWOSMULTIPATCHTRANS] = R_Draw2sMultiPatchTranslucentColumn_8;
+	colfuncs[COLDRAWFUNC_FOG] = R_DrawFogColumn_8;
+
+	spanfuncs[SPANDRAWFUNC_TRANS] = R_DrawTranslucentSpan_8;
+	spanfuncs[SPANDRAWFUNC_TILTED] = R_DrawTiltedSpan_8;
+	spanfuncs[SPANDRAWFUNC_TILTEDTRANS] = R_DrawTiltedTranslucentSpan_8;
+	spanfuncs[SPANDRAWFUNC_SPLAT] = R_DrawSplat_8;
+	spanfuncs[SPANDRAWFUNC_TRANSSPLAT] = R_DrawTranslucentSplat_8;
+	spanfuncs[SPANDRAWFUNC_TILTEDSPLAT] = R_DrawTiltedSplat_8;
+	spanfuncs[SPANDRAWFUNC_SPRITE] = R_DrawFloorSprite_8;
+	spanfuncs[SPANDRAWFUNC_TRANSSPRITE] = R_DrawTranslucentFloorSprite_8;
+	spanfuncs[SPANDRAWFUNC_TILTEDSPRITE] = R_DrawTiltedFloorSprite_8;
+	spanfuncs[SPANDRAWFUNC_TILTEDTRANSSPRITE] = R_DrawTiltedTranslucentFloorSprite_8;
+	spanfuncs[SPANDRAWFUNC_WATER] = R_DrawWaterSpan_8;
+	spanfuncs[SPANDRAWFUNC_TILTEDWATER] = R_DrawTiltedWaterSpan_8;
+	spanfuncs[SPANDRAWFUNC_SOLID] = R_DrawSolidColorSpan_8;
+	spanfuncs[SPANDRAWFUNC_TRANSSOLID] = R_DrawTransSolidColorSpan_8;
+	spanfuncs[SPANDRAWFUNC_TILTEDSOLID] = R_DrawTiltedSolidColorSpan_8;
+	spanfuncs[SPANDRAWFUNC_TILTEDTRANSSOLID] = R_DrawTiltedTransSolidColorSpan_8;
+	spanfuncs[SPANDRAWFUNC_WATERSOLID] = R_DrawWaterSolidColorSpan_8;
+	spanfuncs[SPANDRAWFUNC_TILTEDWATERSOLID] = R_DrawTiltedWaterSolidColorSpan_8;
+	spanfuncs[SPANDRAWFUNC_FOG] = R_DrawFogSpan_8;
+	spanfuncs[SPANDRAWFUNC_TILTEDFOG] = R_DrawTiltedFogSpan_8;
+
+	spanfuncs_npo2[BASEDRAWFUNC] = R_DrawSpan_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_TRANS] = R_DrawTranslucentSpan_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_TILTED] = R_DrawTiltedSpan_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_TILTEDTRANS] = R_DrawTiltedTranslucentSpan_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_SPLAT] = R_DrawSplat_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_TRANSSPLAT] = R_DrawTranslucentSplat_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_TILTEDSPLAT] = R_DrawTiltedSplat_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_SPRITE] = R_DrawFloorSprite_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_TRANSSPRITE] = R_DrawTranslucentFloorSprite_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_TILTEDSPRITE] = R_DrawTiltedFloorSprite_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_TILTEDTRANSSPRITE] = R_DrawTiltedTranslucentFloorSprite_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_WATER] = R_DrawWaterSpan_NPO2_8;
+	spanfuncs_npo2[SPANDRAWFUNC_TILTEDWATER] = R_DrawTiltedWaterSpan_NPO2_8;
 }
 
 void SCR_SetMode(void)
-- 
GitLab


From 41cb145be94137ea96afa7cc50b121d799820f1c Mon Sep 17 00:00:00 2001
From: Lactozilla <jp6781615@gmail.com>
Date: Fri, 4 Aug 2023 15:44:46 -0300
Subject: [PATCH 25/27] Delete ylookup and columnofs

---
 src/d_main.c       |  2 --
 src/r_draw.c       | 71 ++++++++----------------------------
 src/r_draw.h       |  5 ---
 src/r_draw8.c      | 89 ++++++++++++++--------------------------------
 src/r_draw8_npo2.c | 30 +++++++---------
 src/r_things.c     | 19 ++--------
 6 files changed, 58 insertions(+), 158 deletions(-)

diff --git a/src/d_main.c b/src/d_main.c
index dfc1dfb635..c22a02c91d 100644
--- a/src/d_main.c
+++ b/src/d_main.c
@@ -506,14 +506,12 @@ static void D_Display(void)
 					if (rendermode != render_none)
 					{
 						viewwindowy = vid.height / 2;
-						ylookup = ylookup2;
 
 						topleft = screens[0] + viewwindowy*vid.width + viewwindowx;
 
 						R_RenderPlayerView(&players[secondarydisplayplayer]);
 
 						viewwindowy = 0;
-						ylookup = ylookup1;
 					}
 				}
 
diff --git a/src/r_draw.c b/src/r_draw.c
index 16ab767610..f60e4b6453 100644
--- a/src/r_draw.c
+++ b/src/r_draw.c
@@ -40,23 +40,6 @@
 */
 INT32 viewwidth, viewheight, viewwindowx, viewwindowy;
 
-/**	\brief pointer to the start of each line of the screen,
-*/
-UINT8 **ylookup;
-
-/**	\brief pointer to the start of each line of the screen, for view1 (splitscreen)
-*/
-UINT8 **ylookup1;
-
-/**	\brief pointer to the start of each line of the screen, for view2 (splitscreen)
-*/
-UINT8 **ylookup2;
-
-/**	\brief  x byte offset for columns inside the viewwindow,
-	so the first column starts at (SCRWIDTH - VIEWWIDTH)/2
-*/
-INT32 *columnofs;
-
 UINT8 *topleft;
 
 // =========================================================================
@@ -67,8 +50,6 @@ lighttable_t *dc_colormap;
 INT32 dc_x = 0, dc_yl = 0, dc_yh = 0;
 
 fixed_t dc_iscale, dc_texturemid;
-UINT8 dc_hires; // under MSVC boolean is a byte, while on other systems, it a bit,
-               // soo lets make it a byte on all system for the ASM code
 UINT8 *dc_source;
 
 // -----------------------
@@ -669,16 +650,6 @@ UINT16 R_GetSuperColorByName(const char *name)
 	return color;
 }
 
-// ==========================================================================
-//               COMMON DRAWER FOR 8 AND 16 BIT COLOR MODES
-// ==========================================================================
-
-// in a perfect world, all routines would be compatible for either mode,
-// and optimised enough
-//
-// in reality, the few routines that can work for either mode, are
-// put here
-
 /**	\brief	The R_InitViewBuffer function
 
 	Creates lookup tables for getting the framebuffer address
@@ -692,17 +663,8 @@ UINT16 R_GetSuperColorByName(const char *name)
 
 */
 
-void R_InitViewBuffer(INT32 width, INT32 height)
+static void R_AllocViewMemory(void)
 {
-	INT32 i, bytesperpixel = vid.bpp;
-
-	if (width > MAXVIDWIDTH)
-		width = MAXVIDWIDTH;
-	if (height > MAXVIDHEIGHT)
-		height = MAXVIDHEIGHT;
-	if (bytesperpixel < 1 || bytesperpixel > 4)
-		I_Error("R_InitViewBuffer: wrong bytesperpixel value %d\n", bytesperpixel);
-
 	negonearray = Z_Realloc(negonearray, sizeof(*negonearray) * viewwidth, PU_STATIC, NULL);
 	screenheightarray = Z_Realloc(screenheightarray, sizeof(*screenheightarray) * viewwidth, PU_STATIC, NULL);
 
@@ -711,12 +673,6 @@ void R_InitViewBuffer(INT32 width, INT32 height)
 
 	frontscale = Z_Realloc(frontscale, sizeof(*frontscale) * viewwidth, PU_STATIC, NULL);
 
-	ylookup1 = Z_Realloc(ylookup1, sizeof(*ylookup1) * (viewheight * 4), PU_STATIC, NULL);
-	ylookup2 = Z_Realloc(ylookup2, sizeof(*ylookup2) * (viewheight * 4), PU_STATIC, NULL);
-	ylookup = ylookup1;
-
-	columnofs = Z_Realloc(columnofs, sizeof(*columnofs) * (viewwidth * 4), PU_STATIC, NULL);
-
 	xtoviewangle = Z_Realloc(xtoviewangle, sizeof(*xtoviewangle) * (viewwidth + 1), PU_STATIC, NULL);
 
 	tiltlighting = Z_Realloc(tiltlighting, sizeof(*tiltlighting) * viewwidth, PU_STATIC, NULL);
@@ -726,26 +682,29 @@ void R_InitViewBuffer(INT32 width, INT32 height)
 	R_AllocPlaneMemory();
 	R_AllocFloorSpriteTables();
 	R_AllocVisSpriteMemory();
+}
+
+void R_InitViewBuffer(INT32 width, INT32 height)
+{
+	INT32 bytesperpixel = vid.bpp;
+
+	if (width > MAXVIDWIDTH)
+		width = MAXVIDWIDTH;
+	if (height > MAXVIDHEIGHT)
+		height = MAXVIDHEIGHT;
+	if (bytesperpixel < 1 || bytesperpixel > 4)
+		I_Error("R_InitViewBuffer: wrong bytesperpixel value %d\n", bytesperpixel);
+
+	R_AllocViewMemory();
 
 	// Handle resize, e.g. smaller view windows with border and/or status bar.
 	viewwindowx = (vid.width - width) >> 1;
 
-	// Column offset for those columns of the view window, but relative to the entire screen
-	for (i = 0; i < width; i++)
-		columnofs[i] = (viewwindowx + i) * bytesperpixel;
-
 	// Same with base row offset.
 	if (width == vid.width)
 		viewwindowy = 0;
 	else
 		viewwindowy = (vid.height - height) >> 1;
-
-	// Precalculate all row offsets.
-	for (i = 0; i < height; i++)
-	{
-		ylookup1[i] = screens[0] + (i+viewwindowy)*vid.width*bytesperpixel;
-		ylookup2[i] = screens[0] + (i+(vid.height>>1))*vid.width*bytesperpixel; // for splitscreen
-	}
 }
 
 /**	\brief	The R_VideoErase function
diff --git a/src/r_draw.h b/src/r_draw.h
index 4c92875512..55cdf254df 100644
--- a/src/r_draw.h
+++ b/src/r_draw.h
@@ -19,10 +19,6 @@
 // -------------------------------
 // COMMON STUFF FOR 8bpp AND 16bpp
 // -------------------------------
-extern UINT8 **ylookup;
-extern UINT8 **ylookup1;
-extern UINT8 **ylookup2;
-extern INT32 *columnofs;
 extern UINT8 *topleft;
 
 // -------------------------
@@ -32,7 +28,6 @@ extern UINT8 *topleft;
 extern lighttable_t *dc_colormap;
 extern INT32 dc_x, dc_yl, dc_yh;
 extern fixed_t dc_iscale, dc_texturemid;
-extern UINT8 dc_hires;
 
 extern UINT8 *dc_source; // first pixel in a column
 
diff --git a/src/r_draw8.c b/src/r_draw8.c
index b80a47984f..f3f3b04c7b 100644
--- a/src/r_draw8.c
+++ b/src/r_draw8.c
@@ -40,18 +40,13 @@ void R_DrawColumn_8(void)
 #endif
 
 	// Framebuffer destination address.
-	// Use ylookup LUT to avoid multiply with ScreenWidth.
-	// Use columnofs LUT for subwindows?
-
-	//dest = ylookup[dc_yl] + columnofs[dc_x];
 	dest = &topleft[dc_yl*vid.width + dc_x];
 
 	count++;
 
 	// Determine scaling, which is the only mapping to be done.
 	fracstep = dc_iscale;
-	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
-	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);
+	frac = dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep);
 
 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
 	// This is as fast as it gets.
@@ -123,18 +118,13 @@ void R_Draw2sMultiPatchColumn_8(void)
 #endif
 
 	// Framebuffer destination address.
-	// Use ylookup LUT to avoid multiply with ScreenWidth.
-	// Use columnofs LUT for subwindows?
-
-	//dest = ylookup[dc_yl] + columnofs[dc_x];
 	dest = &topleft[dc_yl*vid.width + dc_x];
 
 	count++;
 
 	// Determine scaling, which is the only mapping to be done.
 	fracstep = dc_iscale;
-	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
-	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);
+	frac = dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep);
 
 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
 	// This is as fast as it gets.
@@ -219,18 +209,13 @@ void R_Draw2sMultiPatchTranslucentColumn_8(void)
 #endif
 
 	// Framebuffer destination address.
-	// Use ylookup LUT to avoid multiply with ScreenWidth.
-	// Use columnofs LUT for subwindows?
-
-	//dest = ylookup[dc_yl] + columnofs[dc_x];
 	dest = &topleft[dc_yl*vid.width + dc_x];
 
 	count++;
 
 	// Determine scaling, which is the only mapping to be done.
 	fracstep = dc_iscale;
-	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
-	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);
+	frac = dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep);
 
 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
 	// This is as fast as it gets.
@@ -320,14 +305,11 @@ void R_DrawShadeColumn_8(void)
 		I_Error("R_DrawShadeColumn_8: %d to %d at %d", dc_yl, dc_yh, dc_x);
 #endif
 
-	// FIXME. As above.
-	//dest = ylookup[dc_yl] + columnofs[dc_x];
 	dest = &topleft[dc_yl*vid.width + dc_x];
 
 	// Looks familiar.
 	fracstep = dc_iscale;
-	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
-	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);
+	frac = dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep);
 
 	// Here we do an additional index re-mapping.
 	do
@@ -359,14 +341,11 @@ void R_DrawTranslucentColumn_8(void)
 		I_Error("R_DrawTranslucentColumn_8: %d to %d at %d", dc_yl, dc_yh, dc_x);
 #endif
 
-	// FIXME. As above.
-	//dest = ylookup[dc_yl] + columnofs[dc_x];
 	dest = &topleft[dc_yl*vid.width + dc_x];
 
 	// Looks familiar.
 	fracstep = dc_iscale;
-	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
-	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);
+	frac = dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep);
 
 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
 	// This is as fast as it gets.
@@ -464,14 +443,11 @@ void R_DrawTranslatedTranslucentColumn_8(void)
 	if (count <= 0) // Zero length, column does not exceed a pixel.
 		return;
 
-	// FIXME. As above.
-	//dest = ylookup[dc_yl] + columnofs[dc_x];
 	dest = &topleft[dc_yl*vid.width + dc_x];
 
 	// Looks familiar.
 	fracstep = dc_iscale;
-	//frac = dc_texturemid + (dc_yl - centery)*fracstep;
-	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);
+	frac = dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep);
 
 	// Inner loop that does the actual texture mapping, e.g. a DDA-like scaling.
 	// This is as fast as it gets.
@@ -540,14 +516,11 @@ void R_DrawTranslatedColumn_8(void)
 		I_Error("R_DrawTranslatedColumn_8: %d to %d at %d", dc_yl, dc_yh, dc_x);
 #endif
 
-	// FIXME. As above.
-	//dest = ylookup[dc_yl] + columnofs[dc_x];
 	dest = &topleft[dc_yl*vid.width + dc_x];
 
 	// Looks familiar.
 	fracstep = dc_iscale;
-	//frac = dc_texturemid + (dc_yl-centery)*fracstep;
-	frac = (dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep))*(!dc_hires);
+	frac = dc_texturemid + FixedMul((dc_yl << FRACBITS) - centeryfrac, fracstep);
 
 	// Here we do an additional index re-mapping.
 	do
@@ -603,7 +576,7 @@ void R_DrawSpan_8 (void)
 
 	source = ds_source;
 	colormap = ds_colormap;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	if (dest+8 > deststop)
 		return;
@@ -683,9 +656,8 @@ void R_DrawTiltedSpan_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	source = ds_source;
-	//colormap = ds_colormap;
 
 #if 0	// The "perfect" reference version of this routine. Pretty slow.
 		// Use it only to see how things are supposed to look.
@@ -806,9 +778,8 @@ void R_DrawTiltedTranslucentSpan_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	source = ds_source;
-	//colormap = ds_colormap;
 
 #if 0	// The "perfect" reference version of this routine. Pretty slow.
 		// Use it only to see how things are supposed to look.
@@ -929,10 +900,9 @@ void R_DrawTiltedWaterSpan_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	dsrc = screens[1] + (ds_y+ds_bgofs)*vid.width + ds_x1;
 	source = ds_source;
-	//colormap = ds_colormap;
 
 #if 0	// The "perfect" reference version of this routine. Pretty slow.
 		// Use it only to see how things are supposed to look.
@@ -1051,9 +1021,8 @@ void R_DrawTiltedSplat_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	source = ds_source;
-	//colormap = ds_colormap;
 
 #if 0	// The "perfect" reference version of this routine. Pretty slow.
 		// Use it only to see how things are supposed to look.
@@ -1188,7 +1157,7 @@ void R_DrawSplat_8 (void)
 
 	source = ds_source;
 	colormap = ds_colormap;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	while (count >= 8)
 	{
@@ -1308,7 +1277,7 @@ void R_DrawTranslucentSplat_8 (void)
 
 	source = ds_source;
 	colormap = ds_colormap;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	while (count >= 8)
 	{
@@ -1411,7 +1380,7 @@ void R_DrawFloorSprite_8 (void)
 	source = (UINT16 *)ds_source;
 	colormap = ds_colormap;
 	translation = ds_translation;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	while (count >= 8)
 	{
@@ -1522,7 +1491,7 @@ void R_DrawTranslucentFloorSprite_8 (void)
 	source = (UINT16 *)ds_source;
 	colormap = ds_colormap;
 	translation = ds_translation;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	while (count >= 8)
 	{
@@ -1617,7 +1586,7 @@ void R_DrawTiltedFloorSprite_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	source = (UINT16 *)ds_source;
 	colormap = ds_colormap;
 	translation = ds_translation;
@@ -1726,7 +1695,7 @@ void R_DrawTiltedTranslucentFloorSprite_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	source = (UINT16 *)ds_source;
 	colormap = ds_colormap;
 	translation = ds_translation;
@@ -1841,7 +1810,7 @@ void R_DrawTranslucentSpan_8 (void)
 
 	source = ds_source;
 	colormap = ds_colormap;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	while (count >= 8)
 	{
@@ -1918,7 +1887,7 @@ void R_DrawWaterSpan_8(void)
 
 	source = ds_source;
 	colormap = ds_colormap;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	dsrc = screens[1] + (ds_y+ds_bgofs)*vid.width + ds_x1;
 	count = ds_x2 - ds_x1 + 1;
 
@@ -1981,7 +1950,6 @@ void R_DrawFogSpan_8(void)
 	size_t count;
 
 	colormap = ds_colormap;
-	//dest = ylookup[ds_y] + columnofs[ds_x1];
 	dest = &topleft[ds_y *vid.width + ds_x1];
 
 	count = ds_x2 - ds_x1 + 1;
@@ -2011,7 +1979,7 @@ void R_DrawTiltedFogSpan_8(void)
 {
 	int width = ds_x2 - ds_x1;
 
-	UINT8 *dest = ylookup[ds_y] + columnofs[ds_x1];
+	UINT8 *dest = &topleft[ds_y*vid.width + ds_x1];
 
 	double iz = ds_szp->z + ds_szp->y*(centery-ds_y) + ds_szp->x*(ds_x1-centerx);
 
@@ -2033,7 +2001,7 @@ void R_DrawSolidColorSpan_8(void)
 	size_t count = (ds_x2 - ds_x1 + 1);
 
 	UINT8 source = ds_colormap[ds_source[0]];
-	UINT8 *dest = ylookup[ds_y] + columnofs[ds_x1];
+	UINT8 *dest = &topleft[ds_y*vid.width + ds_x1];
 
 	memset(dest, source, count);
 }
@@ -2046,7 +2014,7 @@ void R_DrawTransSolidColorSpan_8(void)
 	size_t count = (ds_x2 - ds_x1 + 1);
 
 	UINT8 source = ds_colormap[ds_source[0]];
-	UINT8 *dest = ylookup[ds_y] + columnofs[ds_x1];
+	UINT8 *dest = &topleft[ds_y*vid.width + ds_x1];
 
 	const UINT8 *deststop = screens[0] + vid.rowbytes * vid.height;
 
@@ -2065,7 +2033,7 @@ void R_DrawTiltedSolidColorSpan_8(void)
 	int width = ds_x2 - ds_x1;
 
 	UINT8 source = ds_source[0];
-	UINT8 *dest = ylookup[ds_y] + columnofs[ds_x1];
+	UINT8 *dest = &topleft[ds_y*vid.width + ds_x1];
 
 	double iz = ds_szp->z + ds_szp->y*(centery-ds_y) + ds_szp->x*(ds_x1-centerx);
 
@@ -2086,7 +2054,7 @@ void R_DrawTiltedTransSolidColorSpan_8(void)
 	int width = ds_x2 - ds_x1;
 
 	UINT8 source = ds_source[0];
-	UINT8 *dest = ylookup[ds_y] + columnofs[ds_x1];
+	UINT8 *dest = &topleft[ds_y*vid.width + ds_x1];
 
 	double iz = ds_szp->z + ds_szp->y*(centery-ds_y) + ds_szp->x*(ds_x1-centerx);
 
@@ -2107,7 +2075,7 @@ void R_DrawWaterSolidColorSpan_8(void)
 {
 	UINT8 source = ds_source[0];
 	UINT8 *colormap = ds_colormap;
-	UINT8 *dest = ylookup[ds_y] + columnofs[ds_x1];
+	UINT8 *dest = &topleft[ds_y*vid.width + ds_x1];
 	UINT8 *dsrc = screens[1] + (ds_y+ds_bgofs)*vid.width + ds_x1;
 
 	size_t count = (ds_x2 - ds_x1 + 1);
@@ -2128,7 +2096,7 @@ void R_DrawTiltedWaterSolidColorSpan_8(void)
 	int width = ds_x2 - ds_x1;
 
 	UINT8 source = ds_source[0];
-	UINT8 *dest = ylookup[ds_y] + columnofs[ds_x1];
+	UINT8 *dest = &topleft[ds_y*vid.width + ds_x1];
 	UINT8 *dsrc = screens[1] + (ds_y+ds_bgofs)*vid.width + ds_x1;
 
 	double iz = ds_szp->z + ds_szp->y*(centery-ds_y) + ds_szp->x*(ds_x1-centerx);
@@ -2162,9 +2130,6 @@ void R_DrawFogColumn_8(void)
 #endif
 
 	// Framebuffer destination address.
-	// Use ylookup LUT to avoid multiply with ScreenWidth.
-	// Use columnofs LUT for subwindows?
-	//dest = ylookup[dc_yl] + columnofs[dc_x];
 	dest = &topleft[dc_yl*vid.width + dc_x];
 
 	// Determine scaling, which is the only mapping to be done.
diff --git a/src/r_draw8_npo2.c b/src/r_draw8_npo2.c
index 91f3b06c42..b963258712 100644
--- a/src/r_draw8_npo2.c
+++ b/src/r_draw8_npo2.c
@@ -46,7 +46,7 @@ void R_DrawSpan_NPO2_8 (void)
 
 	source = ds_source;
 	colormap = ds_colormap;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	if (dest+8 > deststop)
 		return;
@@ -121,9 +121,8 @@ void R_DrawTiltedSpan_NPO2_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	source = ds_source;
-	//colormap = ds_colormap;
 
 #if 0	// The "perfect" reference version of this routine. Pretty slow.
 		// Use it only to see how things are supposed to look.
@@ -311,9 +310,8 @@ void R_DrawTiltedTranslucentSpan_NPO2_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	source = ds_source;
-	//colormap = ds_colormap;
 
 #if 0	// The "perfect" reference version of this routine. Pretty slow.
 		// Use it only to see how things are supposed to look.
@@ -499,9 +497,8 @@ void R_DrawTiltedSplat_NPO2_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	source = ds_source;
-	//colormap = ds_colormap;
 
 #if 0	// The "perfect" reference version of this routine. Pretty slow.
 		// Use it only to see how things are supposed to look.
@@ -693,7 +690,7 @@ void R_DrawSplat_NPO2_8 (void)
 
 	source = ds_source;
 	colormap = ds_colormap;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	fixedwidth = ds_flatwidth << FRACBITS;
 	fixedheight = ds_flatheight << FRACBITS;
@@ -761,7 +758,7 @@ void R_DrawTranslucentSplat_NPO2_8 (void)
 
 	source = ds_source;
 	colormap = ds_colormap;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	fixedwidth = ds_flatwidth << FRACBITS;
 	fixedheight = ds_flatheight << FRACBITS;
@@ -831,7 +828,7 @@ void R_DrawFloorSprite_NPO2_8 (void)
 	source = (UINT16 *)ds_source;
 	colormap = ds_colormap;
 	translation = ds_translation;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	fixedwidth = ds_flatwidth << FRACBITS;
 	fixedheight = ds_flatheight << FRACBITS;
@@ -901,7 +898,7 @@ void R_DrawTranslucentFloorSprite_NPO2_8 (void)
 	source = (UINT16 *)ds_source;
 	colormap = ds_colormap;
 	translation = ds_translation;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	fixedwidth = ds_flatwidth << FRACBITS;
 	fixedheight = ds_flatheight << FRACBITS;
@@ -974,7 +971,7 @@ void R_DrawTiltedFloorSprite_NPO2_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	source = (UINT16 *)ds_source;
 	colormap = ds_colormap;
 	translation = ds_translation;
@@ -1130,7 +1127,7 @@ void R_DrawTiltedTranslucentFloorSprite_NPO2_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	source = (UINT16 *)ds_source;
 	colormap = ds_colormap;
 	translation = ds_translation;
@@ -1281,7 +1278,7 @@ void R_DrawTranslucentSpan_NPO2_8 (void)
 
 	source = ds_source;
 	colormap = ds_colormap;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 
 	fixedwidth = ds_flatwidth << FRACBITS;
 	fixedheight = ds_flatheight << FRACBITS;
@@ -1345,7 +1342,7 @@ void R_DrawWaterSpan_NPO2_8(void)
 
 	source = ds_source;
 	colormap = ds_colormap;
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	dsrc = screens[1] + (ds_y+ds_bgofs)*vid.width + ds_x1;
 
 	fixedwidth = ds_flatwidth << FRACBITS;
@@ -1418,10 +1415,9 @@ void R_DrawTiltedWaterSpan_NPO2_8(void)
 	uz = ds_sup->z + ds_sup->y*(centery-ds_y) + ds_sup->x*(ds_x1-centerx);
 	vz = ds_svp->z + ds_svp->y*(centery-ds_y) + ds_svp->x*(ds_x1-centerx);
 
-	dest = ylookup[ds_y] + columnofs[ds_x1];
+	dest = &topleft[ds_y*vid.width + ds_x1];
 	dsrc = screens[1] + (ds_y+ds_bgofs)*vid.width + ds_x1;
 	source = ds_source;
-	//colormap = ds_colormap;
 
 #if 0	// The "perfect" reference version of this routine. Pretty slow.
 		// Use it only to see how things are supposed to look.
diff --git a/src/r_things.c b/src/r_things.c
index 12cdb64b7b..ceadcf35d9 100644
--- a/src/r_things.c
+++ b/src/r_things.c
@@ -711,15 +711,7 @@ void R_DrawMaskedColumn(column_t *column)
 			dc_texturemid = basetexturemid - (topdelta<<FRACBITS);
 
 			// Drawn by R_DrawColumn.
-			// This stuff is a likely cause of the splitscreen water crash bug.
-			// FIXTHIS: Figure out what "something more proper" is and do it.
-			// quick fix... something more proper should be done!!!
-			if (ylookup[dc_yl])
-				colfunc();
-#ifdef PARANOIA
-			else
-				I_Error("R_DrawMaskedColumn: Invalid ylookup for dc_yl %d", dc_yl);
-#endif
+			colfunc();
 		}
 		column = (column_t *)((UINT8 *)column + column->length + 4);
 	}
@@ -778,12 +770,8 @@ void R_DrawFlippedMaskedColumn(column_t *column)
 			dc_texturemid = basetexturemid - (topdelta<<FRACBITS);
 
 			// Still drawn by R_DrawColumn.
-			if (ylookup[dc_yl])
-				colfunc();
-#ifdef PARANOIA
-			else
-				I_Error("R_DrawMaskedColumn: Invalid ylookup for dc_yl %d", dc_yl);
-#endif
+			colfunc();
+
 			Z_Free(dc_source);
 		}
 		column = (column_t *)((UINT8 *)column + column->length + 4);
@@ -1027,7 +1015,6 @@ static void R_DrawVisSprite(vissprite_t *vis)
 	}
 
 	colfunc = colfuncs[BASEDRAWFUNC];
-	dc_hires = 0;
 
 	vis->x1 = x1;
 	vis->x2 = x2;
-- 
GitLab


From d3ec50ef540ebf0c85ab10416f2069fdd52fd088 Mon Sep 17 00:00:00 2001
From: Zwip-Zwap Zapony <ZwipZwapZapony@gmail.com>
Date: Tue, 8 Aug 2023 12:31:27 +0200
Subject: [PATCH 26/27] Fix OpenGL screen texture resolution

---
 src/hardware/r_opengl/r_opengl.c | 63 ++++----------------------------
 1 file changed, 8 insertions(+), 55 deletions(-)

diff --git a/src/hardware/r_opengl/r_opengl.c b/src/hardware/r_opengl/r_opengl.c
index 71cb5ca703..0eb4b5abf4 100644
--- a/src/hardware/r_opengl/r_opengl.c
+++ b/src/hardware/r_opengl/r_opengl.c
@@ -67,8 +67,9 @@ static RGBA_t *textureBuffer = NULL;
 static size_t textureBufferSize = 0;
 
 RGBA_t  myPaletteData[256];
-GLint   screen_width    = 0;               // used by Draw2DLine()
+GLint   screen_width    = 0; // used by Draw2DLine()
 GLint   screen_height   = 0;
+GLint   texsize         = 512; // Power-of-two screen texture render resolution
 GLbyte  screen_depth    = 0;
 GLint   textureformatGL = 0;
 GLint maximumAnisotropy = 0;
@@ -1207,6 +1208,12 @@ void SetModelView(GLint w, GLint h)
 
 	screen_width = w;
 	screen_height = h;
+	texsize = 512;
+	// Use a power of two texture, dammit
+	while (texsize < screen_width || texsize < screen_height)
+	{
+		texsize *= 2;
+	}
 
 	pglViewport(0, 0, w, h);
 
@@ -3064,7 +3071,6 @@ EXPORT void HWRAPI(PostImgRedraw) (float points[SCREENVERTS][SCREENVERTS][2])
 	INT32 x, y;
 	float float_x, float_y, float_nextx, float_nexty;
 	float xfix, yfix;
-	INT32 texsize = 2048;
 
 	const float blackBack[16] =
 	{
@@ -3074,12 +3080,6 @@ EXPORT void HWRAPI(PostImgRedraw) (float points[SCREENVERTS][SCREENVERTS][2])
 		16.0f, -16.0f, 6.0f
 	};
 
-	// Use a power of two texture, dammit
-	if(screen_width <= 1024)
-		texsize = 1024;
-	if(screen_width <= 512)
-		texsize = 512;
-
 	// X/Y stretch fix for all resolutions(!)
 	xfix = (float)(texsize)/((float)((screen_width)/(float)(SCREENVERTS-1)));
 	yfix = (float)(texsize)/((float)((screen_height)/(float)(SCREENVERTS-1)));
@@ -3165,15 +3165,8 @@ EXPORT void HWRAPI(FlushScreenTextures) (void)
 // Create Screen to fade from
 EXPORT void HWRAPI(StartScreenWipe) (void)
 {
-	INT32 texsize = 2048;
 	boolean firstTime = (startScreenWipe == 0);
 
-	// Use a power of two texture, dammit
-	if(screen_width <= 512)
-		texsize = 512;
-	else if(screen_width <= 1024)
-		texsize = 1024;
-
 	// Create screen texture
 	if (firstTime)
 		pglGenTextures(1, &startScreenWipe);
@@ -3196,15 +3189,8 @@ EXPORT void HWRAPI(StartScreenWipe) (void)
 // Create Screen to fade to
 EXPORT void HWRAPI(EndScreenWipe)(void)
 {
-	INT32 texsize = 2048;
 	boolean firstTime = (endScreenWipe == 0);
 
-	// Use a power of two texture, dammit
-	if(screen_width <= 512)
-		texsize = 512;
-	else if(screen_width <= 1024)
-		texsize = 1024;
-
 	// Create screen texture
 	if (firstTime)
 		pglGenTextures(1, &endScreenWipe);
@@ -3229,7 +3215,6 @@ EXPORT void HWRAPI(EndScreenWipe)(void)
 EXPORT void HWRAPI(DrawIntermissionBG)(void)
 {
 	float xfix, yfix;
-	INT32 texsize = 2048;
 
 	const float screenVerts[12] =
 	{
@@ -3241,11 +3226,6 @@ EXPORT void HWRAPI(DrawIntermissionBG)(void)
 
 	float fix[8];
 
-	if(screen_width <= 1024)
-		texsize = 1024;
-	if(screen_width <= 512)
-		texsize = 512;
-
 	xfix = 1/((float)(texsize)/((float)((screen_width))));
 	yfix = 1/((float)(texsize)/((float)((screen_height))));
 
@@ -3276,7 +3256,6 @@ EXPORT void HWRAPI(DrawIntermissionBG)(void)
 // Do screen fades!
 EXPORT void HWRAPI(DoScreenWipe)(void)
 {
-	INT32 texsize = 2048;
 	float xfix, yfix;
 
 	INT32 fademaskdownloaded = tex_downloaded; // the fade mask that has been set
@@ -3299,12 +3278,6 @@ EXPORT void HWRAPI(DoScreenWipe)(void)
 		1.0f, 1.0f
 	};
 
-	// Use a power of two texture, dammit
-	if(screen_width <= 1024)
-		texsize = 1024;
-	if(screen_width <= 512)
-		texsize = 512;
-
 	xfix = 1/((float)(texsize)/((float)((screen_width))));
 	yfix = 1/((float)(texsize)/((float)((screen_height))));
 
@@ -3367,15 +3340,8 @@ EXPORT void HWRAPI(DoScreenWipe)(void)
 // Create a texture from the screen.
 EXPORT void HWRAPI(MakeScreenTexture) (void)
 {
-	INT32 texsize = 2048;
 	boolean firstTime = (screentexture == 0);
 
-	// Use a power of two texture, dammit
-	if(screen_width <= 512)
-		texsize = 512;
-	else if(screen_width <= 1024)
-		texsize = 1024;
-
 	// Create screen texture
 	if (firstTime)
 		pglGenTextures(1, &screentexture);
@@ -3397,15 +3363,8 @@ EXPORT void HWRAPI(MakeScreenTexture) (void)
 
 EXPORT void HWRAPI(MakeScreenFinalTexture) (void)
 {
-	INT32 texsize = 2048;
 	boolean firstTime = (finalScreenTexture == 0);
 
-	// Use a power of two texture, dammit
-	if(screen_width <= 512)
-		texsize = 512;
-	else if(screen_width <= 1024)
-		texsize = 1024;
-
 	// Create screen texture
 	if (firstTime)
 		pglGenTextures(1, &finalScreenTexture);
@@ -3431,16 +3390,10 @@ EXPORT void HWRAPI(DrawScreenFinalTexture)(int width, int height)
 	float origaspect, newaspect;
 	float xoff = 1, yoff = 1; // xoffset and yoffset for the polygon to have black bars around the screen
 	FRGBAFloat clearColour;
-	INT32 texsize = 2048;
 
 	float off[12];
 	float fix[8];
 
-	if(screen_width <= 1024)
-		texsize = 1024;
-	if(screen_width <= 512)
-		texsize = 512;
-
 	xfix = 1/((float)(texsize)/((float)((screen_width))));
 	yfix = 1/((float)(texsize)/((float)((screen_height))));
 
-- 
GitLab


From 14f09b976df408976f7a47f76d097fa862247798 Mon Sep 17 00:00:00 2001
From: Zwip-Zwap Zapony <ZwipZwapZapony@gmail.com>
Date: Mon, 14 Aug 2023 16:04:30 +0200
Subject: [PATCH 27/27] Clamp screen textures to OpenGL's max texture size

---
 src/hardware/r_opengl/r_opengl.c | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/src/hardware/r_opengl/r_opengl.c b/src/hardware/r_opengl/r_opengl.c
index 0eb4b5abf4..6fda8d735c 100644
--- a/src/hardware/r_opengl/r_opengl.c
+++ b/src/hardware/r_opengl/r_opengl.c
@@ -1200,7 +1200,9 @@ static void GLProject(GLfloat objX, GLfloat objY, GLfloat objZ,
 // -----------------+
 void SetModelView(GLint w, GLint h)
 {
-//	GL_DBG_Printf("SetModelView(): %dx%d\n", (int)w, (int)h);
+	GLint maxtexsize = 0;
+
+	//GL_DBG_Printf("SetModelView(): %dx%d\n", (int)w, (int)h);
 
 	// The screen textures need to be flushed if the width or height change so that they be remade for the correct size
 	if (screen_width != w || screen_height != h)
@@ -1209,10 +1211,20 @@ void SetModelView(GLint w, GLint h)
 	screen_width = w;
 	screen_height = h;
 	texsize = 512;
-	// Use a power of two texture, dammit
-	while (texsize < screen_width || texsize < screen_height)
+	while (texsize < w || texsize < h)
 	{
-		texsize *= 2;
+		texsize *= 2; // Use a power of two texture, dammit
+	}
+
+	pglGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxtexsize); // Get the maximum supported texture size
+	if (texsize > maxtexsize && maxtexsize > 0)
+	{
+		// The desired screen texture resolution is too big for the player's GPU!
+		CONS_Alert(CONS_WARNING, "Tried to make a screen texture for a %dx%d game resolution, but your GPU only supports up to %dx%d! Please switch to the software renderer or lower your game resolution.\n", w, h, maxtexsize, maxtexsize);
+
+		// For now, let's just pray that clamping it to the maximum supported size "works"
+		// There'll be a stretchy "border" artefact, but it's better than failing to make the screen textures
+		texsize = maxtexsize;
 	}
 
 	pglViewport(0, 0, w, h);
-- 
GitLab

